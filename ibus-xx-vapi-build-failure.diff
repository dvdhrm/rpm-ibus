--- ibus/ui/gtk3/Gkbd-3.0.gi.foo	1970-01-01 09:00:00.000000000 +0900
+++ ibus/ui/gtk3/Gkbd-3.0.gi	2012-03-09 16:09:11.478018975 +0900
@@ -0,0 +1,74 @@
+<?xml version="1.0"?>
+<api version="1.0">
+        <namespace name="Gkbd">
+                <function name="configuration_get" symbol="gkbd_configuration_get">
+                        <return-type type="GkbdConfiguration*"/>
+                        <parameters/>
+                </function>
+                <object name="GkbdConfiguration"
+                        parent="GObject"
+                        type-name="GkbdConfiguration"
+                        get-type="gkbd_configuration_get_type">
+                        <field name="parent" type="GObject"/>
+                        <method name="get_short_group_names"
+                                symbol="gkbd_configuration_get_short_group_names">
+                                <return-type type="gchar**"/>
+                                <parameters>
+                                        <parameter name="configuration"
+                                                   type="GkbdConfiguration*"/>
+                                </parameters>
+                        </method>
+                        <method name="get_group_names"
+                                symbol="gkbd_configuration_get_group_names">
+                                <return-type type="gchar**"/>
+                                <parameters>
+                                        <parameter name="configuration"
+                                                   type="GkbdConfiguration*"/>
+                                </parameters>
+                        </method>
+                        <method name="lock_group"
+                                symbol="gkbd_configuration_lock_group">
+                                <return-type type="void"/>
+                                <parameters>
+                                        <parameter name="configuration"
+                                                   type="GkbdConfiguration*"/>
+                                        <parameter name="group" type="guint"/>
+                                </parameters>
+                        </method>
+                        <method name="start_listen"
+                                symbol="gkbd_configuration_start_listen">
+                                <return-type type="void"/>
+                                <parameters>
+                                        <parameter name="configuration"
+                                                   type="GkbdConfiguration*"/>
+                                </parameters>
+                        </method>
+                        <method name="stop_listen"
+                                symbol="gkbd_configuration_stop_listen">
+                                <return-type type="void"/>
+                                <parameters>
+                                        <parameter name="configuration"
+                                                   type="GkbdConfiguration*"/>
+                                </parameters>
+                        </method>
+                        <signal name="changed" when="LAST">
+                                <return-type type="void"/>
+                        </signal>
+                        <signal name="group-changed" when="LAST">
+                                <return-type type="void"/>
+                                <parameters>
+                                        <parameter name="configuration"
+                                                   type="GkbdConfiguration*"/>
+                                        <parameter name="object" type="int"/>
+                                </parameters>
+                        </signal>
+                        <signal name="indicators-changed" when="LAST">
+                                <return-type type="void"/>
+                                <parameters>
+                                        <parameter name="configuration"
+                                                   type="GkbdConfiguration*"/>
+                                </parameters>
+                        </signal>
+                </object>
+        </namespace>
+</api>
--- ibus/ui/gtk3/Gkbd-3.0.metadata.orig	2012-03-09 11:51:03.509354266 +0900
+++ ibus/ui/gtk3/Gkbd-3.0.metadata	2012-03-09 16:27:38.143929799 +0900
@@ -1 +1,4 @@
+Gkbd cheader_filename="libgnomekbd/gkbd-configuration.h"
 Configuration cheader_filename="libgnomekbd/gkbd-configuration.h"
+//gkbd_configuration_get_short_group_names type_name="string[]"
+//gkbd_configuration_get_group_names type_name="string[]"
--- ibus/ui/gtk3/Makefile.am.orig	2012-03-09 17:59:30.327728137 +0900
+++ ibus/ui/gtk3/Makefile.am	2012-03-09 18:01:04.274430683 +0900
@@ -85,6 +85,7 @@ AM_VALAFLAGS = \
 	--pkg=gtk+-3.0 \
 	--pkg=gdk-x11-3.0 \
 	--pkg=ibus-1.0 \
+	--pkg=Xkl-1.0 \
 	$(NULL)
 
 libexec_PROGRAMS = ibus-ui-gtk3
@@ -106,8 +107,12 @@ ibus_ui_gtk3_valas = \
 	$(NULL)
 ibus_ui_gtk3_vala_cfiles = $(ibus_ui_gtk3_valas:.vala=.c)
 
+#ibus_ui_gtk3_SOURCES = \
+#	$(ibus_ui_gtk3_valas) \
+#	grabkeycode.c \
+#	$(NULL)
 ibus_ui_gtk3_SOURCES = \
-	$(ibus_ui_gtk3_valas) \
+	$(ibus_ui_gtk3_vala_cfiles) \
 	grabkeycode.c \
 	$(NULL)
 
@@ -133,6 +138,11 @@ AM_VALAFLAGS += \
 	--pkg=gkbd \
 	$(NULL)
 
+# FIXME: Running vapigen Gkbd-3.0.gir cannot resolve the type name error:
+#
+# Xkl-1.0.gir:877.51-877.51: error: The type name `X.XEvent' could not be found
+#             <type name="xlib.XEvent" c:type="XEvent*"/>
+#                                                  ^
 $(srcdir)/gkbd.vapi:
 	$(VAPIGEN) --metadatadir . --library gkbd \
 	    --pkg gtk+-3.0 --pkg glib-2.0 --pkg gmodule-2.0 \
@@ -141,20 +151,28 @@ $(srcdir)/gkbd.vapi:
 
 $(srcdir)/gkbdlayout.vala: $(srcdir)/gkbd.vapi
 	@cp $(srcdir)/gkbdlayout.vala.true $(srcdir)/gkbdlayout.vala
+	@cp $(srcdir)/gkbdlayout.c.true $(srcdir)/gkbdlayout.c
 else
 $(srcdir)/gkbdlayout.vala:
 	@cp $(srcdir)/gkbdlayout.vala.false $(srcdir)/gkbdlayout.vala
+	@cp $(srcdir)/gkbdlayout.c.false $(srcdir)/gkbdlayout.c
 endif
 
+srcdir)/panel.c: $(srcdir)/panel.c.in
+	@cp $(srcdir)/panel.c.in $(srcdir)/panel.c
+
 CLEANFILES = \
-	gkbd.vapi \
 	gkbdlayout.vala \
 	gtkpanel.xml \
 	$(ibus_ui_gtk3_vala_cfiles) \
 	$(NULL)
 
 EXTRA_DIST = \
+	gkbd.vapi \
+	Gkbd-3.0.gi \
 	Gkbd-3.0.metadata \
+	gkbdlayout.c.false \
+	gkbdlayout.c.true \
 	gkbdlayout.vala.false \
 	gkbdlayout.vala.true \
 	gtkpanel.xml.in.in \
--- ibus/ui/gtk3/gkbd.vapi.foo	1970-01-01 09:00:00.000000000 +0900
+++ ibus/ui/gtk3/gkbd.vapi	2012-03-09 16:30:37.641184566 +0900
@@ -0,0 +1,282 @@
+/* gkbd.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "Gkbd", gir_namespace = "Gkbd", gir_version = "3.0", lower_case_cprefix = "gkbd_")]
+namespace Gkbd {
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", type_id = "gkbd_configuration_get_type ()")]
+	public class Configuration : GLib.Object {
+		[CCode (has_construct_function = false)]
+		protected Configuration ();
+		public void append_object (GLib.Object obj);
+		public static string create_label_title (int group, GLib.HashTable<void*,void*> ln2cnt_map, string layout_name);
+		public string extract_layout_name (int group);
+		public void free_images (GLib.SList<Gdk.Pixbuf> images);
+		public static Gkbd.Configuration @get ();
+		public unowned GLib.SList<GLib.Object> get_all_objects ();
+		public bool get_caps_lock_state ();
+		public uint get_current_group ();
+		public string get_current_tooltip ();
+		public string get_group_name (uint group);
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned string[] get_group_names ();
+		public string get_image_filename (uint group);
+		public Gkbd.IndicatorConfig get_indicator_config ();
+		public Gkbd.KeyboardConfig get_keyboard_config ();
+		public bool get_num_lock_state ();
+		public bool get_scroll_lock_state ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned string[] get_short_group_names ();
+		public unowned Xkl.Engine get_xkl_engine ();
+		public bool if_any_object_exists ();
+		public bool if_flags_shown ();
+		public GLib.SList<Gdk.Pixbuf> load_images ();
+		public void lock_group (uint group);
+		public void lock_next_group ();
+		public void remove_object (GLib.Object obj);
+		public void start_listen ();
+		public void stop_listen ();
+		public signal void changed ();
+		public signal void group_changed (int object);
+		public signal void indicators_changed ();
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", type_id = "gkbd_indicator_get_type ()")]
+	public class Indicator : Gtk.Notebook, Atk.Implementor, Gtk.Buildable {
+		[CCode (has_construct_function = false, type = "GtkWidget*")]
+		public Indicator ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public static unowned string[] get_group_names ();
+		public static string get_image_filename (uint group);
+		public static double get_max_width_height_ratio ();
+		public static unowned Xkl.Engine get_xkl_engine ();
+		public void set_angle (double angle);
+		public void set_parent_tooltips (bool ifset);
+		[HasEmitter]
+		public virtual signal void reinit_ui ();
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", type_id = "gkbd_keyboard_drawing_get_type ()")]
+	public class KeyboardDrawing : Gtk.DrawingArea, Atk.Implementor, Gtk.Buildable {
+		[CCode (has_construct_function = false, type = "GtkWidget*")]
+		public KeyboardDrawing ();
+		[CCode (has_construct_function = false, type = "GtkWidget*")]
+		public KeyboardDrawing.dialog_new ();
+		public static void dialog_set_group (Gtk.Widget dialog, Xkl.ConfigRegistry registry, int group);
+		public static void dialog_set_layout (Gtk.Widget dialog, Xkl.ConfigRegistry registry, string layout);
+		public unowned string get_compat ();
+		public unowned string get_geometry ();
+		public unowned string get_keycodes ();
+		public unowned string get_symbols ();
+		public unowned string get_types ();
+		public void print (Gtk.Window parent_window, string description);
+		public bool render (Cairo.Context cr, Pango.Layout layout, double x, double y, double width, double height, double dpi_x, double dpi_y);
+		public void set_groups_levels (Gkbd.KeyboardDrawingGroupLevel groupLevels);
+		public void set_layout (string id);
+		public void set_track_config (bool enable);
+		public void set_track_modifiers (bool enable);
+		public virtual signal void bad_keycode (uint keycode);
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", type_id = "gkbd_status_get_type ()")]
+	public class Status : Gtk.StatusIcon {
+		[CCode (has_construct_function = false, type = "GtkStatusIcon*")]
+		public Status ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public static unowned string[] get_group_names ();
+		public static string get_image_filename (uint group);
+		public static unowned Xkl.Engine get_xkl_engine ();
+		public void reinit_ui ();
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct DesktopConfig {
+		public int default_group;
+		public bool group_per_app;
+		public bool handle_indicators;
+		public bool layout_names_as_group_names;
+		public bool load_extra_items;
+		public weak GLib.Settings settings;
+		public int config_listener_id;
+		public weak Xkl.Engine engine;
+		public bool activate ();
+		public void init (Xkl.Engine engine);
+		public void load ();
+		public bool load_group_descriptions (Xkl.ConfigRegistry registry, string layout_ids, string variant_ids, string short_group_names, string full_group_names);
+		public void lock_next_group ();
+		public void lock_prev_group ();
+		public void restore_group ();
+		public void save ();
+		public void start_listen (GLib.Callback func);
+		public void stop_listen ();
+		public void term ();
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct IndicatorConfig {
+		public int secondary_groups_mask;
+		public bool show_flags;
+		public weak string font_family;
+		public int font_size;
+		public weak string foreground_color;
+		public weak string background_color;
+		public weak string enabled_plugins;
+		public weak GLib.Settings settings;
+		public weak GLib.SList<void*> image_filenames;
+		public weak Gtk.IconTheme icon_theme;
+		public int config_listener_id;
+		public weak Xkl.Engine engine;
+		public void activate ();
+		public void free_image_filenames ();
+		public string get_fg_color_for_widget (Gtk.Widget widget);
+		public void get_font_for_widget (Gtk.Widget widget, string font_family, int font_size);
+		public string get_images_file (Gkbd.KeyboardConfig kbd_config, int group);
+		public void init (Xkl.Engine engine);
+		public void load ();
+		public void load_image_filenames (Gkbd.KeyboardConfig kbd_config);
+		public void refresh_style ();
+		public void save ();
+		public void start_listen (GLib.Callback func);
+		public void stop_listen ();
+		public void term ();
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct IndicatorPlugin {
+		public weak string name;
+		public weak string description;
+		public weak Gkbd.IndicatorPluginInitFunc init_callback;
+		public weak Gkbd.IndicatorPluginTermFunc term_callback;
+		public weak Gkbd.IndicatorPluginConfigureProperties configure_properties_callback;
+		public weak Gkbd.IndicatorPluginGroupChangedFunc group_changed_callback;
+		public weak Gkbd.IndicatorPluginWindowCreatedFunc window_created_callback;
+		public weak Gkbd.IndicatorPluginConfigChangedFunc config_changed_callback;
+		public static uint get_num_groups (Gkbd.IndicatorPluginContainer pc);
+		[CCode (array_length = false, array_null_terminated = true)]
+		public static unowned string[] load_localized_group_names (Gkbd.IndicatorPluginContainer pc);
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct IndicatorPluginContainer {
+		public weak GLib.Settings settings;
+		public void init ();
+		public void reinit_ui ();
+		public void term ();
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct IndicatorPluginManager {
+		public weak GLib.HashTable<void*,void*> all_plugin_recs;
+		public weak GLib.SList<void*> inited_plugin_recs;
+		public void config_changed (Gkbd.KeyboardConfig from, Gkbd.KeyboardConfig to);
+		public void configure_plugin (Gkbd.IndicatorPluginContainer pc, string full_path, Gtk.Window parent);
+		public Gtk.Widget decorate_widget (Gtk.Widget widget, int group, string group_description, Gkbd.KeyboardConfig config);
+		public void demote_plugin (string enabled_plugins, string full_path);
+		public void disable_plugin (string enabled_plugins, string full_path);
+		public void enable_plugin (string enabled_plugins, string full_path);
+		public Gkbd.IndicatorPlugin get_plugin (string full_path);
+		public void group_changed (Gtk.Widget notebook, int new_group);
+		public void init ();
+		public void init_enabled_plugins (Gkbd.IndicatorPluginContainer pc, string enabled_plugins);
+		public void promote_plugin (string enabled_plugins, string full_path);
+		public void term ();
+		public void term_initialized_plugins ();
+		public void toggle_plugins (Gkbd.IndicatorPluginContainer pc, string enabled_plugins);
+		public int window_created (X.Window win, X.Window parent);
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct IndicatorPluginManagerRecord {
+		public weak string full_path;
+		public weak GLib.Module module;
+		public Gkbd.IndicatorPlugin plugin;
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct KeyboardConfig {
+		public weak string model;
+		public weak string layouts_variants;
+		public weak string options;
+		public weak GLib.Settings settings;
+		public int config_listener_id;
+		public weak Xkl.Engine engine;
+		public bool activate ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public static string[] add_default_switch_option_if_necessary (string layouts_list, string options_list, bool was_appended);
+		public bool equals (Gkbd.KeyboardConfig kbd_config2);
+		public static unowned string format_full_description (string layout_descr, string variant_descr);
+		public static bool get_descriptions (Xkl.ConfigRegistry config_registry, string name, string layout_short_descr, string layout_descr, string variant_short_descr, string variant_descr);
+		public void init (Xkl.Engine engine);
+		public void load (Gkbd.KeyboardConfig kbd_config_default);
+		public void load_from_x_current (Xkl.ConfigRec buf);
+		public void load_from_x_initial (Xkl.ConfigRec buf);
+		public static unowned string merge_items (string parent, string child);
+		public void save ();
+		public static bool split_items (string merged, string parent, string child);
+		public void start_listen (GLib.Callback func);
+		public void stop_listen ();
+		public void term ();
+		public string to_string ();
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct KeyboardDrawingDoodad {
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct KeyboardDrawingGroupLevel {
+		public int group;
+		public int level;
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct KeyboardDrawingItem {
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct KeyboardDrawingKey {
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_type_id = false)]
+	public struct KeyboardDrawingRenderContext {
+		public weak Cairo.Context cr;
+		public int angle;
+		public weak Pango.Layout layout;
+		public weak Pango.FontDescription font_desc;
+		public int scale_numerator;
+		public int scale_denominator;
+		public Gdk.RGBA dark_color;
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", cprefix = "GKBD_KEYBOARD_DRAWING_POS_")]
+	public enum KeyboardDrawingGroupLevelPosition {
+		TOPLEFT,
+		TOPRIGHT,
+		BOTTOMLEFT,
+		BOTTOMRIGHT,
+		TOTAL,
+		FIRST,
+		LAST
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", cprefix = "GKBD_KEYBOARD_DRAWING_ITEM_TYPE_")]
+	public enum KeyboardDrawingItemType {
+		INVALID,
+		KEY,
+		KEY_EXTRA,
+		DOODAD
+	}
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_target = false)]
+	public delegate void IndicatorPluginConfigChangedFunc (Gkbd.KeyboardConfig from, Gkbd.KeyboardConfig to);
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_target = false)]
+	public delegate void IndicatorPluginConfigureProperties (Gkbd.IndicatorPluginContainer pc, Gtk.Window parent);
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_target = false)]
+	public delegate void* IndicatorPluginGetPluginFunc ();
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_target = false)]
+	public delegate void IndicatorPluginGroupChangedFunc (Gtk.Widget notebook, int new_group);
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_target = false)]
+	public delegate bool IndicatorPluginInitFunc (Gkbd.IndicatorPluginContainer pc);
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_target = false)]
+	public delegate void IndicatorPluginTermFunc ();
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", has_target = false)]
+	public delegate int IndicatorPluginWindowCreatedFunc (X.Window win, X.Window parent);
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", cname = "GKBD_DESKTOP_SCHEMA")]
+	public const string DESKTOP_SCHEMA;
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", cname = "GKBD_KEYBOARD_DRAWING_H")]
+	public const int KEYBOARD_DRAWING_H;
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h", cname = "GKBD_KEYBOARD_SCHEMA")]
+	public const string KEYBOARD_SCHEMA;
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h")]
+	public static void install_glib_log_appender ();
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h")]
+	public static Gdk.Rectangle preview_load_position ();
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h")]
+	public static void preview_save_position (Gdk.Rectangle rect);
+	[CCode (array_length = false, array_null_terminated = true, cheader_filename = "libgnomekbd/gkbd-configuration.h")]
+	public static string[] strv_append (string arr, string element);
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h")]
+	public static void strv_behead (string arr);
+	[CCode (cheader_filename = "libgnomekbd/gkbd-configuration.h")]
+	public static bool strv_remove (string arr, string element);
+}
--- ibus/ui/gtk3/gkbdlayout.c.false.orig	2012-03-09 16:42:59.688639882 +0900
+++ ibus/ui/gtk3/gkbdlayout.c.false	2012-03-09 16:42:53.950535836 +0900
@@ -0,0 +1,307 @@
+/* gkbdlayout.c generated by valac 0.15.1, the Vala compiler
+ * generated from gkbdlayout.vala, do not modify */
+
+/* vim:set et sts=4 sw=4:
+ *
+ * ibus - The Input Bus
+ *
+ * Copyright 2012 Red Hat, Inc.
+ * Copyright(c) 2012 Peng Huang <shawn.p.huang@gmail.com>
+ * Copyright(c) 2012 Takao Fujiwara <tfujiwar@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or(at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA  02111-1307  USA
+ */
+
+#include <glib.h>
+#include <glib-object.h>
+#include <stdlib.h>
+#include <string.h>
+#include <gobject/gvaluecollector.h>
+
+
+#define TYPE_GKBD_LAYOUT (gkbd_layout_get_type ())
+#define GKBD_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GKBD_LAYOUT, GkbdLayout))
+#define GKBD_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GKBD_LAYOUT, GkbdLayoutClass))
+#define IS_GKBD_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GKBD_LAYOUT))
+#define IS_GKBD_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GKBD_LAYOUT))
+#define GKBD_LAYOUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GKBD_LAYOUT, GkbdLayoutClass))
+
+typedef struct _GkbdLayout GkbdLayout;
+typedef struct _GkbdLayoutClass GkbdLayoutClass;
+typedef struct _GkbdLayoutPrivate GkbdLayoutPrivate;
+typedef struct _ParamSpecGkbdLayout ParamSpecGkbdLayout;
+
+struct _GkbdLayout {
+	GTypeInstance parent_instance;
+	volatile int ref_count;
+	GkbdLayoutPrivate * priv;
+};
+
+struct _GkbdLayoutClass {
+	GTypeClass parent_class;
+	void (*finalize) (GkbdLayout *self);
+};
+
+struct _ParamSpecGkbdLayout {
+	GParamSpec parent_instance;
+};
+
+
+static gpointer gkbd_layout_parent_class = NULL;
+
+gpointer gkbd_layout_ref (gpointer instance);
+void gkbd_layout_unref (gpointer instance);
+GParamSpec* param_spec_gkbd_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
+void value_set_gkbd_layout (GValue* value, gpointer v_object);
+void value_take_gkbd_layout (GValue* value, gpointer v_object);
+gpointer value_get_gkbd_layout (const GValue* value);
+GType gkbd_layout_get_type (void) G_GNUC_CONST;
+enum  {
+	GKBD_LAYOUT_DUMMY_PROPERTY
+};
+GkbdLayout* gkbd_layout_new (void);
+GkbdLayout* gkbd_layout_construct (GType object_type);
+gchar** gkbd_layout_get_layouts (GkbdLayout* self, int* result_length1);
+gchar** gkbd_layout_get_group_names (GkbdLayout* self, int* result_length1);
+void gkbd_layout_lock_group (GkbdLayout* self, gint id);
+void gkbd_layout_start_listen (GkbdLayout* self);
+void gkbd_layout_stop_listen (GkbdLayout* self);
+static void gkbd_layout_finalize (GkbdLayout* obj);
+
+
+GkbdLayout* gkbd_layout_construct (GType object_type) {
+	GkbdLayout* self = NULL;
+	self = (GkbdLayout*) g_type_create_instance (object_type);
+	return self;
+}
+
+
+GkbdLayout* gkbd_layout_new (void) {
+	return gkbd_layout_construct (TYPE_GKBD_LAYOUT);
+}
+
+
+gchar** gkbd_layout_get_layouts (GkbdLayout* self, int* result_length1) {
+	gchar** result = NULL;
+	gchar** _tmp0_ = NULL;
+	gchar** _tmp1_;
+	gint _tmp1__length1;
+	g_return_val_if_fail (self != NULL, NULL);
+	_tmp0_ = g_new0 (gchar*, 0 + 1);
+	_tmp1_ = _tmp0_;
+	_tmp1__length1 = 0;
+	if (result_length1) {
+		*result_length1 = _tmp1__length1;
+	}
+	result = _tmp1_;
+	return result;
+}
+
+
+gchar** gkbd_layout_get_group_names (GkbdLayout* self, int* result_length1) {
+	gchar** result = NULL;
+	gchar** _tmp0_ = NULL;
+	gchar** _tmp1_;
+	gint _tmp1__length1;
+	g_return_val_if_fail (self != NULL, NULL);
+	_tmp0_ = g_new0 (gchar*, 0 + 1);
+	_tmp1_ = _tmp0_;
+	_tmp1__length1 = 0;
+	if (result_length1) {
+		*result_length1 = _tmp1__length1;
+	}
+	result = _tmp1_;
+	return result;
+}
+
+
+void gkbd_layout_lock_group (GkbdLayout* self, gint id) {
+	g_return_if_fail (self != NULL);
+}
+
+
+void gkbd_layout_start_listen (GkbdLayout* self) {
+	g_return_if_fail (self != NULL);
+}
+
+
+void gkbd_layout_stop_listen (GkbdLayout* self) {
+	g_return_if_fail (self != NULL);
+}
+
+
+static void value_gkbd_layout_init (GValue* value) {
+	value->data[0].v_pointer = NULL;
+}
+
+
+static void value_gkbd_layout_free_value (GValue* value) {
+	if (value->data[0].v_pointer) {
+		gkbd_layout_unref (value->data[0].v_pointer);
+	}
+}
+
+
+static void value_gkbd_layout_copy_value (const GValue* src_value, GValue* dest_value) {
+	if (src_value->data[0].v_pointer) {
+		dest_value->data[0].v_pointer = gkbd_layout_ref (src_value->data[0].v_pointer);
+	} else {
+		dest_value->data[0].v_pointer = NULL;
+	}
+}
+
+
+static gpointer value_gkbd_layout_peek_pointer (const GValue* value) {
+	return value->data[0].v_pointer;
+}
+
+
+static gchar* value_gkbd_layout_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
+	if (collect_values[0].v_pointer) {
+		GkbdLayout* object;
+		object = collect_values[0].v_pointer;
+		if (object->parent_instance.g_class == NULL) {
+			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
+		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
+			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
+		}
+		value->data[0].v_pointer = gkbd_layout_ref (object);
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	return NULL;
+}
+
+
+static gchar* value_gkbd_layout_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
+	GkbdLayout** object_p;
+	object_p = collect_values[0].v_pointer;
+	if (!object_p) {
+		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
+	}
+	if (!value->data[0].v_pointer) {
+		*object_p = NULL;
+	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
+		*object_p = value->data[0].v_pointer;
+	} else {
+		*object_p = gkbd_layout_ref (value->data[0].v_pointer);
+	}
+	return NULL;
+}
+
+
+GParamSpec* param_spec_gkbd_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
+	ParamSpecGkbdLayout* spec;
+	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GKBD_LAYOUT), NULL);
+	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
+	G_PARAM_SPEC (spec)->value_type = object_type;
+	return G_PARAM_SPEC (spec);
+}
+
+
+gpointer value_get_gkbd_layout (const GValue* value) {
+	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GKBD_LAYOUT), NULL);
+	return value->data[0].v_pointer;
+}
+
+
+void value_set_gkbd_layout (GValue* value, gpointer v_object) {
+	GkbdLayout* old;
+	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GKBD_LAYOUT));
+	old = value->data[0].v_pointer;
+	if (v_object) {
+		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GKBD_LAYOUT));
+		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
+		value->data[0].v_pointer = v_object;
+		gkbd_layout_ref (value->data[0].v_pointer);
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	if (old) {
+		gkbd_layout_unref (old);
+	}
+}
+
+
+void value_take_gkbd_layout (GValue* value, gpointer v_object) {
+	GkbdLayout* old;
+	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GKBD_LAYOUT));
+	old = value->data[0].v_pointer;
+	if (v_object) {
+		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GKBD_LAYOUT));
+		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
+		value->data[0].v_pointer = v_object;
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	if (old) {
+		gkbd_layout_unref (old);
+	}
+}
+
+
+static void gkbd_layout_class_init (GkbdLayoutClass * klass) {
+	gkbd_layout_parent_class = g_type_class_peek_parent (klass);
+	GKBD_LAYOUT_CLASS (klass)->finalize = gkbd_layout_finalize;
+	g_signal_new ("changed", TYPE_GKBD_LAYOUT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+	g_signal_new ("group_changed", TYPE_GKBD_LAYOUT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
+}
+
+
+static void gkbd_layout_instance_init (GkbdLayout * self) {
+	self->ref_count = 1;
+}
+
+
+static void gkbd_layout_finalize (GkbdLayout* obj) {
+	GkbdLayout * self;
+	self = GKBD_LAYOUT (obj);
+}
+
+
+GType gkbd_layout_get_type (void) {
+	static volatile gsize gkbd_layout_type_id__volatile = 0;
+	if (g_once_init_enter (&gkbd_layout_type_id__volatile)) {
+		static const GTypeValueTable g_define_type_value_table = { value_gkbd_layout_init, value_gkbd_layout_free_value, value_gkbd_layout_copy_value, value_gkbd_layout_peek_pointer, "p", value_gkbd_layout_collect_value, "p", value_gkbd_layout_lcopy_value };
+		static const GTypeInfo g_define_type_info = { sizeof (GkbdLayoutClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gkbd_layout_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GkbdLayout), 0, (GInstanceInitFunc) gkbd_layout_instance_init, &g_define_type_value_table };
+		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
+		GType gkbd_layout_type_id;
+		gkbd_layout_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GkbdLayout", &g_define_type_info, &g_define_type_fundamental_info, 0);
+		g_once_init_leave (&gkbd_layout_type_id__volatile, gkbd_layout_type_id);
+	}
+	return gkbd_layout_type_id__volatile;
+}
+
+
+gpointer gkbd_layout_ref (gpointer instance) {
+	GkbdLayout* self;
+	self = instance;
+	g_atomic_int_inc (&self->ref_count);
+	return instance;
+}
+
+
+void gkbd_layout_unref (gpointer instance) {
+	GkbdLayout* self;
+	self = instance;
+	if (g_atomic_int_dec_and_test (&self->ref_count)) {
+		GKBD_LAYOUT_GET_CLASS (self)->finalize (self);
+		g_type_free_instance ((GTypeInstance *) self);
+	}
+}
+
+
+
--- ibus/ui/gtk3/gkbdlayout.c.true.orig	2012-03-09 16:41:03.415531538 +0900
+++ ibus/ui/gtk3/gkbdlayout.c.true	2012-03-09 16:40:45.672209805 +0900
@@ -0,0 +1,490 @@
+/* gkbdlayout.c generated by valac 0.15.1, the Vala compiler
+ * generated from gkbdlayout.vala, do not modify */
+
+/* vim:set et sts=4 sw=4:
+ *
+ * ibus - The Input Bus
+ *
+ * Copyright 2012 Red Hat, Inc.
+ * Copyright(c) 2012 Peng Huang <shawn.p.huang@gmail.com>
+ * Copyright(c) 2012 Takao Fujiwara <tfujiwar@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or(at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA  02111-1307  USA
+ */
+
+#include <glib.h>
+#include <glib-object.h>
+#include <libgnomekbd/gkbd-configuration.h>
+#include <stdlib.h>
+#include <string.h>
+#include <gobject/gvaluecollector.h>
+
+
+#define TYPE_GKBD_LAYOUT (gkbd_layout_get_type ())
+#define GKBD_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GKBD_LAYOUT, GkbdLayout))
+#define GKBD_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GKBD_LAYOUT, GkbdLayoutClass))
+#define IS_GKBD_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GKBD_LAYOUT))
+#define IS_GKBD_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GKBD_LAYOUT))
+#define GKBD_LAYOUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GKBD_LAYOUT, GkbdLayoutClass))
+
+typedef struct _GkbdLayout GkbdLayout;
+typedef struct _GkbdLayoutClass GkbdLayoutClass;
+typedef struct _GkbdLayoutPrivate GkbdLayoutPrivate;
+#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
+typedef struct _ParamSpecGkbdLayout ParamSpecGkbdLayout;
+
+struct _GkbdLayout {
+	GTypeInstance parent_instance;
+	volatile int ref_count;
+	GkbdLayoutPrivate * priv;
+};
+
+struct _GkbdLayoutClass {
+	GTypeClass parent_class;
+	void (*finalize) (GkbdLayout *self);
+};
+
+struct _GkbdLayoutPrivate {
+	GkbdConfiguration* m_config;
+};
+
+struct _ParamSpecGkbdLayout {
+	GParamSpec parent_instance;
+};
+
+
+static gpointer gkbd_layout_parent_class = NULL;
+
+gpointer gkbd_layout_ref (gpointer instance);
+void gkbd_layout_unref (gpointer instance);
+GParamSpec* param_spec_gkbd_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
+void value_set_gkbd_layout (GValue* value, gpointer v_object);
+void value_take_gkbd_layout (GValue* value, gpointer v_object);
+gpointer value_get_gkbd_layout (const GValue* value);
+GType gkbd_layout_get_type (void) G_GNUC_CONST;
+#define GKBD_LAYOUT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GKBD_LAYOUT, GkbdLayoutPrivate))
+enum  {
+	GKBD_LAYOUT_DUMMY_PROPERTY
+};
+static void gkbd_layout_config_changed_cb (GkbdLayout* self);
+static void _gkbd_layout_config_changed_cb_gkbd_configuration_changed (GkbdConfiguration* _sender, gpointer self);
+static void gkbd_layout_config_group_changed_cb (GkbdLayout* self, gint object);
+static void _gkbd_layout_config_group_changed_cb_gkbd_configuration_group_changed (GkbdConfiguration* _sender, gint object, gpointer self);
+GkbdLayout* gkbd_layout_new (void);
+GkbdLayout* gkbd_layout_construct (GType object_type);
+gchar** gkbd_layout_get_layouts (GkbdLayout* self, int* result_length1);
+static gchar** _vala_array_dup2 (gchar** self, int length);
+gchar** gkbd_layout_get_group_names (GkbdLayout* self, int* result_length1);
+static gchar** _vala_array_dup3 (gchar** self, int length);
+void gkbd_layout_lock_group (GkbdLayout* self, gint id);
+void gkbd_layout_start_listen (GkbdLayout* self);
+void gkbd_layout_stop_listen (GkbdLayout* self);
+static void gkbd_layout_finalize (GkbdLayout* obj);
+static gint _vala_array_length (gpointer array);
+
+
+static void _gkbd_layout_config_changed_cb_gkbd_configuration_changed (GkbdConfiguration* _sender, gpointer self) {
+	gkbd_layout_config_changed_cb (self);
+}
+
+
+static void _gkbd_layout_config_group_changed_cb_gkbd_configuration_group_changed (GkbdConfiguration* _sender, gint object, gpointer self) {
+	gkbd_layout_config_group_changed_cb (self, object);
+}
+
+
+GkbdLayout* gkbd_layout_construct (GType object_type) {
+	GkbdLayout* self = NULL;
+	GkbdConfiguration* _tmp0_ = NULL;
+	GkbdConfiguration* _tmp1_;
+	self = (GkbdLayout*) g_type_create_instance (object_type);
+	_tmp0_ = gkbd_configuration_get ();
+	_g_object_unref0 (self->priv->m_config);
+	self->priv->m_config = _tmp0_;
+	_tmp1_ = self->priv->m_config;
+	if (_tmp1_ != NULL) {
+		GkbdConfiguration* _tmp2_;
+		GkbdConfiguration* _tmp3_;
+		_tmp2_ = self->priv->m_config;
+		g_signal_connect (_tmp2_, "changed", (GCallback) _gkbd_layout_config_changed_cb_gkbd_configuration_changed, self);
+		_tmp3_ = self->priv->m_config;
+		g_signal_connect (_tmp3_, "group-changed", (GCallback) _gkbd_layout_config_group_changed_cb_gkbd_configuration_group_changed, self);
+	}
+	return self;
+}
+
+
+GkbdLayout* gkbd_layout_new (void) {
+	return gkbd_layout_construct (TYPE_GKBD_LAYOUT);
+}
+
+
+static void gkbd_layout_config_changed_cb (GkbdLayout* self) {
+	g_return_if_fail (self != NULL);
+	g_signal_emit_by_name (self, "changed");
+}
+
+
+static void gkbd_layout_config_group_changed_cb (GkbdLayout* self, gint object) {
+	gint _tmp0_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = object;
+	g_signal_emit_by_name (self, "group-changed", _tmp0_);
+}
+
+
+static gchar** _vala_array_dup2 (gchar** self, int length) {
+	gchar** result;
+	int i;
+	result = g_new0 (gchar*, length + 1);
+	for (i = 0; i < length; i++) {
+		gchar* _tmp0_;
+		_tmp0_ = g_strdup (self[i]);
+		result[i] = _tmp0_;
+	}
+	return result;
+}
+
+
+gchar** gkbd_layout_get_layouts (GkbdLayout* self, int* result_length1) {
+	gchar** result = NULL;
+	GkbdConfiguration* _tmp0_;
+	GkbdConfiguration* _tmp3_;
+	gchar** _tmp4_;
+	gchar** _tmp5_ = NULL;
+	gchar** _tmp6_;
+	gint _tmp6__length1;
+	gchar** _tmp7_;
+	gint _tmp7__length1;
+	g_return_val_if_fail (self != NULL, NULL);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ == NULL) {
+		gchar** _tmp1_ = NULL;
+		gchar** _tmp2_;
+		gint _tmp2__length1;
+		_tmp1_ = g_new0 (gchar*, 0 + 1);
+		_tmp2_ = _tmp1_;
+		_tmp2__length1 = 0;
+		if (result_length1) {
+			*result_length1 = _tmp2__length1;
+		}
+		result = _tmp2_;
+		return result;
+	}
+	_tmp3_ = self->priv->m_config;
+	_tmp5_ = _tmp4_ = gkbd_configuration_get_short_group_names (_tmp3_);
+	_tmp6_ = (_tmp5_ != NULL) ? _vala_array_dup2 (_tmp5_, _vala_array_length (_tmp4_)) : ((gpointer) _tmp5_);
+	_tmp6__length1 = _vala_array_length (_tmp4_);
+	_tmp7_ = _tmp6_;
+	_tmp7__length1 = _tmp6__length1;
+	if (result_length1) {
+		*result_length1 = _tmp7__length1;
+	}
+	result = _tmp7_;
+	return result;
+}
+
+
+static gchar** _vala_array_dup3 (gchar** self, int length) {
+	gchar** result;
+	int i;
+	result = g_new0 (gchar*, length + 1);
+	for (i = 0; i < length; i++) {
+		gchar* _tmp0_;
+		_tmp0_ = g_strdup (self[i]);
+		result[i] = _tmp0_;
+	}
+	return result;
+}
+
+
+gchar** gkbd_layout_get_group_names (GkbdLayout* self, int* result_length1) {
+	gchar** result = NULL;
+	GkbdConfiguration* _tmp0_;
+	GkbdConfiguration* _tmp3_;
+	gchar** _tmp4_;
+	gchar** _tmp5_ = NULL;
+	gchar** _tmp6_;
+	gint _tmp6__length1;
+	gchar** _tmp7_;
+	gint _tmp7__length1;
+	g_return_val_if_fail (self != NULL, NULL);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ == NULL) {
+		gchar** _tmp1_ = NULL;
+		gchar** _tmp2_;
+		gint _tmp2__length1;
+		_tmp1_ = g_new0 (gchar*, 0 + 1);
+		_tmp2_ = _tmp1_;
+		_tmp2__length1 = 0;
+		if (result_length1) {
+			*result_length1 = _tmp2__length1;
+		}
+		result = _tmp2_;
+		return result;
+	}
+	_tmp3_ = self->priv->m_config;
+	_tmp5_ = _tmp4_ = gkbd_configuration_get_group_names (_tmp3_);
+	_tmp6_ = (_tmp5_ != NULL) ? _vala_array_dup3 (_tmp5_, _vala_array_length (_tmp4_)) : ((gpointer) _tmp5_);
+	_tmp6__length1 = _vala_array_length (_tmp4_);
+	_tmp7_ = _tmp6_;
+	_tmp7__length1 = _tmp6__length1;
+	if (result_length1) {
+		*result_length1 = _tmp7__length1;
+	}
+	result = _tmp7_;
+	return result;
+}
+
+
+void gkbd_layout_lock_group (GkbdLayout* self, gint id) {
+	GkbdConfiguration* _tmp0_;
+	GkbdConfiguration* _tmp1_;
+	gint _tmp2_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ == NULL) {
+		return;
+	}
+	_tmp1_ = self->priv->m_config;
+	_tmp2_ = id;
+	gkbd_configuration_lock_group (_tmp1_, (guint) _tmp2_);
+}
+
+
+void gkbd_layout_start_listen (GkbdLayout* self) {
+	GkbdConfiguration* _tmp0_;
+	GkbdConfiguration* _tmp1_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ == NULL) {
+		return;
+	}
+	_tmp1_ = self->priv->m_config;
+	gkbd_configuration_start_listen (_tmp1_);
+}
+
+
+void gkbd_layout_stop_listen (GkbdLayout* self) {
+	GkbdConfiguration* _tmp0_;
+	GkbdConfiguration* _tmp1_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ == NULL) {
+		return;
+	}
+	_tmp1_ = self->priv->m_config;
+	gkbd_configuration_stop_listen (_tmp1_);
+}
+
+
+static void value_gkbd_layout_init (GValue* value) {
+	value->data[0].v_pointer = NULL;
+}
+
+
+static void value_gkbd_layout_free_value (GValue* value) {
+	if (value->data[0].v_pointer) {
+		gkbd_layout_unref (value->data[0].v_pointer);
+	}
+}
+
+
+static void value_gkbd_layout_copy_value (const GValue* src_value, GValue* dest_value) {
+	if (src_value->data[0].v_pointer) {
+		dest_value->data[0].v_pointer = gkbd_layout_ref (src_value->data[0].v_pointer);
+	} else {
+		dest_value->data[0].v_pointer = NULL;
+	}
+}
+
+
+static gpointer value_gkbd_layout_peek_pointer (const GValue* value) {
+	return value->data[0].v_pointer;
+}
+
+
+static gchar* value_gkbd_layout_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
+	if (collect_values[0].v_pointer) {
+		GkbdLayout* object;
+		object = collect_values[0].v_pointer;
+		if (object->parent_instance.g_class == NULL) {
+			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
+		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
+			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
+		}
+		value->data[0].v_pointer = gkbd_layout_ref (object);
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	return NULL;
+}
+
+
+static gchar* value_gkbd_layout_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
+	GkbdLayout** object_p;
+	object_p = collect_values[0].v_pointer;
+	if (!object_p) {
+		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
+	}
+	if (!value->data[0].v_pointer) {
+		*object_p = NULL;
+	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
+		*object_p = value->data[0].v_pointer;
+	} else {
+		*object_p = gkbd_layout_ref (value->data[0].v_pointer);
+	}
+	return NULL;
+}
+
+
+GParamSpec* param_spec_gkbd_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
+	ParamSpecGkbdLayout* spec;
+	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GKBD_LAYOUT), NULL);
+	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
+	G_PARAM_SPEC (spec)->value_type = object_type;
+	return G_PARAM_SPEC (spec);
+}
+
+
+gpointer value_get_gkbd_layout (const GValue* value) {
+	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GKBD_LAYOUT), NULL);
+	return value->data[0].v_pointer;
+}
+
+
+void value_set_gkbd_layout (GValue* value, gpointer v_object) {
+	GkbdLayout* old;
+	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GKBD_LAYOUT));
+	old = value->data[0].v_pointer;
+	if (v_object) {
+		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GKBD_LAYOUT));
+		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
+		value->data[0].v_pointer = v_object;
+		gkbd_layout_ref (value->data[0].v_pointer);
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	if (old) {
+		gkbd_layout_unref (old);
+	}
+}
+
+
+void value_take_gkbd_layout (GValue* value, gpointer v_object) {
+	GkbdLayout* old;
+	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GKBD_LAYOUT));
+	old = value->data[0].v_pointer;
+	if (v_object) {
+		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GKBD_LAYOUT));
+		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
+		value->data[0].v_pointer = v_object;
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	if (old) {
+		gkbd_layout_unref (old);
+	}
+}
+
+
+static void gkbd_layout_class_init (GkbdLayoutClass * klass) {
+	gkbd_layout_parent_class = g_type_class_peek_parent (klass);
+	GKBD_LAYOUT_CLASS (klass)->finalize = gkbd_layout_finalize;
+	g_type_class_add_private (klass, sizeof (GkbdLayoutPrivate));
+	g_signal_new ("changed", TYPE_GKBD_LAYOUT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+	g_signal_new ("group_changed", TYPE_GKBD_LAYOUT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
+}
+
+
+static void gkbd_layout_instance_init (GkbdLayout * self) {
+	self->priv = GKBD_LAYOUT_GET_PRIVATE (self);
+	self->priv->m_config = NULL;
+	self->ref_count = 1;
+}
+
+
+static void gkbd_layout_finalize (GkbdLayout* obj) {
+	GkbdLayout * self;
+	GkbdConfiguration* _tmp0_;
+	self = GKBD_LAYOUT (obj);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ != NULL) {
+		GkbdConfiguration* _tmp1_;
+		guint _tmp2_ = 0U;
+		GkbdConfiguration* _tmp3_;
+		guint _tmp4_ = 0U;
+		GkbdConfiguration* _tmp5_;
+		_tmp1_ = self->priv->m_config;
+		g_signal_parse_name ("changed", gkbd_configuration_get_type (), &_tmp2_, NULL, FALSE);
+		g_signal_handlers_disconnect_matched (_tmp1_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _gkbd_layout_config_changed_cb_gkbd_configuration_changed, self);
+		_tmp3_ = self->priv->m_config;
+		g_signal_parse_name ("group-changed", gkbd_configuration_get_type (), &_tmp4_, NULL, FALSE);
+		g_signal_handlers_disconnect_matched (_tmp3_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp4_, 0, NULL, (GCallback) _gkbd_layout_config_group_changed_cb_gkbd_configuration_group_changed, self);
+		_tmp5_ = self->priv->m_config;
+		g_object_ref ((GObject*) _tmp5_);
+		_g_object_unref0 (self->priv->m_config);
+		self->priv->m_config = NULL;
+	}
+	_g_object_unref0 (self->priv->m_config);
+}
+
+
+GType gkbd_layout_get_type (void) {
+	static volatile gsize gkbd_layout_type_id__volatile = 0;
+	if (g_once_init_enter (&gkbd_layout_type_id__volatile)) {
+		static const GTypeValueTable g_define_type_value_table = { value_gkbd_layout_init, value_gkbd_layout_free_value, value_gkbd_layout_copy_value, value_gkbd_layout_peek_pointer, "p", value_gkbd_layout_collect_value, "p", value_gkbd_layout_lcopy_value };
+		static const GTypeInfo g_define_type_info = { sizeof (GkbdLayoutClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gkbd_layout_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GkbdLayout), 0, (GInstanceInitFunc) gkbd_layout_instance_init, &g_define_type_value_table };
+		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
+		GType gkbd_layout_type_id;
+		gkbd_layout_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GkbdLayout", &g_define_type_info, &g_define_type_fundamental_info, 0);
+		g_once_init_leave (&gkbd_layout_type_id__volatile, gkbd_layout_type_id);
+	}
+	return gkbd_layout_type_id__volatile;
+}
+
+
+gpointer gkbd_layout_ref (gpointer instance) {
+	GkbdLayout* self;
+	self = instance;
+	g_atomic_int_inc (&self->ref_count);
+	return instance;
+}
+
+
+void gkbd_layout_unref (gpointer instance) {
+	GkbdLayout* self;
+	self = instance;
+	if (g_atomic_int_dec_and_test (&self->ref_count)) {
+		GKBD_LAYOUT_GET_CLASS (self)->finalize (self);
+		g_type_free_instance ((GTypeInstance *) self);
+	}
+}
+
+
+static gint _vala_array_length (gpointer array) {
+	int length;
+	length = 0;
+	if (array) {
+		while (((gpointer*) array)[length]) {
+			length++;
+		}
+	}
+	return length;
+}
+
+
+
--- ibus/ui/gtk3/panel.c.in.orig	2012-03-09 17:06:03.339547266 +0900
+++ ibus/ui/gtk3/panel.c.in	2012-03-09 17:05:53.708372747 +0900
@@ -0,0 +1,3203 @@
+/* panel.c generated by valac 0.15.1, the Vala compiler
+ * generated from panel.vala, do not modify */
+
+/* vim:set et sts=4 sw=4:
+ *
+ * ibus - The Input Bus
+ *
+ * Copyright(c) 2011 Peng Huang <shawn.p.huang@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or(at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA  02111-1307  USA
+ */
+
+#include <glib.h>
+#include <glib-object.h>
+#include <ibus.h>
+#include <gtk/gtk.h>
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
+#include <gdk/gdk.h>
+#include <float.h>
+#include <math.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <glib/gi18n-lib.h>
+
+
+#define TYPE_PANEL (panel_get_type ())
+#define PANEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANEL, Panel))
+#define PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANEL, PanelClass))
+#define IS_PANEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANEL))
+#define IS_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANEL))
+#define PANEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANEL, PanelClass))
+
+typedef struct _Panel Panel;
+typedef struct _PanelClass PanelClass;
+typedef struct _PanelPrivate PanelPrivate;
+
+#define TYPE_CANDIDATE_PANEL (candidate_panel_get_type ())
+#define CANDIDATE_PANEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CANDIDATE_PANEL, CandidatePanel))
+#define CANDIDATE_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CANDIDATE_PANEL, CandidatePanelClass))
+#define IS_CANDIDATE_PANEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CANDIDATE_PANEL))
+#define IS_CANDIDATE_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CANDIDATE_PANEL))
+#define CANDIDATE_PANEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CANDIDATE_PANEL, CandidatePanelClass))
+
+typedef struct _CandidatePanel CandidatePanel;
+typedef struct _CandidatePanelClass CandidatePanelClass;
+
+#define TYPE_SWITCHER (switcher_get_type ())
+#define SWITCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SWITCHER, Switcher))
+#define SWITCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SWITCHER, SwitcherClass))
+#define IS_SWITCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SWITCHER))
+#define IS_SWITCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SWITCHER))
+#define SWITCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SWITCHER, SwitcherClass))
+
+typedef struct _Switcher Switcher;
+typedef struct _SwitcherClass SwitcherClass;
+
+#define TYPE_PROPERTY_MANAGER (property_manager_get_type ())
+#define PROPERTY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_MANAGER, PropertyManager))
+#define PROPERTY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_MANAGER, PropertyManagerClass))
+#define IS_PROPERTY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_MANAGER))
+#define IS_PROPERTY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_MANAGER))
+#define PROPERTY_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_MANAGER, PropertyManagerClass))
+
+typedef struct _PropertyManager PropertyManager;
+typedef struct _PropertyManagerClass PropertyManagerClass;
+
+#define TYPE_GKBD_LAYOUT (gkbd_layout_get_type ())
+#define GKBD_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GKBD_LAYOUT, GkbdLayout))
+#define GKBD_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GKBD_LAYOUT, GkbdLayoutClass))
+#define IS_GKBD_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GKBD_LAYOUT))
+#define IS_GKBD_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GKBD_LAYOUT))
+#define GKBD_LAYOUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GKBD_LAYOUT, GkbdLayoutClass))
+
+typedef struct _GkbdLayout GkbdLayout;
+typedef struct _GkbdLayoutClass GkbdLayoutClass;
+
+#define TYPE_XKB_LAYOUT (xkb_layout_get_type ())
+#define XKB_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XKB_LAYOUT, XKBLayout))
+#define XKB_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XKB_LAYOUT, XKBLayoutClass))
+#define IS_XKB_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XKB_LAYOUT))
+#define IS_XKB_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XKB_LAYOUT))
+#define XKB_LAYOUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XKB_LAYOUT, XKBLayoutClass))
+
+typedef struct _XKBLayout XKBLayout;
+typedef struct _XKBLayoutClass XKBLayoutClass;
+
+#define TYPE_KEYBINDING_MANAGER (keybinding_manager_get_type ())
+#define KEYBINDING_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEYBINDING_MANAGER, KeybindingManager))
+#define KEYBINDING_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEYBINDING_MANAGER, KeybindingManagerClass))
+#define IS_KEYBINDING_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEYBINDING_MANAGER))
+#define IS_KEYBINDING_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEYBINDING_MANAGER))
+#define KEYBINDING_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEYBINDING_MANAGER, KeybindingManagerClass))
+
+typedef struct _KeybindingManager KeybindingManager;
+typedef struct _KeybindingManagerClass KeybindingManagerClass;
+#define _g_free0(var) (var = (g_free (var), NULL))
+#define _gkbd_layout_unref0(var) ((var == NULL) ? NULL : (var = (gkbd_layout_unref (var), NULL)))
+#define _xkb_layout_unref0(var) ((var == NULL) ? NULL : (var = (xkb_layout_unref (var), NULL)))
+#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
+#define _property_manager_unref0(var) ((var == NULL) ? NULL : (var = (property_manager_unref (var), NULL)))
+#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
+#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
+#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))
+#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
+typedef struct _Block4Data Block4Data;
+
+#define TYPE_ICON_WIDGET (icon_widget_get_type ())
+#define ICON_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ICON_WIDGET, IconWidget))
+#define ICON_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ICON_WIDGET, IconWidgetClass))
+#define IS_ICON_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ICON_WIDGET))
+#define IS_ICON_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ICON_WIDGET))
+#define ICON_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ICON_WIDGET, IconWidgetClass))
+
+typedef struct _IconWidget IconWidget;
+typedef struct _IconWidgetClass IconWidgetClass;
+
+struct _Panel {
+	IBusPanelService parent_instance;
+	PanelPrivate * priv;
+};
+
+struct _PanelClass {
+	IBusPanelServiceClass parent_class;
+};
+
+struct _PanelPrivate {
+	IBusBus* m_bus;
+	IBusConfig* m_config;
+	GtkStatusIcon* m_status_icon;
+	GtkMenu* m_ime_menu;
+	GtkMenu* m_sys_menu;
+	IBusEngineDesc** m_engines;
+	gint m_engines_length1;
+	gint _m_engines_size_;
+	CandidatePanel* m_candidate_panel;
+	Switcher* m_switcher;
+	PropertyManager* m_property_manager;
+	GPid m_setup_pid;
+	GtkAboutDialog* m_about_dialog;
+	GkbdLayout* m_gkbdlayout;
+	XKBLayout* m_xkblayout;
+	gchar** m_layouts;
+	gint m_layouts_length1;
+	gint _m_layouts_size_;
+	gchar** m_variants;
+	gint m_variants_length1;
+	gint _m_variants_size_;
+	gint m_fallback_lock_id;
+	gboolean m_changed_xkb_option;
+	GTimer* m_changed_layout_timer;
+	gchar** ACCELERATOR_IME_HOTKEYS;
+	gint ACCELERATOR_IME_HOTKEYS_length1;
+	gint _ACCELERATOR_IME_HOTKEYS_size_;
+};
+
+typedef void (*KeybindingManagerKeybindingHandlerFunc) (GdkEvent* event, void* user_data);
+struct _Block4Data {
+	int _ref_count_;
+	Panel * self;
+	IBusEngineDesc* e;
+};
+
+
+static gpointer panel_parent_class = NULL;
+
+GType panel_get_type (void) G_GNUC_CONST;
+GType candidate_panel_get_type (void) G_GNUC_CONST;
+GType switcher_get_type (void) G_GNUC_CONST;
+gpointer property_manager_ref (gpointer instance);
+void property_manager_unref (gpointer instance);
+GParamSpec* param_spec_property_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
+void value_set_property_manager (GValue* value, gpointer v_object);
+void value_take_property_manager (GValue* value, gpointer v_object);
+gpointer value_get_property_manager (const GValue* value);
+GType property_manager_get_type (void) G_GNUC_CONST;
+gpointer gkbd_layout_ref (gpointer instance);
+void gkbd_layout_unref (gpointer instance);
+GParamSpec* param_spec_gkbd_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
+void value_set_gkbd_layout (GValue* value, gpointer v_object);
+void value_take_gkbd_layout (GValue* value, gpointer v_object);
+gpointer value_get_gkbd_layout (const GValue* value);
+GType gkbd_layout_get_type (void) G_GNUC_CONST;
+gpointer xkb_layout_ref (gpointer instance);
+void xkb_layout_unref (gpointer instance);
+GParamSpec* param_spec_xkb_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
+void value_set_xkb_layout (GValue* value, gpointer v_object);
+void value_take_xkb_layout (GValue* value, gpointer v_object);
+gpointer value_get_xkb_layout (const GValue* value);
+GType xkb_layout_get_type (void) G_GNUC_CONST;
+#define PANEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL, PanelPrivate))
+enum  {
+	PANEL_DUMMY_PROPERTY
+};
+GType keybinding_manager_get_type (void) G_GNUC_CONST;
+KeybindingManager* keybinding_manager_get_instance (void);
+void keybinding_manager_unbind (KeybindingManager* self, const gchar* accelerator);
+#define PANEL_ACCELERATOR_SWITCH_IME_FOREWARD "<Control>space"
+#define PANEL_ACCELERATOR_SWITCH_IME_BACKWARD "<Control><Shift>space"
+static void panel_gkbdlayout_changed_cb (Panel* self);
+static void _panel_gkbdlayout_changed_cb_gkbd_layout_changed (GkbdLayout* _sender, gpointer self);
+void gkbd_layout_stop_listen (GkbdLayout* self);
+Panel* panel_new (IBusBus* bus);
+Panel* panel_construct (GType object_type, IBusBus* bus);
+static void panel_status_icon_popup_menu_cb (Panel* self, GtkStatusIcon* status_icon, guint button, guint activate_time);
+static void _panel_status_icon_popup_menu_cb_gtk_status_icon_popup_menu (GtkStatusIcon* _sender, guint button, guint activate_time, gpointer self);
+static void panel_status_icon_activate_cb (Panel* self, GtkStatusIcon* status_icon);
+static void _panel_status_icon_activate_cb_gtk_status_icon_activate (GtkStatusIcon* _sender, gpointer self);
+CandidatePanel* candidate_panel_new (void);
+CandidatePanel* candidate_panel_construct (GType object_type);
+static void __lambda23_ (Panel* self, CandidatePanel* w);
+static void ___lambda23__candidate_panel_page_up (CandidatePanel* _sender, gpointer self);
+static void __lambda24_ (Panel* self, CandidatePanel* w);
+static void ___lambda24__candidate_panel_page_down (CandidatePanel* _sender, gpointer self);
+Switcher* switcher_new (void);
+Switcher* switcher_construct (GType object_type);
+PropertyManager* property_manager_new (void);
+PropertyManager* property_manager_construct (GType object_type);
+static void __lambda25_ (Panel* self, const gchar* k, gint s);
+static void ___lambda25__property_manager_property_activate (PropertyManager* _sender, const gchar* key, gint state, gpointer self);
+static void panel_set_keybinding (Panel* self);
+static void _vala_array_add9 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add11 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add12 (gchar*** array, int* length, int* size, gchar* value);
+gboolean keybinding_manager_bind (KeybindingManager* self, const gchar* accelerator, KeybindingManagerKeybindingHandlerFunc handler, void* handler_target);
+static void ____lambda26_ (Panel* self, GdkEvent* e);
+static void panel_handle_engine_switch (Panel* self, GdkEvent* event, gboolean revert);
+static void _____lambda26__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self);
+static void _____lambda27_ (Panel* self, GdkEvent* e);
+static void ______lambda27__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self);
+void panel_set_config (Panel* self, IBusConfig* config);
+static void panel_config_value_changed_cb (Panel* self, IBusConfig* config, const gchar* section, const gchar* name, GVariant* variant);
+static void _panel_config_value_changed_cb_ibus_config_value_changed (IBusConfig* _sender, const gchar* section, const gchar* name, GVariant* value, gpointer self);
+static void panel_init_engines_order (Panel* self);
+static void panel_update_engines (Panel* self, GVariant* var_engines, GVariant* var_order);
+void gkbd_layout_lock_group (GkbdLayout* self, gint id);
+void xkb_layout_reset_layout (XKBLayout* self);
+static void panel_update_xkb_engines (Panel* self);
+static void panel_init_gkbd (Panel* self);
+GkbdLayout* gkbd_layout_new (void);
+GkbdLayout* gkbd_layout_construct (GType object_type);
+void gkbd_layout_start_listen (GkbdLayout* self);
+XKBLayout* xkb_layout_new (IBusConfig* config);
+XKBLayout* xkb_layout_construct (GType object_type, IBusConfig* config);
+gchar* xkb_layout_get_layout (XKBLayout* self);
+gchar* xkb_layout_get_variant (XKBLayout* self);
+static void _g_free0_ (gpointer var);
+static void _g_list_free__g_free0_ (GList* self);
+static void _vala_array_add13 (gchar*** array, int* length, int* size, gchar* value);
+static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
+static void _vala_array_add14 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add15 (gchar*** array, int* length, int* size, gchar* value);
+static void panel_set_xkb_group_layout (Panel* self, const gchar* layout);
+gint* xkb_layout_set_layout (XKBLayout* self, const gchar* _layout, const gchar* _variant, const gchar* _option, int* result_length1);
+static gboolean panel_set_gkbd_layout (Panel* self, const gchar* layout);
+gchar** gkbd_layout_get_group_names (GkbdLayout* self, int* result_length1);
+static void panel_set_layout (Panel* self, const gchar* layout);
+static void panel_switch_engine (Panel* self, gint i, gboolean force);
+static void _vala_array_add16 (gchar*** array, int* length, int* size, gchar* value);
+guint keybinding_manager_get_primary_modifier (guint binding_mask);
+gboolean keybinding_manager_primary_modifier_still_pressed (GdkEvent* event, guint primary_modifier);
+gint switcher_run (Switcher* self, GdkEvent* event, IBusEngineDesc** engines, int engines_length1, gint index);
+static gchar** _vala_array_dup2 (gchar** self, int length);
+static void _vala_array_add17 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add18 (gchar*** array, int* length, int* size, gchar* value);
+static IBusEngineDesc** _vala_array_dup3 (IBusEngineDesc** self, int length);
+static IBusEngineDesc** _vala_array_dup4 (IBusEngineDesc** self, int length);
+static void panel_show_setup_dialog (Panel* self);
+static void __lambda18_ (Panel* self, GPid pid, gint state);
+static void ___lambda18__gchild_watch_func (GPid pid, gint status, gpointer self);
+static void panel_show_about_dialog (Panel* self);
+static void ___lambda17_ (Panel* self, GtkMenuItem* i);
+static void ____lambda17__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
+static void ___lambda19_ (Panel* self, GtkMenuItem* i);
+static void ____lambda19__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
+static void ___lambda20_ (Panel* self, GtkMenuItem* i);
+static void ____lambda20__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
+static void ___lambda21_ (Panel* self, GtkMenuItem* i);
+static void ____lambda21__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
+static void _gtk_status_icon_position_menu_gtk_menu_position_func (GtkMenu* menu, gint* x, gint* y, gboolean* push_in, gpointer self);
+gint property_manager_create_menu_items (PropertyManager* self, GtkMenu* menu);
+static Block4Data* block4_data_ref (Block4Data* _data4_);
+static void block4_data_unref (Block4Data* _data4_);
+IconWidget* icon_widget_new (const gchar* icon, gint size);
+IconWidget* icon_widget_construct (GType object_type, const gchar* icon, gint size);
+GType icon_widget_get_type (void) G_GNUC_CONST;
+static void ____lambda22_ (Block4Data* _data4_, GtkMenuItem* item);
+static void _____lambda22__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
+static void panel_real_set_cursor_location (IBusPanelService* base, gint x, gint y, gint width, gint height);
+void candidate_panel_set_cursor_location (CandidatePanel* self, gint x, gint y, gint width, gint height);
+static void panel_real_focus_in (IBusPanelService* base, const gchar* input_context_path);
+static void panel_real_focus_out (IBusPanelService* base, const gchar* input_context_path);
+static void panel_real_register_properties (IBusPanelService* base, IBusPropList* props);
+void property_manager_set_properties (PropertyManager* self, IBusPropList* props);
+static void panel_real_update_property (IBusPanelService* base, IBusProperty* prop);
+void property_manager_update_property (PropertyManager* self, IBusProperty* prop);
+static void panel_real_update_preedit_text (IBusPanelService* base, IBusText* text, guint cursor_pos, gboolean visible);
+void candidate_panel_set_preedit_text (CandidatePanel* self, IBusText* text, guint cursor);
+static void panel_real_hide_preedit_text (IBusPanelService* base);
+static void panel_real_update_auxiliary_text (IBusPanelService* base, IBusText* text, gboolean visible);
+void candidate_panel_set_auxiliary_text (CandidatePanel* self, IBusText* text);
+static void panel_real_hide_auxiliary_text (IBusPanelService* base);
+static void panel_real_update_lookup_table (IBusPanelService* base, IBusLookupTable* table, gboolean visible);
+void candidate_panel_set_lookup_table (CandidatePanel* self, IBusLookupTable* table);
+static void panel_real_hide_lookup_table (IBusPanelService* base);
+static void panel_real_state_changed (IBusPanelService* base);
+static void panel_finalize (GObject* obj);
+static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
+static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
+static gint _vala_array_length (gpointer array);
+
+
+static void _panel_gkbdlayout_changed_cb_gkbd_layout_changed (GkbdLayout* _sender, gpointer self) {
+	panel_gkbdlayout_changed_cb (self);
+}
+
+
+static gpointer _g_object_ref0 (gpointer self) {
+	return self ? g_object_ref (self) : NULL;
+}
+
+
+static void _panel_status_icon_popup_menu_cb_gtk_status_icon_popup_menu (GtkStatusIcon* _sender, guint button, guint activate_time, gpointer self) {
+	panel_status_icon_popup_menu_cb (self, _sender, button, activate_time);
+}
+
+
+static void _panel_status_icon_activate_cb_gtk_status_icon_activate (GtkStatusIcon* _sender, gpointer self) {
+	panel_status_icon_activate_cb (self, _sender);
+}
+
+
+static void __lambda23_ (Panel* self, CandidatePanel* w) {
+	g_return_if_fail (w != NULL);
+	ibus_panel_service_page_up ((IBusPanelService*) self);
+}
+
+
+static void ___lambda23__candidate_panel_page_up (CandidatePanel* _sender, gpointer self) {
+	__lambda23_ (self, _sender);
+}
+
+
+static void __lambda24_ (Panel* self, CandidatePanel* w) {
+	g_return_if_fail (w != NULL);
+	ibus_panel_service_page_down ((IBusPanelService*) self);
+}
+
+
+static void ___lambda24__candidate_panel_page_down (CandidatePanel* _sender, gpointer self) {
+	__lambda24_ (self, _sender);
+}
+
+
+static void __lambda25_ (Panel* self, const gchar* k, gint s) {
+	const gchar* _tmp0_;
+	gint _tmp1_;
+	g_return_if_fail (k != NULL);
+	_tmp0_ = k;
+	_tmp1_ = s;
+	ibus_panel_service_property_activate ((IBusPanelService*) self, _tmp0_, (guint) _tmp1_);
+}
+
+
+static void ___lambda25__property_manager_property_activate (PropertyManager* _sender, const gchar* key, gint state, gpointer self) {
+	__lambda25_ (self, key, state);
+}
+
+
+Panel* panel_construct (GType object_type, IBusBus* bus) {
+	Panel * self = NULL;
+	IBusBus* _tmp0_;
+	gboolean _tmp1_ = FALSE;
+	IBusBus* _tmp2_;
+	GDBusConnection* _tmp3_ = NULL;
+	IBusBus* _tmp4_;
+	IBusBus* _tmp5_;
+	GtkStatusIcon* _tmp6_;
+	GtkStatusIcon* _tmp7_;
+	GtkStatusIcon* _tmp8_;
+	GtkStatusIcon* _tmp9_;
+	GtkStatusIcon* _tmp10_;
+	GtkStatusIcon* _tmp11_;
+	CandidatePanel* _tmp12_;
+	CandidatePanel* _tmp13_;
+	CandidatePanel* _tmp14_;
+	CandidatePanel* _tmp15_;
+	Switcher* _tmp16_;
+	Switcher* _tmp17_;
+	PropertyManager* _tmp18_;
+	PropertyManager* _tmp19_;
+	g_return_val_if_fail (bus != NULL, NULL);
+	_tmp0_ = bus;
+	_tmp1_ = ibus_bus_is_connected (_tmp0_);
+	g_assert (_tmp1_);
+	_tmp2_ = bus;
+	_tmp3_ = ibus_bus_get_connection (_tmp2_);
+	self = (Panel*) g_object_new (object_type, "connection", _tmp3_, "object-path", "/org/freedesktop/IBus/Panel", NULL);
+	_tmp4_ = bus;
+	_tmp5_ = _g_object_ref0 (_tmp4_);
+	_g_object_unref0 (self->priv->m_bus);
+	self->priv->m_bus = _tmp5_;
+	_tmp6_ = gtk_status_icon_new ();
+	_g_object_unref0 (self->priv->m_status_icon);
+	self->priv->m_status_icon = _tmp6_;
+	_tmp7_ = self->priv->m_status_icon;
+	gtk_status_icon_set_name (_tmp7_, "ibus-ui-gtk");
+	_tmp8_ = self->priv->m_status_icon;
+	gtk_status_icon_set_title (_tmp8_, "IBus Panel");
+	_tmp9_ = self->priv->m_status_icon;
+	g_signal_connect_object (_tmp9_, "popup-menu", (GCallback) _panel_status_icon_popup_menu_cb_gtk_status_icon_popup_menu, self, 0);
+	_tmp10_ = self->priv->m_status_icon;
+	g_signal_connect_object (_tmp10_, "activate", (GCallback) _panel_status_icon_activate_cb_gtk_status_icon_activate, self, 0);
+	_tmp11_ = self->priv->m_status_icon;
+	gtk_status_icon_set_from_icon_name (_tmp11_, "ibus-keyboard");
+	_tmp12_ = candidate_panel_new ();
+	_tmp13_ = g_object_ref_sink (_tmp12_);
+	_g_object_unref0 (self->priv->m_candidate_panel);
+	self->priv->m_candidate_panel = _tmp13_;
+	_tmp14_ = self->priv->m_candidate_panel;
+	g_signal_connect_object (_tmp14_, "page-up", (GCallback) ___lambda23__candidate_panel_page_up, self, 0);
+	_tmp15_ = self->priv->m_candidate_panel;
+	g_signal_connect_object (_tmp15_, "page-down", (GCallback) ___lambda24__candidate_panel_page_down, self, 0);
+	_tmp16_ = switcher_new ();
+	_tmp17_ = g_object_ref_sink (_tmp16_);
+	_g_object_unref0 (self->priv->m_switcher);
+	self->priv->m_switcher = _tmp17_;
+	_tmp18_ = property_manager_new ();
+	_property_manager_unref0 (self->priv->m_property_manager);
+	self->priv->m_property_manager = _tmp18_;
+	_tmp19_ = self->priv->m_property_manager;
+	g_signal_connect_object (_tmp19_, "property-activate", (GCallback) ___lambda25__property_manager_property_activate, self, 0);
+	g_signal_emit_by_name ((IBusPanelService*) self, "state-changed");
+	return self;
+}
+
+
+Panel* panel_new (IBusBus* bus) {
+	return panel_construct (TYPE_PANEL, bus);
+}
+
+
+static void _vala_array_add9 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static gchar* string_slice (const gchar* self, glong start, glong end) {
+	gchar* result = NULL;
+	gint _tmp0_;
+	gint _tmp1_;
+	glong string_length;
+	glong _tmp2_;
+	glong _tmp5_;
+	gboolean _tmp8_ = FALSE;
+	glong _tmp9_;
+	gboolean _tmp12_;
+	gboolean _tmp13_ = FALSE;
+	glong _tmp14_;
+	gboolean _tmp17_;
+	glong _tmp18_;
+	glong _tmp19_;
+	glong _tmp20_;
+	glong _tmp21_;
+	glong _tmp22_;
+	gchar* _tmp23_ = NULL;
+	g_return_val_if_fail (self != NULL, NULL);
+	_tmp0_ = strlen (self);
+	_tmp1_ = _tmp0_;
+	string_length = (glong) _tmp1_;
+	_tmp2_ = start;
+	if (_tmp2_ < ((glong) 0)) {
+		glong _tmp3_;
+		glong _tmp4_;
+		_tmp3_ = string_length;
+		_tmp4_ = start;
+		start = _tmp3_ + _tmp4_;
+	}
+	_tmp5_ = end;
+	if (_tmp5_ < ((glong) 0)) {
+		glong _tmp6_;
+		glong _tmp7_;
+		_tmp6_ = string_length;
+		_tmp7_ = end;
+		end = _tmp6_ + _tmp7_;
+	}
+	_tmp9_ = start;
+	if (_tmp9_ >= ((glong) 0)) {
+		glong _tmp10_;
+		glong _tmp11_;
+		_tmp10_ = start;
+		_tmp11_ = string_length;
+		_tmp8_ = _tmp10_ <= _tmp11_;
+	} else {
+		_tmp8_ = FALSE;
+	}
+	_tmp12_ = _tmp8_;
+	g_return_val_if_fail (_tmp12_, NULL);
+	_tmp14_ = end;
+	if (_tmp14_ >= ((glong) 0)) {
+		glong _tmp15_;
+		glong _tmp16_;
+		_tmp15_ = end;
+		_tmp16_ = string_length;
+		_tmp13_ = _tmp15_ <= _tmp16_;
+	} else {
+		_tmp13_ = FALSE;
+	}
+	_tmp17_ = _tmp13_;
+	g_return_val_if_fail (_tmp17_, NULL);
+	_tmp18_ = start;
+	_tmp19_ = end;
+	g_return_val_if_fail (_tmp18_ <= _tmp19_, NULL);
+	_tmp20_ = start;
+	_tmp21_ = end;
+	_tmp22_ = start;
+	_tmp23_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) (_tmp21_ - _tmp22_));
+	result = _tmp23_;
+	return result;
+}
+
+
+static void _vala_array_add11 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add12 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void ____lambda26_ (Panel* self, GdkEvent* e) {
+	GdkEvent* _tmp0_;
+	g_return_if_fail (e != NULL);
+	_tmp0_ = e;
+	panel_handle_engine_switch (self, _tmp0_, FALSE);
+}
+
+
+static void _____lambda26__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self) {
+	____lambda26_ (self, event);
+}
+
+
+static void _____lambda27_ (Panel* self, GdkEvent* e) {
+	GdkEvent* _tmp0_;
+	g_return_if_fail (e != NULL);
+	_tmp0_ = e;
+	panel_handle_engine_switch (self, _tmp0_, TRUE);
+}
+
+
+static void ______lambda27__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self) {
+	_____lambda27_ (self, event);
+}
+
+
+static void panel_set_keybinding (Panel* self) {
+	const gchar* _tmp0_ = NULL;
+	gchar* _tmp1_;
+	gchar* locale;
+	const gchar* _tmp2_;
+	gchar** _tmp4_;
+	gint _tmp4__length1;
+	gchar* _tmp5_;
+	IBusConfig* _tmp6_;
+	gboolean _tmp23_ = FALSE;
+	gchar** _tmp24_;
+	gint _tmp24__length1;
+	gboolean _tmp27_;
+	KeybindingManager* _tmp36_ = NULL;
+	KeybindingManager* keybinding_manager;
+	gchar** _tmp37_;
+	gint _tmp37__length1;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = setlocale (LC_ALL, NULL);
+	_tmp1_ = g_strdup (_tmp0_);
+	locale = _tmp1_;
+	_tmp2_ = locale;
+	if (_tmp2_ == NULL) {
+		gchar* _tmp3_;
+		_tmp3_ = g_strdup ("C");
+		_g_free0 (locale);
+		locale = _tmp3_;
+	}
+	_tmp4_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+	_tmp4__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+	_tmp5_ = g_strdup (PANEL_ACCELERATOR_SWITCH_IME_FOREWARD);
+	_vala_array_add9 (&self->priv->ACCELERATOR_IME_HOTKEYS, &self->priv->ACCELERATOR_IME_HOTKEYS_length1, &self->priv->_ACCELERATOR_IME_HOTKEYS_size_, _tmp5_);
+	_tmp6_ = self->priv->m_config;
+	if (_tmp6_ != NULL) {
+		IBusConfig* _tmp7_;
+		GVariant* _tmp8_ = NULL;
+		GVariant* variant;
+		GVariant* _tmp9_;
+		_tmp7_ = self->priv->m_config;
+		_tmp8_ = ibus_config_get_value (_tmp7_, "general/hotkey", "trigger_accel");
+		variant = _tmp8_;
+		_tmp9_ = variant;
+		if (_tmp9_ != NULL) {
+			gchar** _tmp10_ = NULL;
+			_tmp10_ = g_new0 (gchar*, 0 + 1);
+			self->priv->ACCELERATOR_IME_HOTKEYS = (_vala_array_free (self->priv->ACCELERATOR_IME_HOTKEYS, self->priv->ACCELERATOR_IME_HOTKEYS_length1, (GDestroyNotify) g_free), NULL);
+			self->priv->ACCELERATOR_IME_HOTKEYS = _tmp10_;
+			self->priv->ACCELERATOR_IME_HOTKEYS_length1 = 0;
+			self->priv->_ACCELERATOR_IME_HOTKEYS_size_ = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+			{
+				gint i;
+				i = 0;
+				{
+					gboolean _tmp11_;
+					_tmp11_ = TRUE;
+					while (TRUE) {
+						gboolean _tmp12_;
+						gint _tmp14_;
+						GVariant* _tmp15_;
+						gsize _tmp16_ = 0UL;
+						gchar** _tmp17_;
+						gint _tmp17__length1;
+						GVariant* _tmp18_;
+						gint _tmp19_;
+						GVariant* _tmp20_ = NULL;
+						GVariant* _tmp21_;
+						gchar* _tmp22_ = NULL;
+						_tmp12_ = _tmp11_;
+						if (!_tmp12_) {
+							gint _tmp13_;
+							_tmp13_ = i;
+							i = _tmp13_ + 1;
+						}
+						_tmp11_ = FALSE;
+						_tmp14_ = i;
+						_tmp15_ = variant;
+						_tmp16_ = g_variant_n_children (_tmp15_);
+						if (!(((gsize) _tmp14_) < _tmp16_)) {
+							break;
+						}
+						_tmp17_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+						_tmp17__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+						_tmp18_ = variant;
+						_tmp19_ = i;
+						_tmp20_ = g_variant_get_child_value (_tmp18_, (gsize) _tmp19_);
+						_tmp21_ = _tmp20_;
+						_tmp22_ = g_variant_dup_string (_tmp21_, NULL);
+						_vala_array_add10 (&self->priv->ACCELERATOR_IME_HOTKEYS, &self->priv->ACCELERATOR_IME_HOTKEYS_length1, &self->priv->_ACCELERATOR_IME_HOTKEYS_size_, _tmp22_);
+						_g_variant_unref0 (_tmp21_);
+					}
+				}
+			}
+		}
+		_g_variant_unref0 (variant);
+	}
+	_tmp24_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+	_tmp24__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+	if (_tmp24__length1 == 1) {
+		gchar** _tmp25_;
+		gint _tmp25__length1;
+		const gchar* _tmp26_;
+		_tmp25_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+		_tmp25__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+		_tmp26_ = _tmp25_[0];
+		_tmp23_ = g_strcmp0 (_tmp26_, PANEL_ACCELERATOR_SWITCH_IME_FOREWARD) == 0;
+	} else {
+		_tmp23_ = FALSE;
+	}
+	_tmp27_ = _tmp23_;
+	if (_tmp27_) {
+		const gchar* _tmp28_;
+		gchar* _tmp29_ = NULL;
+		gchar* _tmp30_;
+		gboolean _tmp31_;
+		_tmp28_ = locale;
+		_tmp29_ = string_slice (_tmp28_, (glong) 0, (glong) 2);
+		_tmp30_ = _tmp29_;
+		_tmp31_ = g_strcmp0 (_tmp30_, "ko") == 0;
+		_g_free0 (_tmp30_);
+		if (_tmp31_) {
+			gchar** _tmp32_;
+			gint _tmp32__length1;
+			gchar* _tmp33_;
+			gchar** _tmp34_;
+			gint _tmp34__length1;
+			gchar* _tmp35_;
+			_tmp32_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+			_tmp32__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+			_tmp33_ = g_strdup ("Hangul");
+			_vala_array_add11 (&self->priv->ACCELERATOR_IME_HOTKEYS, &self->priv->ACCELERATOR_IME_HOTKEYS_length1, &self->priv->_ACCELERATOR_IME_HOTKEYS_size_, _tmp33_);
+			_tmp34_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+			_tmp34__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+			_tmp35_ = g_strdup ("Alt_R");
+			_vala_array_add12 (&self->priv->ACCELERATOR_IME_HOTKEYS, &self->priv->ACCELERATOR_IME_HOTKEYS_length1, &self->priv->_ACCELERATOR_IME_HOTKEYS_size_, _tmp35_);
+		}
+	}
+	_tmp36_ = keybinding_manager_get_instance ();
+	keybinding_manager = _tmp36_;
+	_tmp37_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+	_tmp37__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+	{
+		gchar** keybinding_collection = NULL;
+		gint keybinding_collection_length1 = 0;
+		gint _keybinding_collection_size_ = 0;
+		gint keybinding_it = 0;
+		keybinding_collection = _tmp37_;
+		keybinding_collection_length1 = _tmp37__length1;
+		for (keybinding_it = 0; keybinding_it < _tmp37__length1; keybinding_it = keybinding_it + 1) {
+			gchar* _tmp38_;
+			gchar* keybinding = NULL;
+			_tmp38_ = g_strdup (keybinding_collection[keybinding_it]);
+			keybinding = _tmp38_;
+			{
+				KeybindingManager* _tmp39_;
+				const gchar* _tmp40_;
+				const gchar* _tmp41_;
+				_tmp39_ = keybinding_manager;
+				_tmp40_ = keybinding;
+				keybinding_manager_bind (_tmp39_, _tmp40_, _____lambda26__keybinding_manager_keybinding_handler_func, self);
+				_tmp41_ = keybinding;
+				if (g_strcmp0 (_tmp41_, PANEL_ACCELERATOR_SWITCH_IME_FOREWARD) == 0) {
+					KeybindingManager* _tmp42_;
+					_tmp42_ = keybinding_manager;
+					keybinding_manager_bind (_tmp42_, PANEL_ACCELERATOR_SWITCH_IME_BACKWARD, ______lambda27__keybinding_manager_keybinding_handler_func, self);
+				}
+				_g_free0 (keybinding);
+			}
+		}
+	}
+	_g_object_unref0 (keybinding_manager);
+	_g_free0 (locale);
+}
+
+
+static void _panel_config_value_changed_cb_ibus_config_value_changed (IBusConfig* _sender, const gchar* section, const gchar* name, GVariant* value, gpointer self) {
+	panel_config_value_changed_cb (self, _sender, section, name, value);
+}
+
+
+void panel_set_config (Panel* self, IBusConfig* config) {
+	IBusConfig* _tmp0_;
+	IBusConfig* _tmp3_;
+	IBusConfig* _tmp4_;
+	IBusConfig* _tmp5_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (config != NULL);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ != NULL) {
+		IBusConfig* _tmp1_;
+		guint _tmp2_ = 0U;
+		_tmp1_ = self->priv->m_config;
+		g_signal_parse_name ("value-changed", ibus_config_get_type (), &_tmp2_, NULL, FALSE);
+		g_signal_handlers_disconnect_matched (_tmp1_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _panel_config_value_changed_cb_ibus_config_value_changed, self);
+		_g_object_unref0 (self->priv->m_config);
+		self->priv->m_config = NULL;
+	}
+	_tmp3_ = config;
+	_tmp4_ = _g_object_ref0 (_tmp3_);
+	_g_object_unref0 (self->priv->m_config);
+	self->priv->m_config = _tmp4_;
+	panel_set_keybinding (self);
+	_tmp5_ = self->priv->m_config;
+	if (_tmp5_ != NULL) {
+		IBusConfig* _tmp6_;
+		IBusConfig* _tmp7_;
+		GVariant* _tmp8_ = NULL;
+		GVariant* _tmp9_;
+		IBusConfig* _tmp10_;
+		GVariant* _tmp11_ = NULL;
+		GVariant* _tmp12_;
+		_tmp6_ = self->priv->m_config;
+		g_signal_connect_object (_tmp6_, "value-changed", (GCallback) _panel_config_value_changed_cb_ibus_config_value_changed, self, 0);
+		panel_init_engines_order (self);
+		_tmp7_ = self->priv->m_config;
+		_tmp8_ = ibus_config_get_value (_tmp7_, "general", "preload_engines");
+		_tmp9_ = _tmp8_;
+		_tmp10_ = self->priv->m_config;
+		_tmp11_ = ibus_config_get_value (_tmp10_, "general", "engines_order");
+		_tmp12_ = _tmp11_;
+		panel_update_engines (self, _tmp9_, _tmp12_);
+		_g_variant_unref0 (_tmp12_);
+		_g_variant_unref0 (_tmp9_);
+	} else {
+		panel_update_engines (self, NULL, NULL);
+	}
+}
+
+
+static void panel_gkbdlayout_changed_cb (Panel* self) {
+	GTimer* _tmp0_;
+	gdouble _tmp1_ = 0.0;
+	gdouble elapsed;
+	gboolean _tmp2_ = FALSE;
+	gdouble _tmp3_;
+	gboolean _tmp5_;
+	gint _tmp6_;
+	GTimer* _tmp10_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_changed_layout_timer;
+	_tmp1_ = g_timer_elapsed (_tmp0_, NULL);
+	elapsed = _tmp1_;
+	_tmp3_ = elapsed;
+	if (_tmp3_ < 1.0) {
+		gdouble _tmp4_;
+		_tmp4_ = elapsed;
+		_tmp2_ = _tmp4_ > 0.0;
+	} else {
+		_tmp2_ = FALSE;
+	}
+	_tmp5_ = _tmp2_;
+	if (_tmp5_) {
+		return;
+	}
+	_tmp6_ = self->priv->m_fallback_lock_id;
+	if (_tmp6_ != (-1)) {
+		GkbdLayout* _tmp7_;
+		gint _tmp8_;
+		_tmp7_ = self->priv->m_gkbdlayout;
+		_tmp8_ = self->priv->m_fallback_lock_id;
+		gkbd_layout_lock_group (_tmp7_, _tmp8_);
+		self->priv->m_fallback_lock_id = -1;
+	} else {
+		XKBLayout* _tmp9_;
+		_tmp9_ = self->priv->m_xkblayout;
+		xkb_layout_reset_layout (_tmp9_);
+	}
+	panel_update_xkb_engines (self);
+	_tmp10_ = self->priv->m_changed_layout_timer;
+	g_timer_reset (_tmp10_);
+}
+
+
+static void panel_init_gkbd (Panel* self) {
+	GkbdLayout* _tmp0_;
+	GkbdLayout* _tmp1_;
+	GTimer* _tmp2_;
+	GTimer* _tmp3_;
+	GkbdLayout* _tmp4_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = gkbd_layout_new ();
+	_gkbd_layout_unref0 (self->priv->m_gkbdlayout);
+	self->priv->m_gkbdlayout = _tmp0_;
+	_tmp1_ = self->priv->m_gkbdlayout;
+	g_signal_connect_object (_tmp1_, "changed", (GCallback) _panel_gkbdlayout_changed_cb_gkbd_layout_changed, self, 0);
+	_tmp2_ = g_timer_new ();
+	_g_timer_destroy0 (self->priv->m_changed_layout_timer);
+	self->priv->m_changed_layout_timer = _tmp2_;
+	_tmp3_ = self->priv->m_changed_layout_timer;
+	g_timer_start (_tmp3_);
+	_tmp4_ = self->priv->m_gkbdlayout;
+	gkbd_layout_start_listen (_tmp4_);
+}
+
+
+static void panel_init_engines_order (Panel* self) {
+	IBusConfig* _tmp0_;
+	IBusConfig* _tmp1_;
+	XKBLayout* _tmp2_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ == NULL) {
+		return;
+	}
+	_tmp1_ = self->priv->m_config;
+	_tmp2_ = xkb_layout_new (_tmp1_);
+	_xkb_layout_unref0 (self->priv->m_xkblayout);
+	self->priv->m_xkblayout = _tmp2_;
+	if (HAVE_IBUS_GKBD) {
+		panel_init_gkbd (self);
+	}
+	panel_update_xkb_engines (self);
+}
+
+
+static void _g_free0_ (gpointer var) {
+	var = (g_free (var), NULL);
+}
+
+
+static void _g_list_free__g_free0_ (GList* self) {
+	g_list_foreach (self, (GFunc) _g_free0_, NULL);
+	g_list_free (self);
+}
+
+
+static void _vala_array_add13 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
+	int i;
+	for (i = 0; i < stack_length; i++) {
+		if (g_strcmp0 (stack[i], needle) == 0) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+
+static void _vala_array_add14 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add15 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void panel_update_xkb_engines (Panel* self) {
+	XKBLayout* _tmp0_;
+	gchar* _tmp1_ = NULL;
+	gchar* var_layout;
+	XKBLayout* _tmp2_;
+	gchar* _tmp3_ = NULL;
+	gchar* var_variant;
+	const gchar* _tmp4_;
+	const gchar* _tmp5_;
+	gchar** _tmp6_;
+	gchar** _tmp7_ = NULL;
+	const gchar* _tmp8_;
+	gchar** _tmp9_;
+	gchar** _tmp10_ = NULL;
+	IBusXKBConfigRegistry* _tmp11_;
+	IBusXKBConfigRegistry* _tmp12_;
+	IBusXKBConfigRegistry* registry;
+	gchar** _tmp13_ = NULL;
+	gchar** var_xkb_engine_names;
+	gint var_xkb_engine_names_length1;
+	gint _var_xkb_engine_names_size_;
+	IBusConfig* _tmp65_;
+	GVariant* _tmp66_ = NULL;
+	GVariant* var_engines;
+	gchar** _tmp67_ = NULL;
+	gchar** engine_names;
+	gint engine_names_length1;
+	gint _engine_names_size_;
+	gboolean updated_engine_names;
+	GVariant* _tmp68_;
+	gchar** _tmp72_;
+	gint _tmp72__length1;
+	gboolean _tmp79_;
+	IBusConfig* _tmp84_;
+	GVariant* _tmp85_ = NULL;
+	GVariant* var_order;
+	gchar** _tmp86_ = NULL;
+	gchar** order_names;
+	gint order_names_length1;
+	gint _order_names_size_;
+	gboolean updated_order_names;
+	GVariant* _tmp87_;
+	gchar** _tmp91_;
+	gint _tmp91__length1;
+	gboolean _tmp98_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_xkblayout;
+	_tmp1_ = xkb_layout_get_layout (_tmp0_);
+	var_layout = _tmp1_;
+	_tmp2_ = self->priv->m_xkblayout;
+	_tmp3_ = xkb_layout_get_variant (_tmp2_);
+	var_variant = _tmp3_;
+	_tmp4_ = var_layout;
+	if (g_strcmp0 (_tmp4_, "") == 0) {
+		_g_free0 (var_variant);
+		_g_free0 (var_layout);
+		return;
+	}
+	_tmp5_ = var_layout;
+	_tmp7_ = _tmp6_ = g_strsplit (_tmp5_, ",", 0);
+	self->priv->m_layouts = (_vala_array_free (self->priv->m_layouts, self->priv->m_layouts_length1, (GDestroyNotify) g_free), NULL);
+	self->priv->m_layouts = _tmp7_;
+	self->priv->m_layouts_length1 = _vala_array_length (_tmp6_);
+	self->priv->_m_layouts_size_ = self->priv->m_layouts_length1;
+	_tmp8_ = var_variant;
+	_tmp10_ = _tmp9_ = g_strsplit (_tmp8_, ",", 0);
+	self->priv->m_variants = (_vala_array_free (self->priv->m_variants, self->priv->m_variants_length1, (GDestroyNotify) g_free), NULL);
+	self->priv->m_variants = _tmp10_;
+	self->priv->m_variants_length1 = _vala_array_length (_tmp9_);
+	self->priv->_m_variants_size_ = self->priv->m_variants_length1;
+	_tmp11_ = ibus_xkb_config_registry_new ();
+	_tmp12_ = g_object_ref_sink (_tmp11_);
+	registry = _tmp12_;
+	_tmp13_ = g_new0 (gchar*, 0 + 1);
+	var_xkb_engine_names = _tmp13_;
+	var_xkb_engine_names_length1 = 0;
+	_var_xkb_engine_names_size_ = var_xkb_engine_names_length1;
+	{
+		gint i;
+		i = 0;
+		{
+			gboolean _tmp14_;
+			_tmp14_ = TRUE;
+			while (TRUE) {
+				gboolean _tmp15_;
+				gint _tmp17_;
+				gchar** _tmp18_;
+				gint _tmp18__length1;
+				gchar** _tmp19_;
+				gint _tmp19__length1;
+				gint _tmp20_;
+				const gchar* _tmp21_;
+				gchar* _tmp22_;
+				gchar* name;
+				gchar* lang;
+				gboolean _tmp23_ = FALSE;
+				gint _tmp24_;
+				gchar** _tmp25_;
+				gint _tmp25__length1;
+				gboolean _tmp29_;
+				const gchar* _tmp50_;
+				gchar** _tmp61_;
+				gint _tmp61__length1;
+				const gchar* _tmp62_;
+				const gchar* _tmp63_;
+				gchar* _tmp64_ = NULL;
+				_tmp15_ = _tmp14_;
+				if (!_tmp15_) {
+					gint _tmp16_;
+					_tmp16_ = i;
+					i = _tmp16_ + 1;
+				}
+				_tmp14_ = FALSE;
+				_tmp17_ = i;
+				_tmp18_ = self->priv->m_layouts;
+				_tmp18__length1 = self->priv->m_layouts_length1;
+				if (!(_tmp17_ < _tmp18__length1)) {
+					break;
+				}
+				_tmp19_ = self->priv->m_layouts;
+				_tmp19__length1 = self->priv->m_layouts_length1;
+				_tmp20_ = i;
+				_tmp21_ = _tmp19_[_tmp20_];
+				_tmp22_ = g_strdup (_tmp21_);
+				name = _tmp22_;
+				lang = NULL;
+				_tmp24_ = i;
+				_tmp25_ = self->priv->m_variants;
+				_tmp25__length1 = self->priv->m_variants_length1;
+				if (_tmp24_ < _tmp25__length1) {
+					gchar** _tmp26_;
+					gint _tmp26__length1;
+					gint _tmp27_;
+					const gchar* _tmp28_;
+					_tmp26_ = self->priv->m_variants;
+					_tmp26__length1 = self->priv->m_variants_length1;
+					_tmp27_ = i;
+					_tmp28_ = _tmp26_[_tmp27_];
+					_tmp23_ = g_strcmp0 (_tmp28_, "") != 0;
+				} else {
+					_tmp23_ = FALSE;
+				}
+				_tmp29_ = _tmp23_;
+				if (_tmp29_) {
+					const gchar* _tmp30_;
+					gchar** _tmp31_;
+					gint _tmp31__length1;
+					gint _tmp32_;
+					const gchar* _tmp33_;
+					gchar* _tmp34_ = NULL;
+					const gchar* _tmp35_;
+					gchar** _tmp36_;
+					gint _tmp36__length1;
+					gint _tmp37_;
+					const gchar* _tmp38_;
+					gchar* _tmp39_ = NULL;
+					gchar* layout;
+					IBusXKBConfigRegistry* _tmp40_;
+					const gchar* _tmp41_;
+					GList* _tmp42_ = NULL;
+					GList* langs;
+					GList* _tmp43_;
+					guint _tmp44_ = 0U;
+					_tmp30_ = name;
+					_tmp31_ = self->priv->m_variants;
+					_tmp31__length1 = self->priv->m_variants_length1;
+					_tmp32_ = i;
+					_tmp33_ = _tmp31_[_tmp32_];
+					_tmp34_ = g_strdup_printf ("%s:%s", _tmp30_, _tmp33_);
+					_g_free0 (name);
+					name = _tmp34_;
+					_tmp35_ = name;
+					_tmp36_ = self->priv->m_variants;
+					_tmp36__length1 = self->priv->m_variants_length1;
+					_tmp37_ = i;
+					_tmp38_ = _tmp36_[_tmp37_];
+					_tmp39_ = g_strdup_printf ("%s(%s)", _tmp35_, _tmp38_);
+					layout = _tmp39_;
+					_tmp40_ = registry;
+					_tmp41_ = layout;
+					_tmp42_ = ibus_xkb_config_registry_layout_lang_get_langs (_tmp40_, _tmp41_);
+					langs = _tmp42_;
+					_tmp43_ = langs;
+					_tmp44_ = g_list_length (_tmp43_);
+					if (_tmp44_ != ((guint) 0)) {
+						GList* _tmp45_;
+						gconstpointer _tmp46_;
+						gchar* _tmp47_;
+						_tmp45_ = langs;
+						_tmp46_ = _tmp45_->data;
+						_tmp47_ = g_strdup ((const gchar*) _tmp46_);
+						_g_free0 (lang);
+						lang = _tmp47_;
+					}
+					__g_list_free__g_free0_0 (langs);
+					_g_free0 (layout);
+				} else {
+					const gchar* _tmp48_;
+					gchar* _tmp49_ = NULL;
+					_tmp48_ = name;
+					_tmp49_ = g_strdup_printf ("%s:", _tmp48_);
+					_g_free0 (name);
+					name = _tmp49_;
+				}
+				_tmp50_ = lang;
+				if (_tmp50_ == NULL) {
+					IBusXKBConfigRegistry* _tmp51_;
+					gchar** _tmp52_;
+					gint _tmp52__length1;
+					gint _tmp53_;
+					const gchar* _tmp54_;
+					GList* _tmp55_ = NULL;
+					GList* langs;
+					GList* _tmp56_;
+					guint _tmp57_ = 0U;
+					_tmp51_ = registry;
+					_tmp52_ = self->priv->m_layouts;
+					_tmp52__length1 = self->priv->m_layouts_length1;
+					_tmp53_ = i;
+					_tmp54_ = _tmp52_[_tmp53_];
+					_tmp55_ = ibus_xkb_config_registry_layout_lang_get_langs (_tmp51_, _tmp54_);
+					langs = _tmp55_;
+					_tmp56_ = langs;
+					_tmp57_ = g_list_length (_tmp56_);
+					if (_tmp57_ != ((guint) 0)) {
+						GList* _tmp58_;
+						gconstpointer _tmp59_;
+						gchar* _tmp60_;
+						_tmp58_ = langs;
+						_tmp59_ = _tmp58_->data;
+						_tmp60_ = g_strdup ((const gchar*) _tmp59_);
+						_g_free0 (lang);
+						lang = _tmp60_;
+					}
+					__g_list_free__g_free0_0 (langs);
+				}
+				_tmp61_ = var_xkb_engine_names;
+				_tmp61__length1 = var_xkb_engine_names_length1;
+				_tmp62_ = name;
+				_tmp63_ = lang;
+				_tmp64_ = g_strdup_printf ("%s:%s:%s", "xkb", _tmp62_, _tmp63_);
+				_vala_array_add13 (&var_xkb_engine_names, &var_xkb_engine_names_length1, &_var_xkb_engine_names_size_, _tmp64_);
+				_g_free0 (lang);
+				_g_free0 (name);
+			}
+		}
+	}
+	_tmp65_ = self->priv->m_config;
+	_tmp66_ = ibus_config_get_value (_tmp65_, "general", "preload_engines");
+	var_engines = _tmp66_;
+	_tmp67_ = g_new0 (gchar*, 0 + 1);
+	engine_names = _tmp67_;
+	engine_names_length1 = 0;
+	_engine_names_size_ = engine_names_length1;
+	updated_engine_names = FALSE;
+	_tmp68_ = var_engines;
+	if (_tmp68_ != NULL) {
+		GVariant* _tmp69_;
+		size_t _tmp70_;
+		gchar** _tmp71_ = NULL;
+		_tmp69_ = var_engines;
+		_tmp71_ = g_variant_dup_strv (_tmp69_, &_tmp70_);
+		engine_names = (_vala_array_free (engine_names, engine_names_length1, (GDestroyNotify) g_free), NULL);
+		engine_names = _tmp71_;
+		engine_names_length1 = _tmp70_;
+		_engine_names_size_ = engine_names_length1;
+	}
+	_tmp72_ = var_xkb_engine_names;
+	_tmp72__length1 = var_xkb_engine_names_length1;
+	{
+		gchar** name_collection = NULL;
+		gint name_collection_length1 = 0;
+		gint _name_collection_size_ = 0;
+		gint name_it = 0;
+		name_collection = _tmp72_;
+		name_collection_length1 = _tmp72__length1;
+		for (name_it = 0; name_it < _tmp72__length1; name_it = name_it + 1) {
+			gchar* _tmp73_;
+			gchar* name = NULL;
+			_tmp73_ = g_strdup (name_collection[name_it]);
+			name = _tmp73_;
+			{
+				const gchar* _tmp74_;
+				gchar** _tmp75_;
+				gint _tmp75__length1;
+				gchar** _tmp76_;
+				gint _tmp76__length1;
+				const gchar* _tmp77_;
+				gchar* _tmp78_;
+				_tmp74_ = name;
+				_tmp75_ = engine_names;
+				_tmp75__length1 = engine_names_length1;
+				if (_vala_string_array_contains (_tmp75_, _tmp75__length1, _tmp74_)) {
+					_g_free0 (name);
+					continue;
+				}
+				updated_engine_names = TRUE;
+				_tmp76_ = engine_names;
+				_tmp76__length1 = engine_names_length1;
+				_tmp77_ = name;
+				_tmp78_ = g_strdup (_tmp77_);
+				_vala_array_add14 (&engine_names, &engine_names_length1, &_engine_names_size_, _tmp78_);
+				_g_free0 (name);
+			}
+		}
+	}
+	_tmp79_ = updated_engine_names;
+	if (_tmp79_) {
+		IBusConfig* _tmp80_;
+		gchar** _tmp81_;
+		gint _tmp81__length1;
+		GVariant* _tmp82_;
+		GVariant* _tmp83_;
+		_tmp80_ = self->priv->m_config;
+		_tmp81_ = engine_names;
+		_tmp81__length1 = engine_names_length1;
+		_tmp82_ = g_variant_new_strv (_tmp81_, _tmp81__length1);
+		_tmp83_ = g_variant_ref_sink (_tmp82_);
+		ibus_config_set_value (_tmp80_, "general", "preload_engines", _tmp83_);
+		_g_variant_unref0 (_tmp83_);
+	}
+	_tmp84_ = self->priv->m_config;
+	_tmp85_ = ibus_config_get_value (_tmp84_, "general", "engines_order");
+	var_order = _tmp85_;
+	_tmp86_ = g_new0 (gchar*, 0 + 1);
+	order_names = _tmp86_;
+	order_names_length1 = 0;
+	_order_names_size_ = order_names_length1;
+	updated_order_names = FALSE;
+	_tmp87_ = var_order;
+	if (_tmp87_ != NULL) {
+		GVariant* _tmp88_;
+		size_t _tmp89_;
+		gchar** _tmp90_ = NULL;
+		_tmp88_ = var_order;
+		_tmp90_ = g_variant_dup_strv (_tmp88_, &_tmp89_);
+		order_names = (_vala_array_free (order_names, order_names_length1, (GDestroyNotify) g_free), NULL);
+		order_names = _tmp90_;
+		order_names_length1 = _tmp89_;
+		_order_names_size_ = order_names_length1;
+	}
+	_tmp91_ = var_xkb_engine_names;
+	_tmp91__length1 = var_xkb_engine_names_length1;
+	{
+		gchar** name_collection = NULL;
+		gint name_collection_length1 = 0;
+		gint _name_collection_size_ = 0;
+		gint name_it = 0;
+		name_collection = _tmp91_;
+		name_collection_length1 = _tmp91__length1;
+		for (name_it = 0; name_it < _tmp91__length1; name_it = name_it + 1) {
+			gchar* _tmp92_;
+			gchar* name = NULL;
+			_tmp92_ = g_strdup (name_collection[name_it]);
+			name = _tmp92_;
+			{
+				const gchar* _tmp93_;
+				gchar** _tmp94_;
+				gint _tmp94__length1;
+				gchar** _tmp95_;
+				gint _tmp95__length1;
+				const gchar* _tmp96_;
+				gchar* _tmp97_;
+				_tmp93_ = name;
+				_tmp94_ = order_names;
+				_tmp94__length1 = order_names_length1;
+				if (_vala_string_array_contains (_tmp94_, _tmp94__length1, _tmp93_)) {
+					_g_free0 (name);
+					continue;
+				}
+				_tmp95_ = order_names;
+				_tmp95__length1 = order_names_length1;
+				_tmp96_ = name;
+				_tmp97_ = g_strdup (_tmp96_);
+				_vala_array_add15 (&order_names, &order_names_length1, &_order_names_size_, _tmp97_);
+				updated_order_names = TRUE;
+				_g_free0 (name);
+			}
+		}
+	}
+	_tmp98_ = updated_order_names;
+	if (_tmp98_) {
+		IBusConfig* _tmp99_;
+		gchar** _tmp100_;
+		gint _tmp100__length1;
+		GVariant* _tmp101_;
+		GVariant* _tmp102_;
+		_tmp99_ = self->priv->m_config;
+		_tmp100_ = order_names;
+		_tmp100__length1 = order_names_length1;
+		_tmp101_ = g_variant_new_strv (_tmp100_, _tmp100__length1);
+		_tmp102_ = g_variant_ref_sink (_tmp101_);
+		ibus_config_set_value (_tmp99_, "general", "engines_order", _tmp102_);
+		_g_variant_unref0 (_tmp102_);
+	}
+	order_names = (_vala_array_free (order_names, order_names_length1, (GDestroyNotify) g_free), NULL);
+	_g_variant_unref0 (var_order);
+	engine_names = (_vala_array_free (engine_names, engine_names_length1, (GDestroyNotify) g_free), NULL);
+	_g_variant_unref0 (var_engines);
+	var_xkb_engine_names = (_vala_array_free (var_xkb_engine_names, var_xkb_engine_names_length1, (GDestroyNotify) g_free), NULL);
+	_g_object_unref0 (registry);
+	_g_free0 (var_variant);
+	_g_free0 (var_layout);
+}
+
+
+static void panel_set_xkb_group_layout (Panel* self, const gchar* layout) {
+	XKBLayout* _tmp0_;
+	const gchar* _tmp1_;
+	gint _tmp2_ = 0;
+	gint* _tmp3_ = NULL;
+	gint* retval;
+	gint retval_length1;
+	gint _retval_size_;
+	gint* _tmp4_;
+	gint _tmp4__length1;
+	gint _tmp5_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (layout != NULL);
+	_tmp0_ = self->priv->m_xkblayout;
+	_tmp1_ = layout;
+	_tmp3_ = xkb_layout_set_layout (_tmp0_, _tmp1_, "default", "default", &_tmp2_);
+	retval = _tmp3_;
+	retval_length1 = _tmp2_;
+	_retval_size_ = retval_length1;
+	_tmp4_ = retval;
+	_tmp4__length1 = retval_length1;
+	_tmp5_ = _tmp4_[0];
+	if (_tmp5_ >= 0) {
+		gint* _tmp6_;
+		gint _tmp6__length1;
+		gint _tmp7_;
+		gboolean _tmp8_ = FALSE;
+		gint* _tmp9_;
+		gint _tmp9__length1;
+		gint _tmp10_;
+		gboolean _tmp11_;
+		_tmp6_ = retval;
+		_tmp6__length1 = retval_length1;
+		_tmp7_ = _tmp6_[0];
+		self->priv->m_fallback_lock_id = _tmp7_;
+		_tmp9_ = retval;
+		_tmp9__length1 = retval_length1;
+		_tmp10_ = _tmp9_[1];
+		if (_tmp10_ != 0) {
+			_tmp8_ = TRUE;
+		} else {
+			_tmp8_ = FALSE;
+		}
+		_tmp11_ = _tmp8_;
+		self->priv->m_changed_xkb_option = _tmp11_;
+	}
+	retval = (g_free (retval), NULL);
+}
+
+
+static gboolean panel_set_gkbd_layout (Panel* self, const gchar* layout) {
+	gboolean result = FALSE;
+	gboolean _tmp0_;
+	GkbdLayout* _tmp1_;
+	gint _tmp2_ = 0;
+	gchar** _tmp3_ = NULL;
+	gchar** _tmp4_;
+	gint _tmp4__length1;
+	gint _tmp5_;
+	gint gkbd_len;
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (layout != NULL, FALSE);
+	_tmp0_ = self->priv->m_changed_xkb_option;
+	if (_tmp0_ == TRUE) {
+		self->priv->m_changed_xkb_option = FALSE;
+		result = FALSE;
+		return result;
+	}
+	_tmp1_ = self->priv->m_gkbdlayout;
+	_tmp3_ = gkbd_layout_get_group_names (_tmp1_, &_tmp2_);
+	_tmp4_ = _tmp3_;
+	_tmp4__length1 = _tmp2_;
+	_tmp5_ = _tmp2_;
+	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
+	gkbd_len = _tmp5_;
+	{
+		gint i;
+		i = 0;
+		{
+			gboolean _tmp6_;
+			_tmp6_ = TRUE;
+			while (TRUE) {
+				gboolean _tmp7_;
+				gboolean _tmp9_ = FALSE;
+				gint _tmp10_;
+				gchar** _tmp11_;
+				gint _tmp11__length1;
+				gboolean _tmp14_;
+				gchar** _tmp15_;
+				gint _tmp15__length1;
+				gint _tmp16_;
+				const gchar* _tmp17_;
+				gchar* _tmp18_;
+				gchar* sys_layout;
+				gboolean _tmp19_ = FALSE;
+				gint _tmp20_;
+				gchar** _tmp21_;
+				gint _tmp21__length1;
+				gboolean _tmp25_;
+				const gchar* _tmp31_;
+				const gchar* _tmp32_;
+				_tmp7_ = _tmp6_;
+				if (!_tmp7_) {
+					gint _tmp8_;
+					_tmp8_ = i;
+					i = _tmp8_ + 1;
+				}
+				_tmp6_ = FALSE;
+				_tmp10_ = i;
+				_tmp11_ = self->priv->m_layouts;
+				_tmp11__length1 = self->priv->m_layouts_length1;
+				if (_tmp10_ < _tmp11__length1) {
+					gint _tmp12_;
+					gint _tmp13_;
+					_tmp12_ = i;
+					_tmp13_ = gkbd_len;
+					_tmp9_ = _tmp12_ < _tmp13_;
+				} else {
+					_tmp9_ = FALSE;
+				}
+				_tmp14_ = _tmp9_;
+				if (!_tmp14_) {
+					break;
+				}
+				_tmp15_ = self->priv->m_layouts;
+				_tmp15__length1 = self->priv->m_layouts_length1;
+				_tmp16_ = i;
+				_tmp17_ = _tmp15_[_tmp16_];
+				_tmp18_ = g_strdup (_tmp17_);
+				sys_layout = _tmp18_;
+				_tmp20_ = i;
+				_tmp21_ = self->priv->m_variants;
+				_tmp21__length1 = self->priv->m_variants_length1;
+				if (_tmp20_ < _tmp21__length1) {
+					gchar** _tmp22_;
+					gint _tmp22__length1;
+					gint _tmp23_;
+					const gchar* _tmp24_;
+					_tmp22_ = self->priv->m_variants;
+					_tmp22__length1 = self->priv->m_variants_length1;
+					_tmp23_ = i;
+					_tmp24_ = _tmp22_[_tmp23_];
+					_tmp19_ = g_strcmp0 (_tmp24_, "") != 0;
+				} else {
+					_tmp19_ = FALSE;
+				}
+				_tmp25_ = _tmp19_;
+				if (_tmp25_) {
+					const gchar* _tmp26_;
+					gchar** _tmp27_;
+					gint _tmp27__length1;
+					gint _tmp28_;
+					const gchar* _tmp29_;
+					gchar* _tmp30_ = NULL;
+					_tmp26_ = sys_layout;
+					_tmp27_ = self->priv->m_variants;
+					_tmp27__length1 = self->priv->m_variants_length1;
+					_tmp28_ = i;
+					_tmp29_ = _tmp27_[_tmp28_];
+					_tmp30_ = g_strdup_printf ("%s(%s)", _tmp26_, _tmp29_);
+					_g_free0 (sys_layout);
+					sys_layout = _tmp30_;
+				}
+				_tmp31_ = sys_layout;
+				_tmp32_ = layout;
+				if (g_strcmp0 (_tmp31_, _tmp32_) == 0) {
+					GkbdLayout* _tmp33_;
+					gint _tmp34_;
+					_tmp33_ = self->priv->m_gkbdlayout;
+					_tmp34_ = i;
+					gkbd_layout_lock_group (_tmp33_, _tmp34_);
+					result = TRUE;
+					_g_free0 (sys_layout);
+					return result;
+				}
+				_g_free0 (sys_layout);
+			}
+		}
+	}
+	result = FALSE;
+	return result;
+}
+
+
+static void panel_set_layout (Panel* self, const gchar* layout) {
+	gboolean _tmp0_ = FALSE;
+	const gchar* _tmp1_;
+	gboolean _tmp3_;
+	XKBLayout* _tmp4_;
+	XKBLayout* _tmp8_;
+	const gchar* _tmp9_;
+	gint _tmp10_ = 0;
+	gint* _tmp11_ = NULL;
+	gint* _tmp12_;
+	gint _tmp12__length1;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (layout != NULL);
+	_tmp1_ = layout;
+	if (g_strcmp0 (_tmp1_, "default") == 0) {
+		_tmp0_ = TRUE;
+	} else {
+		const gchar* _tmp2_;
+		_tmp2_ = layout;
+		_tmp0_ = _tmp2_ == NULL;
+	}
+	_tmp3_ = _tmp0_;
+	if (_tmp3_) {
+		return;
+	}
+	_tmp4_ = self->priv->m_xkblayout;
+	if (_tmp4_ == NULL) {
+		panel_init_engines_order (self);
+	}
+	if (HAVE_IBUS_GKBD) {
+		const gchar* _tmp5_;
+		gboolean _tmp6_ = FALSE;
+		const gchar* _tmp7_;
+		_tmp5_ = layout;
+		_tmp6_ = panel_set_gkbd_layout (self, _tmp5_);
+		if (_tmp6_) {
+			return;
+		}
+		_tmp7_ = layout;
+		panel_set_xkb_group_layout (self, _tmp7_);
+		return;
+	}
+	_tmp8_ = self->priv->m_xkblayout;
+	_tmp9_ = layout;
+	_tmp11_ = xkb_layout_set_layout (_tmp8_, _tmp9_, "default", "default", &_tmp10_);
+	_tmp12_ = _tmp11_;
+	_tmp12__length1 = _tmp10_;
+	_tmp12_ = (g_free (_tmp12_), NULL);
+}
+
+
+static void _vala_array_add16 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void panel_switch_engine (Panel* self, gint i, gboolean force) {
+	gboolean _tmp0_ = FALSE;
+	gint _tmp1_;
+	gboolean _tmp4_;
+	gboolean _tmp5_ = FALSE;
+	gint _tmp6_;
+	gboolean _tmp8_;
+	IBusEngineDesc** _tmp9_;
+	gint _tmp9__length1;
+	gint _tmp10_;
+	IBusEngineDesc* _tmp11_;
+	IBusEngineDesc* _tmp12_;
+	IBusEngineDesc* engine;
+	IBusEngineDesc** _tmp25_;
+	gint _tmp25__length1;
+	IBusEngineDesc* _tmp26_;
+	IBusEngineDesc* _tmp27_;
+	IBusEngineDesc* _tmp28_;
+	IBusBus* _tmp29_;
+	IBusEngineDesc* _tmp30_;
+	const gchar* _tmp31_ = NULL;
+	gboolean _tmp32_ = FALSE;
+	IBusEngineDesc* _tmp35_;
+	const gchar* _tmp36_ = NULL;
+	gchar** _tmp37_ = NULL;
+	gchar** names;
+	gint names_length1;
+	gint _names_size_;
+	IBusEngineDesc** _tmp38_;
+	gint _tmp38__length1;
+	IBusConfig* _tmp44_;
+	g_return_if_fail (self != NULL);
+	_tmp1_ = i;
+	if (_tmp1_ >= 0) {
+		gint _tmp2_;
+		IBusEngineDesc** _tmp3_;
+		gint _tmp3__length1;
+		_tmp2_ = i;
+		_tmp3_ = self->priv->m_engines;
+		_tmp3__length1 = self->priv->m_engines_length1;
+		_tmp0_ = _tmp2_ < _tmp3__length1;
+	} else {
+		_tmp0_ = FALSE;
+	}
+	_tmp4_ = _tmp0_;
+	g_assert (_tmp4_);
+	_tmp6_ = i;
+	if (_tmp6_ == 0) {
+		gboolean _tmp7_;
+		_tmp7_ = force;
+		_tmp5_ = !_tmp7_;
+	} else {
+		_tmp5_ = FALSE;
+	}
+	_tmp8_ = _tmp5_;
+	if (_tmp8_) {
+		return;
+	}
+	_tmp9_ = self->priv->m_engines;
+	_tmp9__length1 = self->priv->m_engines_length1;
+	_tmp10_ = i;
+	_tmp11_ = _tmp9_[_tmp10_];
+	_tmp12_ = _g_object_ref0 (_tmp11_);
+	engine = _tmp12_;
+	{
+		gint _tmp13_;
+		gint j;
+		_tmp13_ = i;
+		j = _tmp13_;
+		{
+			gboolean _tmp14_;
+			_tmp14_ = TRUE;
+			while (TRUE) {
+				gboolean _tmp15_;
+				gint _tmp17_;
+				IBusEngineDesc** _tmp18_;
+				gint _tmp18__length1;
+				gint _tmp19_;
+				IBusEngineDesc** _tmp20_;
+				gint _tmp20__length1;
+				gint _tmp21_;
+				IBusEngineDesc* _tmp22_;
+				IBusEngineDesc* _tmp23_;
+				IBusEngineDesc* _tmp24_;
+				_tmp15_ = _tmp14_;
+				if (!_tmp15_) {
+					gint _tmp16_;
+					_tmp16_ = j;
+					j = _tmp16_ - 1;
+				}
+				_tmp14_ = FALSE;
+				_tmp17_ = j;
+				if (!(_tmp17_ > 0)) {
+					break;
+				}
+				_tmp18_ = self->priv->m_engines;
+				_tmp18__length1 = self->priv->m_engines_length1;
+				_tmp19_ = j;
+				_tmp20_ = self->priv->m_engines;
+				_tmp20__length1 = self->priv->m_engines_length1;
+				_tmp21_ = j;
+				_tmp22_ = _tmp20_[_tmp21_ - 1];
+				_tmp23_ = _g_object_ref0 (_tmp22_);
+				_g_object_unref0 (_tmp18_[_tmp19_]);
+				_tmp18_[_tmp19_] = _tmp23_;
+				_tmp24_ = _tmp18_[_tmp19_];
+			}
+		}
+	}
+	_tmp25_ = self->priv->m_engines;
+	_tmp25__length1 = self->priv->m_engines_length1;
+	_tmp26_ = engine;
+	_tmp27_ = _g_object_ref0 (_tmp26_);
+	_g_object_unref0 (_tmp25_[0]);
+	_tmp25_[0] = _tmp27_;
+	_tmp28_ = _tmp25_[0];
+	_tmp29_ = self->priv->m_bus;
+	_tmp30_ = engine;
+	_tmp31_ = ibus_engine_desc_get_name (_tmp30_);
+	_tmp32_ = ibus_bus_set_global_engine (_tmp29_, _tmp31_);
+	if (!_tmp32_) {
+		IBusEngineDesc* _tmp33_;
+		const gchar* _tmp34_ = NULL;
+		_tmp33_ = engine;
+		_tmp34_ = ibus_engine_desc_get_name (_tmp33_);
+		g_warning ("panel.vala:367: Switch engine to %s failed.", _tmp34_);
+		_g_object_unref0 (engine);
+		return;
+	}
+	_tmp35_ = engine;
+	_tmp36_ = ibus_engine_desc_get_layout (_tmp35_);
+	panel_set_layout (self, _tmp36_);
+	_tmp37_ = g_new0 (gchar*, 0 + 1);
+	names = _tmp37_;
+	names_length1 = 0;
+	_names_size_ = names_length1;
+	_tmp38_ = self->priv->m_engines;
+	_tmp38__length1 = self->priv->m_engines_length1;
+	{
+		IBusEngineDesc** desc_collection = NULL;
+		gint desc_collection_length1 = 0;
+		gint _desc_collection_size_ = 0;
+		gint desc_it = 0;
+		desc_collection = _tmp38_;
+		desc_collection_length1 = _tmp38__length1;
+		for (desc_it = 0; desc_it < _tmp38__length1; desc_it = desc_it + 1) {
+			IBusEngineDesc* _tmp39_;
+			IBusEngineDesc* desc = NULL;
+			_tmp39_ = _g_object_ref0 (desc_collection[desc_it]);
+			desc = _tmp39_;
+			{
+				gchar** _tmp40_;
+				gint _tmp40__length1;
+				IBusEngineDesc* _tmp41_;
+				const gchar* _tmp42_ = NULL;
+				gchar* _tmp43_;
+				_tmp40_ = names;
+				_tmp40__length1 = names_length1;
+				_tmp41_ = desc;
+				_tmp42_ = ibus_engine_desc_get_name (_tmp41_);
+				_tmp43_ = g_strdup (_tmp42_);
+				_vala_array_add16 (&names, &names_length1, &_names_size_, _tmp43_);
+				_g_object_unref0 (desc);
+			}
+		}
+	}
+	_tmp44_ = self->priv->m_config;
+	if (_tmp44_ != NULL) {
+		IBusConfig* _tmp45_;
+		gchar** _tmp46_;
+		gint _tmp46__length1;
+		GVariant* _tmp47_;
+		GVariant* _tmp48_;
+		_tmp45_ = self->priv->m_config;
+		_tmp46_ = names;
+		_tmp46__length1 = names_length1;
+		_tmp47_ = g_variant_new_strv (_tmp46_, _tmp46__length1);
+		_tmp48_ = g_variant_ref_sink (_tmp47_);
+		ibus_config_set_value (_tmp45_, "general", "engines_order", _tmp48_);
+		_g_variant_unref0 (_tmp48_);
+	}
+	names = (_vala_array_free (names, names_length1, (GDestroyNotify) g_free), NULL);
+	_g_object_unref0 (engine);
+}
+
+
+static void panel_config_value_changed_cb (Panel* self, IBusConfig* config, const gchar* section, const gchar* name, GVariant* variant) {
+	gboolean _tmp0_ = FALSE;
+	const gchar* _tmp1_;
+	gboolean _tmp3_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (config != NULL);
+	g_return_if_fail (section != NULL);
+	g_return_if_fail (name != NULL);
+	g_return_if_fail (variant != NULL);
+	_tmp1_ = section;
+	if (g_strcmp0 (_tmp1_, "general") == 0) {
+		const gchar* _tmp2_;
+		_tmp2_ = name;
+		_tmp0_ = g_strcmp0 (_tmp2_, "preload_engines") == 0;
+	} else {
+		_tmp0_ = FALSE;
+	}
+	_tmp3_ = _tmp0_;
+	if (_tmp3_) {
+		GVariant* _tmp4_;
+		_tmp4_ = variant;
+		panel_update_engines (self, _tmp4_, NULL);
+	}
+}
+
+
+static void panel_handle_engine_switch (Panel* self, GdkEvent* event, gboolean revert) {
+	IBusEngineDesc** _tmp0_;
+	gint _tmp0__length1;
+	GdkEvent* _tmp1_;
+	GdkEventKey _tmp2_;
+	GdkModifierType _tmp3_;
+	guint _tmp4_ = 0U;
+	guint primary_modifiers;
+	GdkEvent* _tmp5_;
+	guint _tmp6_;
+	gboolean _tmp7_ = FALSE;
+	gboolean pressed;
+	gboolean _tmp8_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (event != NULL);
+	_tmp0_ = self->priv->m_engines;
+	_tmp0__length1 = self->priv->m_engines_length1;
+	if (_tmp0__length1 <= 1) {
+		return;
+	}
+	_tmp1_ = event;
+	_tmp2_ = _tmp1_->key;
+	_tmp3_ = _tmp2_.state;
+	_tmp4_ = keybinding_manager_get_primary_modifier ((guint) _tmp3_);
+	primary_modifiers = _tmp4_;
+	_tmp5_ = event;
+	_tmp6_ = primary_modifiers;
+	_tmp7_ = keybinding_manager_primary_modifier_still_pressed (_tmp5_, _tmp6_);
+	pressed = _tmp7_;
+	_tmp8_ = pressed;
+	if (_tmp8_) {
+		gint _tmp9_ = 0;
+		gboolean _tmp10_;
+		gint _tmp12_;
+		gint i;
+		Switcher* _tmp13_;
+		GdkEvent* _tmp14_;
+		IBusEngineDesc** _tmp15_;
+		gint _tmp15__length1;
+		gint _tmp16_;
+		gint _tmp17_ = 0;
+		gint _tmp18_;
+		_tmp10_ = revert;
+		if (_tmp10_) {
+			IBusEngineDesc** _tmp11_;
+			gint _tmp11__length1;
+			_tmp11_ = self->priv->m_engines;
+			_tmp11__length1 = self->priv->m_engines_length1;
+			_tmp9_ = _tmp11__length1 - 1;
+		} else {
+			_tmp9_ = 1;
+		}
+		_tmp12_ = _tmp9_;
+		i = _tmp12_;
+		_tmp13_ = self->priv->m_switcher;
+		_tmp14_ = event;
+		_tmp15_ = self->priv->m_engines;
+		_tmp15__length1 = self->priv->m_engines_length1;
+		_tmp16_ = i;
+		_tmp17_ = switcher_run (_tmp13_, _tmp14_, _tmp15_, _tmp15__length1, _tmp16_);
+		i = _tmp17_;
+		_tmp18_ = i;
+		if (_tmp18_ < 0) {
+			g_debug ("panel.vala:406: switch cancelled");
+		} else {
+			gint _tmp19_;
+			IBusEngineDesc** _tmp20_;
+			gint _tmp20__length1;
+			gint _tmp21_;
+			_tmp19_ = i;
+			_tmp20_ = self->priv->m_engines;
+			_tmp20__length1 = self->priv->m_engines_length1;
+			g_assert (_tmp19_ < _tmp20__length1);
+			_tmp21_ = i;
+			panel_switch_engine (self, _tmp21_, FALSE);
+		}
+	} else {
+		gint _tmp22_ = 0;
+		gboolean _tmp23_;
+		gint _tmp25_;
+		gint i;
+		gint _tmp26_;
+		_tmp23_ = revert;
+		if (_tmp23_) {
+			IBusEngineDesc** _tmp24_;
+			gint _tmp24__length1;
+			_tmp24_ = self->priv->m_engines;
+			_tmp24__length1 = self->priv->m_engines_length1;
+			_tmp22_ = _tmp24__length1 - 1;
+		} else {
+			_tmp22_ = 1;
+		}
+		_tmp25_ = _tmp22_;
+		i = _tmp25_;
+		_tmp26_ = i;
+		panel_switch_engine (self, _tmp26_, FALSE);
+	}
+}
+
+
+static gchar** _vala_array_dup2 (gchar** self, int length) {
+	gchar** result;
+	int i;
+	result = g_new0 (gchar*, length + 1);
+	for (i = 0; i < length; i++) {
+		gchar* _tmp0_;
+		_tmp0_ = g_strdup (self[i]);
+		result[i] = _tmp0_;
+	}
+	return result;
+}
+
+
+static void _vala_array_add17 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add18 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static IBusEngineDesc** _vala_array_dup3 (IBusEngineDesc** self, int length) {
+	IBusEngineDesc** result;
+	int i;
+	result = g_new0 (IBusEngineDesc*, length + 1);
+	for (i = 0; i < length; i++) {
+		IBusEngineDesc* _tmp0_;
+		_tmp0_ = _g_object_ref0 (self[i]);
+		result[i] = _tmp0_;
+	}
+	return result;
+}
+
+
+static IBusEngineDesc** _vala_array_dup4 (IBusEngineDesc** self, int length) {
+	IBusEngineDesc** result;
+	int i;
+	result = g_new0 (IBusEngineDesc*, length + 1);
+	for (i = 0; i < length; i++) {
+		IBusEngineDesc* _tmp0_;
+		_tmp0_ = _g_object_ref0 (self[i]);
+		result[i] = _tmp0_;
+	}
+	return result;
+}
+
+
+static void panel_update_engines (Panel* self, GVariant* var_engines, GVariant* var_order) {
+	gchar** engine_names;
+	gint engine_names_length1;
+	gint _engine_names_size_;
+	GVariant* _tmp0_;
+	gboolean _tmp4_ = FALSE;
+	gchar** _tmp5_;
+	gint _tmp5__length1;
+	gboolean _tmp7_;
+	gchar** _tmp10_ = NULL;
+	gint _tmp10__length1 = 0;
+	gint __tmp10__size_ = 0;
+	GVariant* _tmp11_;
+	gchar** _tmp15_;
+	gint _tmp15__length1;
+	gchar** _tmp16_;
+	gint _tmp16__length1;
+	gchar** order_names;
+	gint order_names_length1;
+	gint _order_names_size_;
+	gchar** _tmp17_ = NULL;
+	gchar** names;
+	gint names_length1;
+	gint _names_size_;
+	gchar** _tmp18_;
+	gint _tmp18__length1;
+	gchar** _tmp25_;
+	gint _tmp25__length1;
+	IBusBus* _tmp32_;
+	gchar** _tmp33_;
+	gint _tmp33__length1;
+	IBusEngineDesc** _tmp34_;
+	IBusEngineDesc** _tmp35_ = NULL;
+	IBusEngineDesc** engines;
+	gint engines_length1;
+	gint _engines_size_;
+	IBusEngineDesc** _tmp36_;
+	gint _tmp36__length1;
+	g_return_if_fail (self != NULL);
+	engine_names = NULL;
+	engine_names_length1 = 0;
+	_engine_names_size_ = engine_names_length1;
+	_tmp0_ = var_engines;
+	if (_tmp0_ != NULL) {
+		GVariant* _tmp1_;
+		size_t _tmp2_;
+		gchar** _tmp3_ = NULL;
+		_tmp1_ = var_engines;
+		_tmp3_ = g_variant_dup_strv (_tmp1_, &_tmp2_);
+		engine_names = (_vala_array_free (engine_names, engine_names_length1, (GDestroyNotify) g_free), NULL);
+		engine_names = _tmp3_;
+		engine_names_length1 = _tmp2_;
+		_engine_names_size_ = engine_names_length1;
+	}
+	_tmp5_ = engine_names;
+	_tmp5__length1 = engine_names_length1;
+	if (_tmp5_ == NULL) {
+		_tmp4_ = TRUE;
+	} else {
+		gchar** _tmp6_;
+		gint _tmp6__length1;
+		_tmp6_ = engine_names;
+		_tmp6__length1 = engine_names_length1;
+		_tmp4_ = _tmp6__length1 == 0;
+	}
+	_tmp7_ = _tmp4_;
+	if (_tmp7_) {
+		gchar* _tmp8_;
+		gchar** _tmp9_ = NULL;
+		_tmp8_ = g_strdup ("xkb:us::eng");
+		_tmp9_ = g_new0 (gchar*, 1 + 1);
+		_tmp9_[0] = _tmp8_;
+		engine_names = (_vala_array_free (engine_names, engine_names_length1, (GDestroyNotify) g_free), NULL);
+		engine_names = _tmp9_;
+		engine_names_length1 = 1;
+		_engine_names_size_ = engine_names_length1;
+	}
+	_tmp11_ = var_order;
+	if (_tmp11_ != NULL) {
+		GVariant* _tmp12_;
+		size_t _tmp13_;
+		gchar** _tmp14_ = NULL;
+		_tmp12_ = var_order;
+		_tmp14_ = g_variant_dup_strv (_tmp12_, &_tmp13_);
+		_tmp10_ = (_vala_array_free (_tmp10_, _tmp10__length1, (GDestroyNotify) g_free), NULL);
+		_tmp10_ = _tmp14_;
+		_tmp10__length1 = _tmp13_;
+		__tmp10__size_ = _tmp10__length1;
+	} else {
+		_tmp10_ = (_vala_array_free (_tmp10_, _tmp10__length1, (GDestroyNotify) g_free), NULL);
+		_tmp10_ = NULL;
+		_tmp10__length1 = 0;
+		__tmp10__size_ = _tmp10__length1;
+	}
+	_tmp15_ = _tmp10_;
+	_tmp15__length1 = _tmp10__length1;
+	_tmp16_ = (_tmp15_ != NULL) ? _vala_array_dup2 (_tmp15_, _tmp15__length1) : ((gpointer) _tmp15_);
+	_tmp16__length1 = _tmp15__length1;
+	order_names = _tmp16_;
+	order_names_length1 = _tmp16__length1;
+	_order_names_size_ = order_names_length1;
+	_tmp17_ = g_new0 (gchar*, 0 + 1);
+	names = _tmp17_;
+	names_length1 = 0;
+	_names_size_ = names_length1;
+	_tmp18_ = order_names;
+	_tmp18__length1 = order_names_length1;
+	{
+		gchar** name_collection = NULL;
+		gint name_collection_length1 = 0;
+		gint _name_collection_size_ = 0;
+		gint name_it = 0;
+		name_collection = _tmp18_;
+		name_collection_length1 = _tmp18__length1;
+		for (name_it = 0; name_it < _tmp18__length1; name_it = name_it + 1) {
+			gchar* _tmp19_;
+			gchar* name = NULL;
+			_tmp19_ = g_strdup (name_collection[name_it]);
+			name = _tmp19_;
+			{
+				const gchar* _tmp20_;
+				gchar** _tmp21_;
+				gint _tmp21__length1;
+				_tmp20_ = name;
+				_tmp21_ = engine_names;
+				_tmp21__length1 = engine_names_length1;
+				if (_vala_string_array_contains (_tmp21_, _tmp21__length1, _tmp20_)) {
+					gchar** _tmp22_;
+					gint _tmp22__length1;
+					const gchar* _tmp23_;
+					gchar* _tmp24_;
+					_tmp22_ = names;
+					_tmp22__length1 = names_length1;
+					_tmp23_ = name;
+					_tmp24_ = g_strdup (_tmp23_);
+					_vala_array_add17 (&names, &names_length1, &_names_size_, _tmp24_);
+				}
+				_g_free0 (name);
+			}
+		}
+	}
+	_tmp25_ = engine_names;
+	_tmp25__length1 = engine_names_length1;
+	{
+		gchar** name_collection = NULL;
+		gint name_collection_length1 = 0;
+		gint _name_collection_size_ = 0;
+		gint name_it = 0;
+		name_collection = _tmp25_;
+		name_collection_length1 = _tmp25__length1;
+		for (name_it = 0; name_it < _tmp25__length1; name_it = name_it + 1) {
+			gchar* _tmp26_;
+			gchar* name = NULL;
+			_tmp26_ = g_strdup (name_collection[name_it]);
+			name = _tmp26_;
+			{
+				const gchar* _tmp27_;
+				gchar** _tmp28_;
+				gint _tmp28__length1;
+				gchar** _tmp29_;
+				gint _tmp29__length1;
+				const gchar* _tmp30_;
+				gchar* _tmp31_;
+				_tmp27_ = name;
+				_tmp28_ = names;
+				_tmp28__length1 = names_length1;
+				if (_vala_string_array_contains (_tmp28_, _tmp28__length1, _tmp27_)) {
+					_g_free0 (name);
+					continue;
+				}
+				_tmp29_ = names;
+				_tmp29__length1 = names_length1;
+				_tmp30_ = name;
+				_tmp31_ = g_strdup (_tmp30_);
+				_vala_array_add18 (&names, &names_length1, &_names_size_, _tmp31_);
+				_g_free0 (name);
+			}
+		}
+	}
+	_tmp32_ = self->priv->m_bus;
+	_tmp33_ = names;
+	_tmp33__length1 = names_length1;
+	_tmp35_ = _tmp34_ = ibus_bus_get_engines_by_names (_tmp32_, _tmp33_);
+	engines = _tmp35_;
+	engines_length1 = _vala_array_length (_tmp34_);
+	_engines_size_ = engines_length1;
+	_tmp36_ = self->priv->m_engines;
+	_tmp36__length1 = self->priv->m_engines_length1;
+	if (_tmp36__length1 == 0) {
+		IBusEngineDesc** _tmp37_;
+		gint _tmp37__length1;
+		IBusEngineDesc** _tmp38_;
+		gint _tmp38__length1;
+		_tmp37_ = engines;
+		_tmp37__length1 = engines_length1;
+		_tmp38_ = (_tmp37_ != NULL) ? _vala_array_dup3 (_tmp37_, _tmp37__length1) : ((gpointer) _tmp37_);
+		_tmp38__length1 = _tmp37__length1;
+		self->priv->m_engines = (_vala_array_free (self->priv->m_engines, self->priv->m_engines_length1, (GDestroyNotify) g_object_unref), NULL);
+		self->priv->m_engines = _tmp38_;
+		self->priv->m_engines_length1 = _tmp38__length1;
+		self->priv->_m_engines_size_ = self->priv->m_engines_length1;
+		panel_switch_engine (self, 0, TRUE);
+	} else {
+		IBusEngineDesc** _tmp39_;
+		gint _tmp39__length1;
+		IBusEngineDesc* _tmp40_;
+		IBusEngineDesc* _tmp41_;
+		IBusEngineDesc* current_engine;
+		IBusEngineDesc** _tmp42_;
+		gint _tmp42__length1;
+		IBusEngineDesc** _tmp43_;
+		gint _tmp43__length1;
+		gint i = 0;
+		_tmp39_ = self->priv->m_engines;
+		_tmp39__length1 = self->priv->m_engines_length1;
+		_tmp40_ = _tmp39_[0];
+		_tmp41_ = _g_object_ref0 (_tmp40_);
+		current_engine = _tmp41_;
+		_tmp42_ = engines;
+		_tmp42__length1 = engines_length1;
+		_tmp43_ = (_tmp42_ != NULL) ? _vala_array_dup4 (_tmp42_, _tmp42__length1) : ((gpointer) _tmp42_);
+		_tmp43__length1 = _tmp42__length1;
+		self->priv->m_engines = (_vala_array_free (self->priv->m_engines, self->priv->m_engines_length1, (GDestroyNotify) g_object_unref), NULL);
+		self->priv->m_engines = _tmp43_;
+		self->priv->m_engines_length1 = _tmp43__length1;
+		self->priv->_m_engines_size_ = self->priv->m_engines_length1;
+		{
+			gboolean _tmp44_;
+			i = 0;
+			_tmp44_ = TRUE;
+			while (TRUE) {
+				gboolean _tmp45_;
+				gint _tmp47_;
+				IBusEngineDesc** _tmp48_;
+				gint _tmp48__length1;
+				IBusEngineDesc* _tmp49_;
+				const gchar* _tmp50_ = NULL;
+				IBusEngineDesc** _tmp51_;
+				gint _tmp51__length1;
+				gint _tmp52_;
+				IBusEngineDesc* _tmp53_;
+				const gchar* _tmp54_ = NULL;
+				_tmp45_ = _tmp44_;
+				if (!_tmp45_) {
+					gint _tmp46_;
+					_tmp46_ = i;
+					i = _tmp46_ + 1;
+				}
+				_tmp44_ = FALSE;
+				_tmp47_ = i;
+				_tmp48_ = self->priv->m_engines;
+				_tmp48__length1 = self->priv->m_engines_length1;
+				if (!(_tmp47_ < _tmp48__length1)) {
+					break;
+				}
+				_tmp49_ = current_engine;
+				_tmp50_ = ibus_engine_desc_get_name (_tmp49_);
+				_tmp51_ = engines;
+				_tmp51__length1 = engines_length1;
+				_tmp52_ = i;
+				_tmp53_ = _tmp51_[_tmp52_];
+				_tmp54_ = ibus_engine_desc_get_name (_tmp53_);
+				if (g_strcmp0 (_tmp50_, _tmp54_) == 0) {
+					gint _tmp55_;
+					_tmp55_ = i;
+					panel_switch_engine (self, _tmp55_, FALSE);
+					_g_object_unref0 (current_engine);
+					engines = (_vala_array_free (engines, engines_length1, (GDestroyNotify) g_object_unref), NULL);
+					names = (_vala_array_free (names, names_length1, (GDestroyNotify) g_free), NULL);
+					order_names = (_vala_array_free (order_names, order_names_length1, (GDestroyNotify) g_free), NULL);
+					_tmp10_ = (_vala_array_free (_tmp10_, _tmp10__length1, (GDestroyNotify) g_free), NULL);
+					engine_names = (_vala_array_free (engine_names, engine_names_length1, (GDestroyNotify) g_free), NULL);
+					return;
+				}
+			}
+		}
+		panel_switch_engine (self, 0, TRUE);
+		_g_object_unref0 (current_engine);
+	}
+	engines = (_vala_array_free (engines, engines_length1, (GDestroyNotify) g_object_unref), NULL);
+	names = (_vala_array_free (names, names_length1, (GDestroyNotify) g_free), NULL);
+	order_names = (_vala_array_free (order_names, order_names_length1, (GDestroyNotify) g_free), NULL);
+	_tmp10_ = (_vala_array_free (_tmp10_, _tmp10__length1, (GDestroyNotify) g_free), NULL);
+	engine_names = (_vala_array_free (engine_names, engine_names_length1, (GDestroyNotify) g_free), NULL);
+}
+
+
+static void __lambda18_ (Panel* self, GPid pid, gint state) {
+	GPid _tmp0_;
+	GPid _tmp1_;
+	GPid _tmp2_;
+	_tmp0_ = pid;
+	_tmp1_ = self->priv->m_setup_pid;
+	if (_tmp0_ != _tmp1_) {
+		return;
+	}
+	self->priv->m_setup_pid = (GPid) 0;
+	_tmp2_ = pid;
+	g_spawn_close_pid (_tmp2_);
+}
+
+
+static void ___lambda18__gchild_watch_func (GPid pid, gint status, gpointer self) {
+	__lambda18_ (self, pid, status);
+}
+
+
+static void panel_show_setup_dialog (Panel* self) {
+	GPid _tmp0_;
+	gchar* _tmp3_ = NULL;
+	gchar* binary;
+	GPid _tmp13_;
+	GError * _inner_error_ = NULL;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_setup_pid;
+	if (_tmp0_ != ((GPid) 0)) {
+		GPid _tmp1_;
+		gint _tmp2_ = 0;
+		_tmp1_ = self->priv->m_setup_pid;
+		_tmp2_ = kill ((pid_t) _tmp1_, SIGUSR1);
+		if (_tmp2_ == 0) {
+			return;
+		}
+		self->priv->m_setup_pid = (GPid) 0;
+	}
+	_tmp3_ = g_build_filename (BINDIR, "ibus-setup", NULL);
+	binary = _tmp3_;
+	{
+		const gchar* _tmp4_;
+		gchar* _tmp5_;
+		gchar* _tmp6_;
+		gchar** _tmp7_ = NULL;
+		gchar** _tmp8_;
+		gint _tmp8__length1;
+		GPid _tmp9_ = 0;
+		_tmp4_ = binary;
+		_tmp5_ = g_strdup (_tmp4_);
+		_tmp6_ = g_strdup ("ibus-setup");
+		_tmp7_ = g_new0 (gchar*, 2 + 1);
+		_tmp7_[0] = _tmp5_;
+		_tmp7_[1] = _tmp6_;
+		_tmp8_ = _tmp7_;
+		_tmp8__length1 = 2;
+		g_spawn_async (NULL, _tmp8_, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp9_, &_inner_error_);
+		self->priv->m_setup_pid = _tmp9_;
+		_tmp8_ = (_vala_array_free (_tmp8_, _tmp8__length1, (GDestroyNotify) g_free), NULL);
+		if (_inner_error_ != NULL) {
+			if (_inner_error_->domain == G_SPAWN_ERROR) {
+				goto __catch2_g_spawn_error;
+			}
+			_g_free0 (binary);
+			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+			g_clear_error (&_inner_error_);
+			return;
+		}
+	}
+	goto __finally2;
+	__catch2_g_spawn_error:
+	{
+		GError* e = NULL;
+		const gchar* _tmp10_;
+		GError* _tmp11_;
+		const gchar* _tmp12_;
+		e = _inner_error_;
+		_inner_error_ = NULL;
+		_tmp10_ = binary;
+		_tmp11_ = e;
+		_tmp12_ = _tmp11_->message;
+		g_warning ("panel.vala:478: Execute %s failed! %s", _tmp10_, _tmp12_);
+		self->priv->m_setup_pid = (GPid) 0;
+		_g_error_free0 (e);
+	}
+	__finally2:
+	if (_inner_error_ != NULL) {
+		_g_free0 (binary);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+		g_clear_error (&_inner_error_);
+		return;
+	}
+	_tmp13_ = self->priv->m_setup_pid;
+	g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp13_, ___lambda18__gchild_watch_func, g_object_ref (self), g_object_unref);
+	_g_free0 (binary);
+}
+
+
+static void panel_show_about_dialog (Panel* self) {
+	GtkAboutDialog* _tmp0_;
+	GtkAboutDialog* _tmp25_;
+	gboolean _tmp26_ = FALSE;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_about_dialog;
+	if (_tmp0_ == NULL) {
+		GtkAboutDialog* _tmp1_;
+		GtkAboutDialog* _tmp2_;
+		GtkAboutDialog* _tmp3_;
+		GtkAboutDialog* _tmp4_;
+		const gchar* _tmp5_ = NULL;
+		gchar* _tmp6_;
+		gchar* copyright;
+		GtkAboutDialog* _tmp7_;
+		const gchar* _tmp8_;
+		GtkAboutDialog* _tmp9_;
+		GtkAboutDialog* _tmp10_;
+		const gchar* _tmp11_ = NULL;
+		GtkAboutDialog* _tmp12_;
+		GtkAboutDialog* _tmp13_;
+		gchar* _tmp14_;
+		gchar** _tmp15_ = NULL;
+		gchar** _tmp16_;
+		gint _tmp16__length1;
+		GtkAboutDialog* _tmp17_;
+		gchar* _tmp18_;
+		gchar** _tmp19_ = NULL;
+		gchar** _tmp20_;
+		gint _tmp20__length1;
+		GtkAboutDialog* _tmp21_;
+		const gchar* _tmp22_ = NULL;
+		GtkAboutDialog* _tmp23_;
+		GtkAboutDialog* _tmp24_;
+		_tmp1_ = (GtkAboutDialog*) gtk_about_dialog_new ();
+		_tmp2_ = g_object_ref_sink (_tmp1_);
+		_g_object_unref0 (self->priv->m_about_dialog);
+		self->priv->m_about_dialog = _tmp2_;
+		_tmp3_ = self->priv->m_about_dialog;
+		gtk_about_dialog_set_program_name (_tmp3_, "IBus");
+		_tmp4_ = self->priv->m_about_dialog;
+		gtk_about_dialog_set_version (_tmp4_, IBUS_VERSION);
+		_tmp5_ = _ ("Copyright (c) 2007-2012 Peng Huang\n" "Copyright (c) 2007-2010 Red Hat, Inc.\n");
+		_tmp6_ = g_strdup (_tmp5_);
+		copyright = _tmp6_;
+		_tmp7_ = self->priv->m_about_dialog;
+		_tmp8_ = copyright;
+		gtk_about_dialog_set_copyright (_tmp7_, _tmp8_);
+		_tmp9_ = self->priv->m_about_dialog;
+		gtk_about_dialog_set_license (_tmp9_, "LGPL");
+		_tmp10_ = self->priv->m_about_dialog;
+		_tmp11_ = _ ("IBus is an intelligent input bus for Linux/Unix.");
+		gtk_about_dialog_set_comments (_tmp10_, _tmp11_);
+		_tmp12_ = self->priv->m_about_dialog;
+		gtk_about_dialog_set_website (_tmp12_, "http://code.google.com/p/ibus");
+		_tmp13_ = self->priv->m_about_dialog;
+		_tmp14_ = g_strdup ("Peng Huang <shawn.p.huang@gmail.com>");
+		_tmp15_ = g_new0 (gchar*, 1 + 1);
+		_tmp15_[0] = _tmp14_;
+		_tmp16_ = _tmp15_;
+		_tmp16__length1 = 1;
+		gtk_about_dialog_set_authors (_tmp13_, _tmp16_);
+		_tmp16_ = (_vala_array_free (_tmp16_, _tmp16__length1, (GDestroyNotify) g_free), NULL);
+		_tmp17_ = self->priv->m_about_dialog;
+		_tmp18_ = g_strdup ("Peng Huang <shawn.p.huang@gmail.com>");
+		_tmp19_ = g_new0 (gchar*, 1 + 1);
+		_tmp19_[0] = _tmp18_;
+		_tmp20_ = _tmp19_;
+		_tmp20__length1 = 1;
+		gtk_about_dialog_set_documenters (_tmp17_, _tmp20_);
+		_tmp20_ = (_vala_array_free (_tmp20_, _tmp20__length1, (GDestroyNotify) g_free), NULL);
+		_tmp21_ = self->priv->m_about_dialog;
+		_tmp22_ = _ ("translator-credits");
+		gtk_about_dialog_set_translator_credits (_tmp21_, _tmp22_);
+		_tmp23_ = self->priv->m_about_dialog;
+		gtk_about_dialog_set_logo_icon_name (_tmp23_, "ibus");
+		_tmp24_ = self->priv->m_about_dialog;
+		gtk_window_set_icon_name ((GtkWindow*) _tmp24_, "ibus");
+		_g_free0 (copyright);
+	}
+	_tmp25_ = self->priv->m_about_dialog;
+	_tmp26_ = gtk_widget_get_visible ((GtkWidget*) _tmp25_);
+	if (!_tmp26_) {
+		GtkAboutDialog* _tmp27_;
+		GtkAboutDialog* _tmp28_;
+		_tmp27_ = self->priv->m_about_dialog;
+		gtk_dialog_run ((GtkDialog*) _tmp27_);
+		_tmp28_ = self->priv->m_about_dialog;
+		gtk_widget_hide ((GtkWidget*) _tmp28_);
+	} else {
+		GtkAboutDialog* _tmp29_;
+		_tmp29_ = self->priv->m_about_dialog;
+		gtk_window_present ((GtkWindow*) _tmp29_);
+	}
+}
+
+
+static void ___lambda17_ (Panel* self, GtkMenuItem* i) {
+	g_return_if_fail (i != NULL);
+	panel_show_setup_dialog (self);
+}
+
+
+static void ____lambda17__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
+	___lambda17_ (self, _sender);
+}
+
+
+static void ___lambda19_ (Panel* self, GtkMenuItem* i) {
+	g_return_if_fail (i != NULL);
+	panel_show_about_dialog (self);
+}
+
+
+static void ____lambda19__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
+	___lambda19_ (self, _sender);
+}
+
+
+static void ___lambda20_ (Panel* self, GtkMenuItem* i) {
+	IBusBus* _tmp0_;
+	g_return_if_fail (i != NULL);
+	_tmp0_ = self->priv->m_bus;
+	ibus_bus_exit (_tmp0_, TRUE);
+}
+
+
+static void ____lambda20__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
+	___lambda20_ (self, _sender);
+}
+
+
+static void ___lambda21_ (Panel* self, GtkMenuItem* i) {
+	IBusBus* _tmp0_;
+	g_return_if_fail (i != NULL);
+	_tmp0_ = self->priv->m_bus;
+	ibus_bus_exit (_tmp0_, FALSE);
+}
+
+
+static void ____lambda21__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
+	___lambda21_ (self, _sender);
+}
+
+
+static void _gtk_status_icon_position_menu_gtk_menu_position_func (GtkMenu* menu, gint* x, gint* y, gboolean* push_in, gpointer self) {
+	gtk_status_icon_position_menu (menu, x, y, push_in, self);
+}
+
+
+static void panel_status_icon_popup_menu_cb (Panel* self, GtkStatusIcon* status_icon, guint button, guint activate_time) {
+	GtkMenu* _tmp0_;
+	GtkMenu* _tmp29_;
+	GtkStatusIcon* _tmp30_;
+	guint32 _tmp31_ = 0U;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (status_icon != NULL);
+	_tmp0_ = self->priv->m_sys_menu;
+	if (_tmp0_ == NULL) {
+		GtkImageMenuItem* item = NULL;
+		GtkMenu* _tmp1_;
+		GtkMenu* _tmp2_;
+		GtkImageMenuItem* _tmp3_;
+		GtkImageMenuItem* _tmp4_;
+		GtkImageMenuItem* _tmp5_;
+		GtkMenu* _tmp6_;
+		GtkImageMenuItem* _tmp7_;
+		GtkImageMenuItem* _tmp8_;
+		GtkImageMenuItem* _tmp9_;
+		GtkImageMenuItem* _tmp10_;
+		GtkMenu* _tmp11_;
+		GtkImageMenuItem* _tmp12_;
+		GtkMenu* _tmp13_;
+		GtkSeparatorMenuItem* _tmp14_;
+		GtkSeparatorMenuItem* _tmp15_;
+		GtkImageMenuItem* _tmp16_;
+		GtkImageMenuItem* _tmp17_;
+		GtkImageMenuItem* _tmp18_;
+		const gchar* _tmp19_ = NULL;
+		GtkImageMenuItem* _tmp20_;
+		GtkMenu* _tmp21_;
+		GtkImageMenuItem* _tmp22_;
+		GtkImageMenuItem* _tmp23_;
+		GtkImageMenuItem* _tmp24_;
+		GtkImageMenuItem* _tmp25_;
+		GtkMenu* _tmp26_;
+		GtkImageMenuItem* _tmp27_;
+		GtkMenu* _tmp28_;
+		_tmp1_ = (GtkMenu*) gtk_menu_new ();
+		_tmp2_ = g_object_ref_sink (_tmp1_);
+		_g_object_unref0 (self->priv->m_sys_menu);
+		self->priv->m_sys_menu = _tmp2_;
+		_tmp3_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_PREFERENCES, NULL);
+		_tmp4_ = g_object_ref_sink (_tmp3_);
+		_g_object_unref0 (item);
+		item = _tmp4_;
+		_tmp5_ = item;
+		g_signal_connect_object ((GtkMenuItem*) _tmp5_, "activate", (GCallback) ____lambda17__gtk_menu_item_activate, self, 0);
+		_tmp6_ = self->priv->m_sys_menu;
+		_tmp7_ = item;
+		gtk_menu_shell_append ((GtkMenuShell*) _tmp6_, (GtkWidget*) ((GtkMenuItem*) _tmp7_));
+		_tmp8_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_ABOUT, NULL);
+		_tmp9_ = g_object_ref_sink (_tmp8_);
+		_g_object_unref0 (item);
+		item = _tmp9_;
+		_tmp10_ = item;
+		g_signal_connect_object ((GtkMenuItem*) _tmp10_, "activate", (GCallback) ____lambda19__gtk_menu_item_activate, self, 0);
+		_tmp11_ = self->priv->m_sys_menu;
+		_tmp12_ = item;
+		gtk_menu_shell_append ((GtkMenuShell*) _tmp11_, (GtkWidget*) ((GtkMenuItem*) _tmp12_));
+		_tmp13_ = self->priv->m_sys_menu;
+		_tmp14_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
+		_tmp15_ = g_object_ref_sink (_tmp14_);
+		gtk_menu_shell_append ((GtkMenuShell*) _tmp13_, (GtkWidget*) ((GtkMenuItem*) _tmp15_));
+		_g_object_unref0 (_tmp15_);
+		_tmp16_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_REFRESH, NULL);
+		_tmp17_ = g_object_ref_sink (_tmp16_);
+		_g_object_unref0 (item);
+		item = _tmp17_;
+		_tmp18_ = item;
+		_tmp19_ = _ ("Restart");
+		gtk_menu_item_set_label ((GtkMenuItem*) _tmp18_, _tmp19_);
+		_tmp20_ = item;
+		g_signal_connect_object ((GtkMenuItem*) _tmp20_, "activate", (GCallback) ____lambda20__gtk_menu_item_activate, self, 0);
+		_tmp21_ = self->priv->m_sys_menu;
+		_tmp22_ = item;
+		gtk_menu_shell_append ((GtkMenuShell*) _tmp21_, (GtkWidget*) ((GtkMenuItem*) _tmp22_));
+		_tmp23_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_QUIT, NULL);
+		_tmp24_ = g_object_ref_sink (_tmp23_);
+		_g_object_unref0 (item);
+		item = _tmp24_;
+		_tmp25_ = item;
+		g_signal_connect_object ((GtkMenuItem*) _tmp25_, "activate", (GCallback) ____lambda21__gtk_menu_item_activate, self, 0);
+		_tmp26_ = self->priv->m_sys_menu;
+		_tmp27_ = item;
+		gtk_menu_shell_append ((GtkMenuShell*) _tmp26_, (GtkWidget*) ((GtkMenuItem*) _tmp27_));
+		_tmp28_ = self->priv->m_sys_menu;
+		gtk_widget_show_all ((GtkWidget*) _tmp28_);
+		_g_object_unref0 (item);
+	}
+	_tmp29_ = self->priv->m_sys_menu;
+	_tmp30_ = self->priv->m_status_icon;
+	_tmp31_ = gtk_get_current_event_time ();
+	gtk_menu_popup (_tmp29_, NULL, NULL, _gtk_status_icon_position_menu_gtk_menu_position_func, _tmp30_, (guint) 0, _tmp31_);
+}
+
+
+static Block4Data* block4_data_ref (Block4Data* _data4_) {
+	g_atomic_int_inc (&_data4_->_ref_count_);
+	return _data4_;
+}
+
+
+static void block4_data_unref (Block4Data* _data4_) {
+	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
+		Panel * self;
+		self = _data4_->self;
+		_g_object_unref0 (_data4_->e);
+		_g_object_unref0 (self);
+		g_slice_free (Block4Data, _data4_);
+	}
+}
+
+
+static void ____lambda22_ (Block4Data* _data4_, GtkMenuItem* item) {
+	Panel * self;
+	self = _data4_->self;
+	g_return_if_fail (item != NULL);
+	{
+		gint i;
+		i = 0;
+		{
+			gboolean _tmp0_;
+			_tmp0_ = TRUE;
+			while (TRUE) {
+				gboolean _tmp1_;
+				gint _tmp3_;
+				IBusEngineDesc** _tmp4_;
+				gint _tmp4__length1;
+				IBusEngineDesc* _tmp5_;
+				IBusEngineDesc** _tmp6_;
+				gint _tmp6__length1;
+				gint _tmp7_;
+				IBusEngineDesc* _tmp8_;
+				_tmp1_ = _tmp0_;
+				if (!_tmp1_) {
+					gint _tmp2_;
+					_tmp2_ = i;
+					i = _tmp2_ + 1;
+				}
+				_tmp0_ = FALSE;
+				_tmp3_ = i;
+				_tmp4_ = self->priv->m_engines;
+				_tmp4__length1 = self->priv->m_engines_length1;
+				if (!(_tmp3_ < _tmp4__length1)) {
+					break;
+				}
+				_tmp5_ = _data4_->e;
+				_tmp6_ = self->priv->m_engines;
+				_tmp6__length1 = self->priv->m_engines_length1;
+				_tmp7_ = i;
+				_tmp8_ = _tmp6_[_tmp7_];
+				if (_tmp5_ == _tmp8_) {
+					gint _tmp9_;
+					_tmp9_ = i;
+					panel_switch_engine (self, _tmp9_, FALSE);
+					break;
+				}
+			}
+		}
+	}
+}
+
+
+static void _____lambda22__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
+	____lambda22_ (self, _sender);
+}
+
+
+static void panel_status_icon_activate_cb (Panel* self, GtkStatusIcon* status_icon) {
+	GtkMenu* _tmp0_;
+	GtkMenu* _tmp1_;
+	PropertyManager* _tmp2_;
+	GtkMenu* _tmp3_;
+	GtkMenu* _tmp4_;
+	GtkSeparatorMenuItem* _tmp5_;
+	GtkSeparatorMenuItem* _tmp6_;
+	gint width = 0;
+	gint height = 0;
+	gint _tmp7_ = 0;
+	gint _tmp8_ = 0;
+	IBusEngineDesc** _tmp9_;
+	gint _tmp9__length1;
+	GtkMenu* _tmp31_;
+	GtkMenu* _tmp32_;
+	GtkMenu* _tmp33_;
+	GtkStatusIcon* _tmp34_;
+	guint32 _tmp35_ = 0U;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (status_icon != NULL);
+	_tmp0_ = (GtkMenu*) gtk_menu_new ();
+	_tmp1_ = g_object_ref_sink (_tmp0_);
+	_g_object_unref0 (self->priv->m_ime_menu);
+	self->priv->m_ime_menu = _tmp1_;
+	_tmp2_ = self->priv->m_property_manager;
+	_tmp3_ = self->priv->m_ime_menu;
+	property_manager_create_menu_items (_tmp2_, _tmp3_);
+	_tmp4_ = self->priv->m_ime_menu;
+	_tmp5_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
+	_tmp6_ = g_object_ref_sink (_tmp5_);
+	gtk_menu_shell_append ((GtkMenuShell*) _tmp4_, (GtkWidget*) ((GtkMenuItem*) _tmp6_));
+	_g_object_unref0 (_tmp6_);
+	gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &_tmp7_, &_tmp8_);
+	width = _tmp7_;
+	height = _tmp8_;
+	_tmp9_ = self->priv->m_engines;
+	_tmp9__length1 = self->priv->m_engines_length1;
+	{
+		IBusEngineDesc** engine_collection = NULL;
+		gint engine_collection_length1 = 0;
+		gint _engine_collection_size_ = 0;
+		gint engine_it = 0;
+		engine_collection = _tmp9_;
+		engine_collection_length1 = _tmp9__length1;
+		for (engine_it = 0; engine_it < _tmp9__length1; engine_it = engine_it + 1) {
+			IBusEngineDesc* _tmp10_;
+			IBusEngineDesc* engine = NULL;
+			_tmp10_ = _g_object_ref0 (engine_collection[engine_it]);
+			engine = _tmp10_;
+			{
+				Block4Data* _data4_;
+				IBusEngineDesc* _tmp11_;
+				const gchar* _tmp12_ = NULL;
+				gchar* _tmp13_;
+				gchar* longname;
+				const gchar* _tmp14_;
+				GtkImageMenuItem* _tmp15_;
+				GtkImageMenuItem* _tmp16_;
+				GtkImageMenuItem* item;
+				IBusEngineDesc* _tmp17_;
+				const gchar* _tmp18_ = NULL;
+				IBusEngineDesc* _tmp26_;
+				IBusEngineDesc* _tmp27_;
+				GtkImageMenuItem* _tmp28_;
+				GtkMenu* _tmp29_;
+				GtkImageMenuItem* _tmp30_;
+				_data4_ = g_slice_new0 (Block4Data);
+				_data4_->_ref_count_ = 1;
+				_data4_->self = g_object_ref (self);
+				_tmp11_ = engine;
+				_tmp12_ = ibus_engine_desc_get_longname (_tmp11_);
+				_tmp13_ = g_strdup (_tmp12_);
+				longname = _tmp13_;
+				_tmp14_ = longname;
+				_tmp15_ = (GtkImageMenuItem*) gtk_image_menu_item_new_with_label (_tmp14_);
+				_tmp16_ = g_object_ref_sink (_tmp15_);
+				item = _tmp16_;
+				_tmp17_ = engine;
+				_tmp18_ = ibus_engine_desc_get_icon (_tmp17_);
+				if (g_strcmp0 (_tmp18_, "") != 0) {
+					IBusEngineDesc* _tmp19_;
+					const gchar* _tmp20_ = NULL;
+					gint _tmp21_;
+					IconWidget* _tmp22_;
+					IconWidget* _tmp23_;
+					IconWidget* icon;
+					GtkImageMenuItem* _tmp24_;
+					IconWidget* _tmp25_;
+					_tmp19_ = engine;
+					_tmp20_ = ibus_engine_desc_get_icon (_tmp19_);
+					_tmp21_ = width;
+					_tmp22_ = icon_widget_new (_tmp20_, _tmp21_);
+					_tmp23_ = g_object_ref_sink (_tmp22_);
+					icon = _tmp23_;
+					_tmp24_ = item;
+					_tmp25_ = icon;
+					gtk_image_menu_item_set_image (_tmp24_, (GtkWidget*) _tmp25_);
+					_g_object_unref0 (icon);
+				}
+				_tmp26_ = engine;
+				_tmp27_ = _g_object_ref0 (_tmp26_);
+				_data4_->e = _tmp27_;
+				_tmp28_ = item;
+				g_signal_connect_data ((GtkMenuItem*) _tmp28_, "activate", (GCallback) _____lambda22__gtk_menu_item_activate, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
+				_tmp29_ = self->priv->m_ime_menu;
+				_tmp30_ = item;
+				gtk_container_add ((GtkContainer*) _tmp29_, (GtkWidget*) _tmp30_);
+				_g_object_unref0 (item);
+				_g_free0 (longname);
+				_g_object_unref0 (engine);
+				block4_data_unref (_data4_);
+				_data4_ = NULL;
+			}
+		}
+	}
+	_tmp31_ = self->priv->m_ime_menu;
+	gtk_widget_show_all ((GtkWidget*) _tmp31_);
+	_tmp32_ = self->priv->m_ime_menu;
+	gtk_menu_shell_set_take_focus ((GtkMenuShell*) _tmp32_, FALSE);
+	_tmp33_ = self->priv->m_ime_menu;
+	_tmp34_ = self->priv->m_status_icon;
+	_tmp35_ = gtk_get_current_event_time ();
+	gtk_menu_popup (_tmp33_, NULL, NULL, _gtk_status_icon_position_menu_gtk_menu_position_func, _tmp34_, (guint) 0, _tmp35_);
+}
+
+
+static void panel_real_set_cursor_location (IBusPanelService* base, gint x, gint y, gint width, gint height) {
+	Panel * self;
+	CandidatePanel* _tmp0_;
+	gint _tmp1_;
+	gint _tmp2_;
+	gint _tmp3_;
+	gint _tmp4_;
+	self = (Panel*) base;
+	_tmp0_ = self->priv->m_candidate_panel;
+	_tmp1_ = x;
+	_tmp2_ = y;
+	_tmp3_ = width;
+	_tmp4_ = height;
+	candidate_panel_set_cursor_location (_tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
+}
+
+
+static void panel_real_focus_in (IBusPanelService* base, const gchar* input_context_path) {
+	Panel * self;
+	self = (Panel*) base;
+	g_return_if_fail (input_context_path != NULL);
+}
+
+
+static void panel_real_focus_out (IBusPanelService* base, const gchar* input_context_path) {
+	Panel * self;
+	self = (Panel*) base;
+	g_return_if_fail (input_context_path != NULL);
+}
+
+
+static void panel_real_register_properties (IBusPanelService* base, IBusPropList* props) {
+	Panel * self;
+	PropertyManager* _tmp0_;
+	IBusPropList* _tmp1_;
+	self = (Panel*) base;
+	g_return_if_fail (props != NULL);
+	_tmp0_ = self->priv->m_property_manager;
+	_tmp1_ = props;
+	property_manager_set_properties (_tmp0_, _tmp1_);
+}
+
+
+static void panel_real_update_property (IBusPanelService* base, IBusProperty* prop) {
+	Panel * self;
+	PropertyManager* _tmp0_;
+	IBusProperty* _tmp1_;
+	self = (Panel*) base;
+	g_return_if_fail (prop != NULL);
+	_tmp0_ = self->priv->m_property_manager;
+	_tmp1_ = prop;
+	property_manager_update_property (_tmp0_, _tmp1_);
+}
+
+
+static void panel_real_update_preedit_text (IBusPanelService* base, IBusText* text, guint cursor_pos, gboolean visible) {
+	Panel * self;
+	gboolean _tmp0_;
+	self = (Panel*) base;
+	g_return_if_fail (text != NULL);
+	_tmp0_ = visible;
+	if (_tmp0_) {
+		CandidatePanel* _tmp1_;
+		IBusText* _tmp2_;
+		guint _tmp3_;
+		_tmp1_ = self->priv->m_candidate_panel;
+		_tmp2_ = text;
+		_tmp3_ = cursor_pos;
+		candidate_panel_set_preedit_text (_tmp1_, _tmp2_, _tmp3_);
+	} else {
+		CandidatePanel* _tmp4_;
+		_tmp4_ = self->priv->m_candidate_panel;
+		candidate_panel_set_preedit_text (_tmp4_, NULL, (guint) 0);
+	}
+}
+
+
+static void panel_real_hide_preedit_text (IBusPanelService* base) {
+	Panel * self;
+	CandidatePanel* _tmp0_;
+	self = (Panel*) base;
+	_tmp0_ = self->priv->m_candidate_panel;
+	candidate_panel_set_preedit_text (_tmp0_, NULL, (guint) 0);
+}
+
+
+static void panel_real_update_auxiliary_text (IBusPanelService* base, IBusText* text, gboolean visible) {
+	Panel * self;
+	IBusText* _tmp0_ = NULL;
+	gboolean _tmp1_;
+	CandidatePanel* _tmp3_;
+	IBusText* _tmp4_;
+	self = (Panel*) base;
+	g_return_if_fail (text != NULL);
+	_tmp1_ = visible;
+	if (_tmp1_) {
+		IBusText* _tmp2_;
+		_tmp2_ = text;
+		_tmp0_ = _tmp2_;
+	} else {
+		_tmp0_ = NULL;
+	}
+	_tmp3_ = self->priv->m_candidate_panel;
+	_tmp4_ = _tmp0_;
+	candidate_panel_set_auxiliary_text (_tmp3_, _tmp4_);
+}
+
+
+static void panel_real_hide_auxiliary_text (IBusPanelService* base) {
+	Panel * self;
+	CandidatePanel* _tmp0_;
+	self = (Panel*) base;
+	_tmp0_ = self->priv->m_candidate_panel;
+	candidate_panel_set_auxiliary_text (_tmp0_, NULL);
+}
+
+
+static void panel_real_update_lookup_table (IBusPanelService* base, IBusLookupTable* table, gboolean visible) {
+	Panel * self;
+	IBusLookupTable* _tmp0_ = NULL;
+	gboolean _tmp1_;
+	CandidatePanel* _tmp3_;
+	IBusLookupTable* _tmp4_;
+	self = (Panel*) base;
+	g_return_if_fail (table != NULL);
+	_tmp1_ = visible;
+	if (_tmp1_) {
+		IBusLookupTable* _tmp2_;
+		_tmp2_ = table;
+		_tmp0_ = _tmp2_;
+	} else {
+		_tmp0_ = NULL;
+	}
+	_tmp3_ = self->priv->m_candidate_panel;
+	_tmp4_ = _tmp0_;
+	candidate_panel_set_lookup_table (_tmp3_, _tmp4_);
+}
+
+
+static void panel_real_hide_lookup_table (IBusPanelService* base) {
+	Panel * self;
+	CandidatePanel* _tmp0_;
+	self = (Panel*) base;
+	_tmp0_ = self->priv->m_candidate_panel;
+	candidate_panel_set_lookup_table (_tmp0_, NULL);
+}
+
+
+static gchar string_get (const gchar* self, glong index) {
+	gchar result = '\0';
+	glong _tmp0_;
+	gchar _tmp1_;
+	g_return_val_if_fail (self != NULL, '\0');
+	_tmp0_ = index;
+	_tmp1_ = ((gchar*) self)[_tmp0_];
+	result = _tmp1_;
+	return result;
+}
+
+
+static void panel_real_state_changed (IBusPanelService* base) {
+	Panel * self;
+	gchar* _tmp0_;
+	gchar* icon_name;
+	IBusBus* _tmp1_;
+	IBusEngineDesc* _tmp2_ = NULL;
+	IBusEngineDesc* _tmp3_;
+	IBusEngineDesc* engine;
+	IBusEngineDesc* _tmp4_;
+	const gchar* _tmp8_;
+	gchar _tmp9_ = '\0';
+	self = (Panel*) base;
+	_tmp0_ = g_strdup ("ibus-keyboard");
+	icon_name = _tmp0_;
+	_tmp1_ = self->priv->m_bus;
+	_tmp2_ = ibus_bus_get_global_engine (_tmp1_);
+	_tmp3_ = _g_object_ref0 (_tmp2_);
+	engine = _tmp3_;
+	_tmp4_ = engine;
+	if (_tmp4_ != NULL) {
+		IBusEngineDesc* _tmp5_;
+		const gchar* _tmp6_ = NULL;
+		gchar* _tmp7_;
+		_tmp5_ = engine;
+		_tmp6_ = ibus_engine_desc_get_icon (_tmp5_);
+		_tmp7_ = g_strdup (_tmp6_);
+		_g_free0 (icon_name);
+		icon_name = _tmp7_;
+	}
+	_tmp8_ = icon_name;
+	_tmp9_ = string_get (_tmp8_, (glong) 0);
+	if (_tmp9_ == '/') {
+		GtkStatusIcon* _tmp10_;
+		const gchar* _tmp11_;
+		_tmp10_ = self->priv->m_status_icon;
+		_tmp11_ = icon_name;
+		gtk_status_icon_set_from_file (_tmp10_, _tmp11_);
+	} else {
+		GtkStatusIcon* _tmp12_;
+		const gchar* _tmp13_;
+		_tmp12_ = self->priv->m_status_icon;
+		_tmp13_ = icon_name;
+		gtk_status_icon_set_from_icon_name (_tmp12_, _tmp13_);
+	}
+	_g_object_unref0 (engine);
+	_g_free0 (icon_name);
+}
+
+
+static void panel_class_init (PanelClass * klass) {
+	panel_parent_class = g_type_class_peek_parent (klass);
+	g_type_class_add_private (klass, sizeof (PanelPrivate));
+	IBUS_PANEL_SERVICE_CLASS (klass)->set_cursor_location = panel_real_set_cursor_location;
+	IBUS_PANEL_SERVICE_CLASS (klass)->focus_in = panel_real_focus_in;
+	IBUS_PANEL_SERVICE_CLASS (klass)->focus_out = panel_real_focus_out;
+	IBUS_PANEL_SERVICE_CLASS (klass)->register_properties = panel_real_register_properties;
+	IBUS_PANEL_SERVICE_CLASS (klass)->update_property = panel_real_update_property;
+	IBUS_PANEL_SERVICE_CLASS (klass)->update_preedit_text = panel_real_update_preedit_text;
+	IBUS_PANEL_SERVICE_CLASS (klass)->hide_preedit_text = panel_real_hide_preedit_text;
+	IBUS_PANEL_SERVICE_CLASS (klass)->update_auxiliary_text = panel_real_update_auxiliary_text;
+	IBUS_PANEL_SERVICE_CLASS (klass)->hide_auxiliary_text = panel_real_hide_auxiliary_text;
+	IBUS_PANEL_SERVICE_CLASS (klass)->update_lookup_table = panel_real_update_lookup_table;
+	IBUS_PANEL_SERVICE_CLASS (klass)->hide_lookup_table = panel_real_hide_lookup_table;
+	IBUS_PANEL_SERVICE_CLASS (klass)->state_changed = panel_real_state_changed;
+	G_OBJECT_CLASS (klass)->finalize = panel_finalize;
+}
+
+
+static void panel_instance_init (Panel * self) {
+	IBusEngineDesc** _tmp0_ = NULL;
+	gchar** _tmp1_ = NULL;
+	gchar** _tmp2_ = NULL;
+	gchar** _tmp3_ = NULL;
+	self->priv = PANEL_GET_PRIVATE (self);
+	_tmp0_ = g_new0 (IBusEngineDesc*, 0 + 1);
+	self->priv->m_engines = _tmp0_;
+	self->priv->m_engines_length1 = 0;
+	self->priv->_m_engines_size_ = self->priv->m_engines_length1;
+	self->priv->m_setup_pid = (GPid) 0;
+	self->priv->m_gkbdlayout = NULL;
+	self->priv->m_xkblayout = NULL;
+	_tmp1_ = g_new0 (gchar*, 0 + 1);
+	self->priv->m_layouts = _tmp1_;
+	self->priv->m_layouts_length1 = 0;
+	self->priv->_m_layouts_size_ = self->priv->m_layouts_length1;
+	_tmp2_ = g_new0 (gchar*, 0 + 1);
+	self->priv->m_variants = _tmp2_;
+	self->priv->m_variants_length1 = 0;
+	self->priv->_m_variants_size_ = self->priv->m_variants_length1;
+	self->priv->m_fallback_lock_id = -1;
+	self->priv->m_changed_xkb_option = FALSE;
+	_tmp3_ = g_new0 (gchar*, 0 + 1);
+	self->priv->ACCELERATOR_IME_HOTKEYS = _tmp3_;
+	self->priv->ACCELERATOR_IME_HOTKEYS_length1 = 0;
+	self->priv->_ACCELERATOR_IME_HOTKEYS_size_ = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+}
+
+
+static void panel_finalize (GObject* obj) {
+	Panel * self;
+	KeybindingManager* _tmp0_ = NULL;
+	KeybindingManager* keybinding_manager;
+	gchar** _tmp1_;
+	gint _tmp1__length1;
+	gboolean _tmp7_ = FALSE;
+	gboolean _tmp9_;
+	self = PANEL (obj);
+	_tmp0_ = keybinding_manager_get_instance ();
+	keybinding_manager = _tmp0_;
+	_tmp1_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+	_tmp1__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+	{
+		gchar** keybinding_collection = NULL;
+		gint keybinding_collection_length1 = 0;
+		gint _keybinding_collection_size_ = 0;
+		gint keybinding_it = 0;
+		keybinding_collection = _tmp1_;
+		keybinding_collection_length1 = _tmp1__length1;
+		for (keybinding_it = 0; keybinding_it < _tmp1__length1; keybinding_it = keybinding_it + 1) {
+			gchar* _tmp2_;
+			gchar* keybinding = NULL;
+			_tmp2_ = g_strdup (keybinding_collection[keybinding_it]);
+			keybinding = _tmp2_;
+			{
+				KeybindingManager* _tmp3_;
+				const gchar* _tmp4_;
+				const gchar* _tmp5_;
+				_tmp3_ = keybinding_manager;
+				_tmp4_ = keybinding;
+				keybinding_manager_unbind (_tmp3_, _tmp4_);
+				_tmp5_ = keybinding;
+				if (g_strcmp0 (_tmp5_, PANEL_ACCELERATOR_SWITCH_IME_FOREWARD) == 0) {
+					KeybindingManager* _tmp6_;
+					_tmp6_ = keybinding_manager;
+					keybinding_manager_unbind (_tmp6_, PANEL_ACCELERATOR_SWITCH_IME_BACKWARD);
+				}
+				_g_free0 (keybinding);
+			}
+		}
+	}
+	if (HAVE_IBUS_GKBD) {
+		GkbdLayout* _tmp8_;
+		_tmp8_ = self->priv->m_gkbdlayout;
+		_tmp7_ = _tmp8_ != NULL;
+	} else {
+		_tmp7_ = FALSE;
+	}
+	_tmp9_ = _tmp7_;
+	if (_tmp9_) {
+		GkbdLayout* _tmp10_;
+		guint _tmp11_ = 0U;
+		GkbdLayout* _tmp12_;
+		_tmp10_ = self->priv->m_gkbdlayout;
+		g_signal_parse_name ("changed", TYPE_GKBD_LAYOUT, &_tmp11_, NULL, FALSE);
+		g_signal_handlers_disconnect_matched (_tmp10_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp11_, 0, NULL, (GCallback) _panel_gkbdlayout_changed_cb_gkbd_layout_changed, self);
+		_tmp12_ = self->priv->m_gkbdlayout;
+		gkbd_layout_stop_listen (_tmp12_);
+		_gkbd_layout_unref0 (self->priv->m_gkbdlayout);
+		self->priv->m_gkbdlayout = NULL;
+	}
+	_xkb_layout_unref0 (self->priv->m_xkblayout);
+	self->priv->m_xkblayout = NULL;
+	_g_object_unref0 (keybinding_manager);
+	_g_object_unref0 (self->priv->m_bus);
+	_g_object_unref0 (self->priv->m_config);
+	_g_object_unref0 (self->priv->m_status_icon);
+	_g_object_unref0 (self->priv->m_ime_menu);
+	_g_object_unref0 (self->priv->m_sys_menu);
+	self->priv->m_engines = (_vala_array_free (self->priv->m_engines, self->priv->m_engines_length1, (GDestroyNotify) g_object_unref), NULL);
+	_g_object_unref0 (self->priv->m_candidate_panel);
+	_g_object_unref0 (self->priv->m_switcher);
+	_property_manager_unref0 (self->priv->m_property_manager);
+	_g_object_unref0 (self->priv->m_about_dialog);
+	_gkbd_layout_unref0 (self->priv->m_gkbdlayout);
+	_xkb_layout_unref0 (self->priv->m_xkblayout);
+	self->priv->m_layouts = (_vala_array_free (self->priv->m_layouts, self->priv->m_layouts_length1, (GDestroyNotify) g_free), NULL);
+	self->priv->m_variants = (_vala_array_free (self->priv->m_variants, self->priv->m_variants_length1, (GDestroyNotify) g_free), NULL);
+	_g_timer_destroy0 (self->priv->m_changed_layout_timer);
+	self->priv->ACCELERATOR_IME_HOTKEYS = (_vala_array_free (self->priv->ACCELERATOR_IME_HOTKEYS, self->priv->ACCELERATOR_IME_HOTKEYS_length1, (GDestroyNotify) g_free), NULL);
+	G_OBJECT_CLASS (panel_parent_class)->finalize (obj);
+}
+
+
+GType panel_get_type (void) {
+	static volatile gsize panel_type_id__volatile = 0;
+	if (g_once_init_enter (&panel_type_id__volatile)) {
+		static const GTypeInfo g_define_type_info = { sizeof (PanelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panel_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Panel), 0, (GInstanceInitFunc) panel_instance_init, NULL };
+		GType panel_type_id;
+		panel_type_id = g_type_register_static (ibus_panel_service_get_type (), "Panel", &g_define_type_info, 0);
+		g_once_init_leave (&panel_type_id__volatile, panel_type_id);
+	}
+	return panel_type_id__volatile;
+}
+
+
+static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
+	if ((array != NULL) && (destroy_func != NULL)) {
+		int i;
+		for (i = 0; i < array_length; i = i + 1) {
+			if (((gpointer*) array)[i] != NULL) {
+				destroy_func (((gpointer*) array)[i]);
+			}
+		}
+	}
+}
+
+
+static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
+	_vala_array_destroy (array, array_length, destroy_func);
+	g_free (array);
+}
+
+
+static gint _vala_array_length (gpointer array) {
+	int length;
+	length = 0;
+	if (array) {
+		while (((gpointer*) array)[length]) {
+			length++;
+		}
+	}
+	return length;
+}
+
+
+
--- ibus/ui/gtk3/panel.c.orig	2012-03-09 18:53:39.271243400 +0900
+++ ibus/ui/gtk3/panel.c	2012-03-09 18:54:51.594556206 +0900
@@ -29,7 +29,10 @@
 #include <gtk/gtk.h>
 #include <stdlib.h>
 #include <string.h>
+#include <locale.h>
 #include <gdk/gdk.h>
+#include <float.h>
+#include <math.h>
 #include <signal.h>
 #include <sys/types.h>
 #include <glib/gi18n-lib.h>
@@ -76,6 +79,26 @@ typedef struct _SwitcherClass SwitcherCl
 typedef struct _PropertyManager PropertyManager;
 typedef struct _PropertyManagerClass PropertyManagerClass;
 
+#define TYPE_GKBD_LAYOUT (gkbd_layout_get_type ())
+#define GKBD_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GKBD_LAYOUT, GkbdLayout))
+#define GKBD_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GKBD_LAYOUT, GkbdLayoutClass))
+#define IS_GKBD_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GKBD_LAYOUT))
+#define IS_GKBD_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GKBD_LAYOUT))
+#define GKBD_LAYOUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GKBD_LAYOUT, GkbdLayoutClass))
+
+typedef struct _GkbdLayout GkbdLayout;
+typedef struct _GkbdLayoutClass GkbdLayoutClass;
+
+#define TYPE_XKB_LAYOUT (xkb_layout_get_type ())
+#define XKB_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XKB_LAYOUT, XKBLayout))
+#define XKB_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XKB_LAYOUT, XKBLayoutClass))
+#define IS_XKB_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XKB_LAYOUT))
+#define IS_XKB_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XKB_LAYOUT))
+#define XKB_LAYOUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XKB_LAYOUT, XKBLayoutClass))
+
+typedef struct _XKBLayout XKBLayout;
+typedef struct _XKBLayoutClass XKBLayoutClass;
+
 #define TYPE_KEYBINDING_MANAGER (keybinding_manager_get_type ())
 #define KEYBINDING_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEYBINDING_MANAGER, KeybindingManager))
 #define KEYBINDING_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEYBINDING_MANAGER, KeybindingManagerClass))
@@ -85,10 +108,14 @@ typedef struct _PropertyManagerClass Pro
 
 typedef struct _KeybindingManager KeybindingManager;
 typedef struct _KeybindingManagerClass KeybindingManagerClass;
+#define _g_free0(var) (var = (g_free (var), NULL))
+#define _gkbd_layout_unref0(var) ((var == NULL) ? NULL : (var = (gkbd_layout_unref (var), NULL)))
+#define _xkb_layout_unref0(var) ((var == NULL) ? NULL : (var = (xkb_layout_unref (var), NULL)))
 #define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
 #define _property_manager_unref0(var) ((var == NULL) ? NULL : (var = (property_manager_unref (var), NULL)))
+#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
 #define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
+#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))
 #define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
 typedef struct _Block4Data Block4Data;
 
@@ -125,6 +152,20 @@ struct _PanelPrivate {
 	PropertyManager* m_property_manager;
 	GPid m_setup_pid;
 	GtkAboutDialog* m_about_dialog;
+	GkbdLayout* m_gkbdlayout;
+	XKBLayout* m_xkblayout;
+	gchar** m_layouts;
+	gint m_layouts_length1;
+	gint _m_layouts_size_;
+	gchar** m_variants;
+	gint m_variants_length1;
+	gint _m_variants_size_;
+	gint m_fallback_lock_id;
+	gboolean m_changed_xkb_option;
+	GTimer* m_changed_layout_timer;
+	gchar** ACCELERATOR_IME_HOTKEYS;
+	gint ACCELERATOR_IME_HOTKEYS_length1;
+	gint _ACCELERATOR_IME_HOTKEYS_size_;
 };
 
 typedef void (*KeybindingManagerKeybindingHandlerFunc) (GdkEvent* event, void* user_data);
@@ -147,6 +188,20 @@ void value_set_property_manager (GValue*
 void value_take_property_manager (GValue* value, gpointer v_object);
 gpointer value_get_property_manager (const GValue* value);
 GType property_manager_get_type (void) G_GNUC_CONST;
+gpointer gkbd_layout_ref (gpointer instance);
+void gkbd_layout_unref (gpointer instance);
+GParamSpec* param_spec_gkbd_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
+void value_set_gkbd_layout (GValue* value, gpointer v_object);
+void value_take_gkbd_layout (GValue* value, gpointer v_object);
+gpointer value_get_gkbd_layout (const GValue* value);
+GType gkbd_layout_get_type (void) G_GNUC_CONST;
+gpointer xkb_layout_ref (gpointer instance);
+void xkb_layout_unref (gpointer instance);
+GParamSpec* param_spec_xkb_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
+void value_set_xkb_layout (GValue* value, gpointer v_object);
+void value_take_xkb_layout (GValue* value, gpointer v_object);
+gpointer value_get_xkb_layout (const GValue* value);
+GType xkb_layout_get_type (void) G_GNUC_CONST;
 #define PANEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANEL, PanelPrivate))
 enum  {
 	PANEL_DUMMY_PROPERTY
@@ -156,6 +211,9 @@ KeybindingManager* keybinding_manager_ge
 void keybinding_manager_unbind (KeybindingManager* self, const gchar* accelerator);
 #define PANEL_ACCELERATOR_SWITCH_IME_FOREWARD "<Control>space"
 #define PANEL_ACCELERATOR_SWITCH_IME_BACKWARD "<Control><Shift>space"
+static void panel_gkbdlayout_changed_cb (Panel* self);
+static void _panel_gkbdlayout_changed_cb_gkbd_layout_changed (GkbdLayout* _sender, gpointer self);
+void gkbd_layout_stop_listen (GkbdLayout* self);
 Panel* panel_new (IBusBus* bus);
 Panel* panel_construct (GType object_type, IBusBus* bus);
 static void panel_status_icon_popup_menu_cb (Panel* self, GtkStatusIcon* status_icon, guint button, guint activate_time);
@@ -170,31 +228,58 @@ static void __lambda24_ (Panel* self, Ca
 static void ___lambda24__candidate_panel_page_down (CandidatePanel* _sender, gpointer self);
 Switcher* switcher_new (void);
 Switcher* switcher_construct (GType object_type);
-gboolean keybinding_manager_bind (KeybindingManager* self, const gchar* accelerator, KeybindingManagerKeybindingHandlerFunc handler, void* handler_target);
-static void __lambda25_ (Panel* self, GdkEvent* e);
-static void panel_handle_engine_switch (Panel* self, GdkEvent* event, gboolean revert);
-static void ___lambda25__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self);
-static void __lambda26_ (Panel* self, GdkEvent* e);
-static void ___lambda26__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self);
 PropertyManager* property_manager_new (void);
 PropertyManager* property_manager_construct (GType object_type);
-static void __lambda27_ (Panel* self, const gchar* k, gint s);
-static void ___lambda27__property_manager_property_activate (PropertyManager* _sender, const gchar* key, gint state, gpointer self);
+static void __lambda25_ (Panel* self, const gchar* k, gint s);
+static void ___lambda25__property_manager_property_activate (PropertyManager* _sender, const gchar* key, gint state, gpointer self);
+static void panel_set_keybinding (Panel* self);
+static void _vala_array_add9 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add11 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add12 (gchar*** array, int* length, int* size, gchar* value);
+gboolean keybinding_manager_bind (KeybindingManager* self, const gchar* accelerator, KeybindingManagerKeybindingHandlerFunc handler, void* handler_target);
+static void ____lambda26_ (Panel* self, GdkEvent* e);
+static void panel_handle_engine_switch (Panel* self, GdkEvent* event, gboolean revert);
+static void _____lambda26__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self);
+static void _____lambda27_ (Panel* self, GdkEvent* e);
+static void ______lambda27__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self);
 void panel_set_config (Panel* self, IBusConfig* config);
 static void panel_config_value_changed_cb (Panel* self, IBusConfig* config, const gchar* section, const gchar* name, GVariant* variant);
 static void _panel_config_value_changed_cb_ibus_config_value_changed (IBusConfig* _sender, const gchar* section, const gchar* name, GVariant* value, gpointer self);
+static void panel_init_engines_order (Panel* self);
 static void panel_update_engines (Panel* self, GVariant* var_engines, GVariant* var_order);
+void gkbd_layout_lock_group (GkbdLayout* self, gint id);
+void xkb_layout_reset_layout (XKBLayout* self);
+static void panel_update_xkb_engines (Panel* self);
+static void panel_init_gkbd (Panel* self);
+GkbdLayout* gkbd_layout_new (void);
+GkbdLayout* gkbd_layout_construct (GType object_type);
+void gkbd_layout_start_listen (GkbdLayout* self);
+XKBLayout* xkb_layout_new (IBusConfig* config);
+XKBLayout* xkb_layout_construct (GType object_type, IBusConfig* config);
+gchar* xkb_layout_get_layout (XKBLayout* self);
+gchar* xkb_layout_get_variant (XKBLayout* self);
+static void _g_free0_ (gpointer var);
+static void _g_list_free__g_free0_ (GList* self);
+static void _vala_array_add13 (gchar*** array, int* length, int* size, gchar* value);
+static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
+static void _vala_array_add14 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add15 (gchar*** array, int* length, int* size, gchar* value);
+static void panel_set_xkb_group_layout (Panel* self, const gchar* layout);
+gint* xkb_layout_set_layout (XKBLayout* self, const gchar* _layout, const gchar* _variant, const gchar* _option, int* result_length1);
+static gboolean panel_set_gkbd_layout (Panel* self, const gchar* layout);
+gchar** gkbd_layout_get_group_names (GkbdLayout* self, int* result_length1);
+static void panel_set_layout (Panel* self, const gchar* layout);
 static void panel_switch_engine (Panel* self, gint i, gboolean force);
-static void _vala_array_add9 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add16 (gchar*** array, int* length, int* size, gchar* value);
 guint keybinding_manager_get_primary_modifier (guint binding_mask);
 gboolean keybinding_manager_primary_modifier_still_pressed (GdkEvent* event, guint primary_modifier);
 gint switcher_run (Switcher* self, GdkEvent* event, IBusEngineDesc** engines, int engines_length1, gint index);
-static gchar** _vala_array_dup2 (gchar** self, int length);
-static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
-static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value);
-static void _vala_array_add11 (gchar*** array, int* length, int* size, gchar* value);
-static IBusEngineDesc** _vala_array_dup3 (IBusEngineDesc** self, int length);
-static IBusEngineDesc** _vala_array_dup4 (IBusEngineDesc** self, int length);
+static gchar** _vala_array_dup4 (gchar** self, int length);
+static void _vala_array_add17 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add18 (gchar*** array, int* length, int* size, gchar* value);
+static IBusEngineDesc** _vala_array_dup5 (IBusEngineDesc** self, int length);
+static IBusEngineDesc** _vala_array_dup6 (IBusEngineDesc** self, int length);
 static void panel_show_setup_dialog (Panel* self);
 static void __lambda18_ (Panel* self, GPid pid, gint state);
 static void ___lambda18__gchild_watch_func (GPid pid, gint status, gpointer self);
@@ -240,6 +325,11 @@ static void _vala_array_free (gpointer a
 static gint _vala_array_length (gpointer array);
 
 
+static void _panel_gkbdlayout_changed_cb_gkbd_layout_changed (GkbdLayout* _sender, gpointer self) {
+	panel_gkbdlayout_changed_cb (self);
+}
+
+
 static gpointer _g_object_ref0 (gpointer self) {
 	return self ? g_object_ref (self) : NULL;
 }
@@ -277,33 +367,7 @@ static void ___lambda24__candidate_panel
 }
 
 
-static void __lambda25_ (Panel* self, GdkEvent* e) {
-	GdkEvent* _tmp0_;
-	g_return_if_fail (e != NULL);
-	_tmp0_ = e;
-	panel_handle_engine_switch (self, _tmp0_, FALSE);
-}
-
-
-static void ___lambda25__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self) {
-	__lambda25_ (self, event);
-}
-
-
-static void __lambda26_ (Panel* self, GdkEvent* e) {
-	GdkEvent* _tmp0_;
-	g_return_if_fail (e != NULL);
-	_tmp0_ = e;
-	panel_handle_engine_switch (self, _tmp0_, TRUE);
-}
-
-
-static void ___lambda26__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self) {
-	__lambda26_ (self, event);
-}
-
-
-static void __lambda27_ (Panel* self, const gchar* k, gint s) {
+static void __lambda25_ (Panel* self, const gchar* k, gint s) {
 	const gchar* _tmp0_;
 	gint _tmp1_;
 	g_return_if_fail (k != NULL);
@@ -313,8 +377,8 @@ static void __lambda27_ (Panel* self, co
 }
 
 
-static void ___lambda27__property_manager_property_activate (PropertyManager* _sender, const gchar* key, gint state, gpointer self) {
-	__lambda27_ (self, key, state);
+static void ___lambda25__property_manager_property_activate (PropertyManager* _sender, const gchar* key, gint state, gpointer self) {
+	__lambda25_ (self, key, state);
 }
 
 
@@ -338,10 +402,8 @@ Panel* panel_construct (GType object_typ
 	CandidatePanel* _tmp15_;
 	Switcher* _tmp16_;
 	Switcher* _tmp17_;
-	KeybindingManager* _tmp18_ = NULL;
-	KeybindingManager* keybinding_manager;
+	PropertyManager* _tmp18_;
 	PropertyManager* _tmp19_;
-	PropertyManager* _tmp20_;
 	g_return_val_if_fail (bus != NULL, NULL);
 	_tmp0_ = bus;
 	_tmp1_ = ibus_bus_is_connected (_tmp0_);
@@ -378,17 +440,12 @@ Panel* panel_construct (GType object_typ
 	_tmp17_ = g_object_ref_sink (_tmp16_);
 	_g_object_unref0 (self->priv->m_switcher);
 	self->priv->m_switcher = _tmp17_;
-	_tmp18_ = keybinding_manager_get_instance ();
-	keybinding_manager = _tmp18_;
-	keybinding_manager_bind (keybinding_manager, PANEL_ACCELERATOR_SWITCH_IME_FOREWARD, ___lambda25__keybinding_manager_keybinding_handler_func, self);
-	keybinding_manager_bind (keybinding_manager, PANEL_ACCELERATOR_SWITCH_IME_BACKWARD, ___lambda26__keybinding_manager_keybinding_handler_func, self);
-	_tmp19_ = property_manager_new ();
+	_tmp18_ = property_manager_new ();
 	_property_manager_unref0 (self->priv->m_property_manager);
-	self->priv->m_property_manager = _tmp19_;
-	_tmp20_ = self->priv->m_property_manager;
-	g_signal_connect_object (_tmp20_, "property-activate", (GCallback) ___lambda27__property_manager_property_activate, self, 0);
+	self->priv->m_property_manager = _tmp18_;
+	_tmp19_ = self->priv->m_property_manager;
+	g_signal_connect_object (_tmp19_, "property-activate", (GCallback) ___lambda25__property_manager_property_activate, self, 0);
 	g_signal_emit_by_name ((IBusPanelService*) self, "state-changed");
-	_g_object_unref0 (keybinding_manager);
 	return self;
 }
 
@@ -398,6 +455,321 @@ Panel* panel_new (IBusBus* bus) {
 }
 
 
+static void _vala_array_add9 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static gchar* string_slice (const gchar* self, glong start, glong end) {
+	gchar* result = NULL;
+	gint _tmp0_;
+	gint _tmp1_;
+	glong string_length;
+	glong _tmp2_;
+	glong _tmp5_;
+	gboolean _tmp8_ = FALSE;
+	glong _tmp9_;
+	gboolean _tmp12_;
+	gboolean _tmp13_ = FALSE;
+	glong _tmp14_;
+	gboolean _tmp17_;
+	glong _tmp18_;
+	glong _tmp19_;
+	glong _tmp20_;
+	glong _tmp21_;
+	glong _tmp22_;
+	gchar* _tmp23_ = NULL;
+	g_return_val_if_fail (self != NULL, NULL);
+	_tmp0_ = strlen (self);
+	_tmp1_ = _tmp0_;
+	string_length = (glong) _tmp1_;
+	_tmp2_ = start;
+	if (_tmp2_ < ((glong) 0)) {
+		glong _tmp3_;
+		glong _tmp4_;
+		_tmp3_ = string_length;
+		_tmp4_ = start;
+		start = _tmp3_ + _tmp4_;
+	}
+	_tmp5_ = end;
+	if (_tmp5_ < ((glong) 0)) {
+		glong _tmp6_;
+		glong _tmp7_;
+		_tmp6_ = string_length;
+		_tmp7_ = end;
+		end = _tmp6_ + _tmp7_;
+	}
+	_tmp9_ = start;
+	if (_tmp9_ >= ((glong) 0)) {
+		glong _tmp10_;
+		glong _tmp11_;
+		_tmp10_ = start;
+		_tmp11_ = string_length;
+		_tmp8_ = _tmp10_ <= _tmp11_;
+	} else {
+		_tmp8_ = FALSE;
+	}
+	_tmp12_ = _tmp8_;
+	g_return_val_if_fail (_tmp12_, NULL);
+	_tmp14_ = end;
+	if (_tmp14_ >= ((glong) 0)) {
+		glong _tmp15_;
+		glong _tmp16_;
+		_tmp15_ = end;
+		_tmp16_ = string_length;
+		_tmp13_ = _tmp15_ <= _tmp16_;
+	} else {
+		_tmp13_ = FALSE;
+	}
+	_tmp17_ = _tmp13_;
+	g_return_val_if_fail (_tmp17_, NULL);
+	_tmp18_ = start;
+	_tmp19_ = end;
+	g_return_val_if_fail (_tmp18_ <= _tmp19_, NULL);
+	_tmp20_ = start;
+	_tmp21_ = end;
+	_tmp22_ = start;
+	_tmp23_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) (_tmp21_ - _tmp22_));
+	result = _tmp23_;
+	return result;
+}
+
+
+static void _vala_array_add11 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add12 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void ____lambda26_ (Panel* self, GdkEvent* e) {
+	GdkEvent* _tmp0_;
+	g_return_if_fail (e != NULL);
+	_tmp0_ = e;
+	panel_handle_engine_switch (self, _tmp0_, FALSE);
+}
+
+
+static void _____lambda26__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self) {
+	____lambda26_ (self, event);
+}
+
+
+static void _____lambda27_ (Panel* self, GdkEvent* e) {
+	GdkEvent* _tmp0_;
+	g_return_if_fail (e != NULL);
+	_tmp0_ = e;
+	panel_handle_engine_switch (self, _tmp0_, TRUE);
+}
+
+
+static void ______lambda27__keybinding_manager_keybinding_handler_func (GdkEvent* event, gpointer self) {
+	_____lambda27_ (self, event);
+}
+
+
+static void panel_set_keybinding (Panel* self) {
+	const gchar* _tmp0_ = NULL;
+	gchar* _tmp1_;
+	gchar* locale;
+	const gchar* _tmp2_;
+	gchar** _tmp4_;
+	gint _tmp4__length1;
+	gchar* _tmp5_;
+	IBusConfig* _tmp6_;
+	gboolean _tmp23_ = FALSE;
+	gchar** _tmp24_;
+	gint _tmp24__length1;
+	gboolean _tmp27_;
+	KeybindingManager* _tmp36_ = NULL;
+	KeybindingManager* keybinding_manager;
+	gchar** _tmp37_;
+	gint _tmp37__length1;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = setlocale (LC_ALL, NULL);
+	_tmp1_ = g_strdup (_tmp0_);
+	locale = _tmp1_;
+	_tmp2_ = locale;
+	if (_tmp2_ == NULL) {
+		gchar* _tmp3_;
+		_tmp3_ = g_strdup ("C");
+		_g_free0 (locale);
+		locale = _tmp3_;
+	}
+	_tmp4_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+	_tmp4__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+	_tmp5_ = g_strdup (PANEL_ACCELERATOR_SWITCH_IME_FOREWARD);
+	_vala_array_add9 (&self->priv->ACCELERATOR_IME_HOTKEYS, &self->priv->ACCELERATOR_IME_HOTKEYS_length1, &self->priv->_ACCELERATOR_IME_HOTKEYS_size_, _tmp5_);
+	_tmp6_ = self->priv->m_config;
+	if (_tmp6_ != NULL) {
+		IBusConfig* _tmp7_;
+		GVariant* _tmp8_ = NULL;
+		GVariant* variant;
+		GVariant* _tmp9_;
+		_tmp7_ = self->priv->m_config;
+		_tmp8_ = ibus_config_get_value (_tmp7_, "general/hotkey", "trigger_accel");
+		variant = _tmp8_;
+		_tmp9_ = variant;
+		if (_tmp9_ != NULL) {
+			gchar** _tmp10_ = NULL;
+			_tmp10_ = g_new0 (gchar*, 0 + 1);
+			self->priv->ACCELERATOR_IME_HOTKEYS = (_vala_array_free (self->priv->ACCELERATOR_IME_HOTKEYS, self->priv->ACCELERATOR_IME_HOTKEYS_length1, (GDestroyNotify) g_free), NULL);
+			self->priv->ACCELERATOR_IME_HOTKEYS = _tmp10_;
+			self->priv->ACCELERATOR_IME_HOTKEYS_length1 = 0;
+			self->priv->_ACCELERATOR_IME_HOTKEYS_size_ = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+			{
+				gint i;
+				i = 0;
+				{
+					gboolean _tmp11_;
+					_tmp11_ = TRUE;
+					while (TRUE) {
+						gboolean _tmp12_;
+						gint _tmp14_;
+						GVariant* _tmp15_;
+						gsize _tmp16_ = 0UL;
+						gchar** _tmp17_;
+						gint _tmp17__length1;
+						GVariant* _tmp18_;
+						gint _tmp19_;
+						GVariant* _tmp20_ = NULL;
+						GVariant* _tmp21_;
+						gchar* _tmp22_ = NULL;
+						_tmp12_ = _tmp11_;
+						if (!_tmp12_) {
+							gint _tmp13_;
+							_tmp13_ = i;
+							i = _tmp13_ + 1;
+						}
+						_tmp11_ = FALSE;
+						_tmp14_ = i;
+						_tmp15_ = variant;
+						_tmp16_ = g_variant_n_children (_tmp15_);
+						if (!(((gsize) _tmp14_) < _tmp16_)) {
+							break;
+						}
+						_tmp17_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+						_tmp17__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+						_tmp18_ = variant;
+						_tmp19_ = i;
+						_tmp20_ = g_variant_get_child_value (_tmp18_, (gsize) _tmp19_);
+						_tmp21_ = _tmp20_;
+						_tmp22_ = g_variant_dup_string (_tmp21_, NULL);
+						_vala_array_add10 (&self->priv->ACCELERATOR_IME_HOTKEYS, &self->priv->ACCELERATOR_IME_HOTKEYS_length1, &self->priv->_ACCELERATOR_IME_HOTKEYS_size_, _tmp22_);
+						_g_variant_unref0 (_tmp21_);
+					}
+				}
+			}
+		}
+		_g_variant_unref0 (variant);
+	}
+	_tmp24_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+	_tmp24__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+	if (_tmp24__length1 == 1) {
+		gchar** _tmp25_;
+		gint _tmp25__length1;
+		const gchar* _tmp26_;
+		_tmp25_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+		_tmp25__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+		_tmp26_ = _tmp25_[0];
+		_tmp23_ = g_strcmp0 (_tmp26_, PANEL_ACCELERATOR_SWITCH_IME_FOREWARD) == 0;
+	} else {
+		_tmp23_ = FALSE;
+	}
+	_tmp27_ = _tmp23_;
+	if (_tmp27_) {
+		const gchar* _tmp28_;
+		gchar* _tmp29_ = NULL;
+		gchar* _tmp30_;
+		gboolean _tmp31_;
+		_tmp28_ = locale;
+		_tmp29_ = string_slice (_tmp28_, (glong) 0, (glong) 2);
+		_tmp30_ = _tmp29_;
+		_tmp31_ = g_strcmp0 (_tmp30_, "ko") == 0;
+		_g_free0 (_tmp30_);
+		if (_tmp31_) {
+			gchar** _tmp32_;
+			gint _tmp32__length1;
+			gchar* _tmp33_;
+			gchar** _tmp34_;
+			gint _tmp34__length1;
+			gchar* _tmp35_;
+			_tmp32_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+			_tmp32__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+			_tmp33_ = g_strdup ("Hangul");
+			_vala_array_add11 (&self->priv->ACCELERATOR_IME_HOTKEYS, &self->priv->ACCELERATOR_IME_HOTKEYS_length1, &self->priv->_ACCELERATOR_IME_HOTKEYS_size_, _tmp33_);
+			_tmp34_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+			_tmp34__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+			_tmp35_ = g_strdup ("Alt_R");
+			_vala_array_add12 (&self->priv->ACCELERATOR_IME_HOTKEYS, &self->priv->ACCELERATOR_IME_HOTKEYS_length1, &self->priv->_ACCELERATOR_IME_HOTKEYS_size_, _tmp35_);
+		}
+	}
+	_tmp36_ = keybinding_manager_get_instance ();
+	keybinding_manager = _tmp36_;
+	_tmp37_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+	_tmp37__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+	{
+		gchar** keybinding_collection = NULL;
+		gint keybinding_collection_length1 = 0;
+		gint _keybinding_collection_size_ = 0;
+		gint keybinding_it = 0;
+		keybinding_collection = _tmp37_;
+		keybinding_collection_length1 = _tmp37__length1;
+		for (keybinding_it = 0; keybinding_it < _tmp37__length1; keybinding_it = keybinding_it + 1) {
+			gchar* _tmp38_;
+			gchar* keybinding = NULL;
+			_tmp38_ = g_strdup (keybinding_collection[keybinding_it]);
+			keybinding = _tmp38_;
+			{
+				KeybindingManager* _tmp39_;
+				const gchar* _tmp40_;
+				const gchar* _tmp41_;
+				_tmp39_ = keybinding_manager;
+				_tmp40_ = keybinding;
+				keybinding_manager_bind (_tmp39_, _tmp40_, _____lambda26__keybinding_manager_keybinding_handler_func, self);
+				_tmp41_ = keybinding;
+				if (g_strcmp0 (_tmp41_, PANEL_ACCELERATOR_SWITCH_IME_FOREWARD) == 0) {
+					KeybindingManager* _tmp42_;
+					_tmp42_ = keybinding_manager;
+					keybinding_manager_bind (_tmp42_, PANEL_ACCELERATOR_SWITCH_IME_BACKWARD, ______lambda27__keybinding_manager_keybinding_handler_func, self);
+				}
+				_g_free0 (keybinding);
+			}
+		}
+	}
+	_g_object_unref0 (keybinding_manager);
+	_g_free0 (locale);
+}
+
+
 static void _panel_config_value_changed_cb_ibus_config_value_changed (IBusConfig* _sender, const gchar* section, const gchar* name, GVariant* value, gpointer self) {
 	panel_config_value_changed_cb (self, _sender, section, name, value);
 }
@@ -424,6 +796,7 @@ void panel_set_config (Panel* self, IBus
 	_tmp4_ = _g_object_ref0 (_tmp3_);
 	_g_object_unref0 (self->priv->m_config);
 	self->priv->m_config = _tmp4_;
+	panel_set_keybinding (self);
 	_tmp5_ = self->priv->m_config;
 	if (_tmp5_ != NULL) {
 		IBusConfig* _tmp6_;
@@ -435,6 +808,7 @@ void panel_set_config (Panel* self, IBus
 		GVariant* _tmp12_;
 		_tmp6_ = self->priv->m_config;
 		g_signal_connect_object (_tmp6_, "value-changed", (GCallback) _panel_config_value_changed_cb_ibus_config_value_changed, self, 0);
+		panel_init_engines_order (self);
 		_tmp7_ = self->priv->m_config;
 		_tmp8_ = ibus_config_get_value (_tmp7_, "general", "preload_engines");
 		_tmp9_ = _tmp8_;
@@ -450,7 +824,786 @@ void panel_set_config (Panel* self, IBus
 }
 
 
-static void _vala_array_add9 (gchar*** array, int* length, int* size, gchar* value) {
+static void panel_gkbdlayout_changed_cb (Panel* self) {
+	GTimer* _tmp0_;
+	gdouble _tmp1_ = 0.0;
+	gdouble elapsed;
+	gboolean _tmp2_ = FALSE;
+	gdouble _tmp3_;
+	gboolean _tmp5_;
+	gint _tmp6_;
+	GTimer* _tmp10_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_changed_layout_timer;
+	_tmp1_ = g_timer_elapsed (_tmp0_, NULL);
+	elapsed = _tmp1_;
+	_tmp3_ = elapsed;
+	if (_tmp3_ < 1.0) {
+		gdouble _tmp4_;
+		_tmp4_ = elapsed;
+		_tmp2_ = _tmp4_ > 0.0;
+	} else {
+		_tmp2_ = FALSE;
+	}
+	_tmp5_ = _tmp2_;
+	if (_tmp5_) {
+		return;
+	}
+	_tmp6_ = self->priv->m_fallback_lock_id;
+	if (_tmp6_ != (-1)) {
+		GkbdLayout* _tmp7_;
+		gint _tmp8_;
+		_tmp7_ = self->priv->m_gkbdlayout;
+		_tmp8_ = self->priv->m_fallback_lock_id;
+		gkbd_layout_lock_group (_tmp7_, _tmp8_);
+		self->priv->m_fallback_lock_id = -1;
+	} else {
+		XKBLayout* _tmp9_;
+		_tmp9_ = self->priv->m_xkblayout;
+		xkb_layout_reset_layout (_tmp9_);
+	}
+	panel_update_xkb_engines (self);
+	_tmp10_ = self->priv->m_changed_layout_timer;
+	g_timer_reset (_tmp10_);
+}
+
+
+static void panel_init_gkbd (Panel* self) {
+	GkbdLayout* _tmp0_;
+	GkbdLayout* _tmp1_;
+	GTimer* _tmp2_;
+	GTimer* _tmp3_;
+	GkbdLayout* _tmp4_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = gkbd_layout_new ();
+	_gkbd_layout_unref0 (self->priv->m_gkbdlayout);
+	self->priv->m_gkbdlayout = _tmp0_;
+	_tmp1_ = self->priv->m_gkbdlayout;
+	g_signal_connect_object (_tmp1_, "changed", (GCallback) _panel_gkbdlayout_changed_cb_gkbd_layout_changed, self, 0);
+	_tmp2_ = g_timer_new ();
+	_g_timer_destroy0 (self->priv->m_changed_layout_timer);
+	self->priv->m_changed_layout_timer = _tmp2_;
+	_tmp3_ = self->priv->m_changed_layout_timer;
+	g_timer_start (_tmp3_);
+	_tmp4_ = self->priv->m_gkbdlayout;
+	gkbd_layout_start_listen (_tmp4_);
+}
+
+
+static void panel_init_engines_order (Panel* self) {
+	IBusConfig* _tmp0_;
+	IBusConfig* _tmp1_;
+	XKBLayout* _tmp2_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_config;
+	if (_tmp0_ == NULL) {
+		return;
+	}
+	_tmp1_ = self->priv->m_config;
+	_tmp2_ = xkb_layout_new (_tmp1_);
+	_xkb_layout_unref0 (self->priv->m_xkblayout);
+	self->priv->m_xkblayout = _tmp2_;
+	if (HAVE_IBUS_GKBD) {
+		panel_init_gkbd (self);
+	}
+	panel_update_xkb_engines (self);
+}
+
+
+static void _g_free0_ (gpointer var) {
+	var = (g_free (var), NULL);
+}
+
+
+static void _g_list_free__g_free0_ (GList* self) {
+	g_list_foreach (self, (GFunc) _g_free0_, NULL);
+	g_list_free (self);
+}
+
+
+static void _vala_array_add13 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
+	int i;
+	for (i = 0; i < stack_length; i++) {
+		if (g_strcmp0 (stack[i], needle) == 0) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+
+static void _vala_array_add14 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add15 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void panel_update_xkb_engines (Panel* self) {
+	XKBLayout* _tmp0_;
+	gchar* _tmp1_ = NULL;
+	gchar* var_layout;
+	XKBLayout* _tmp2_;
+	gchar* _tmp3_ = NULL;
+	gchar* var_variant;
+	const gchar* _tmp4_;
+	const gchar* _tmp5_;
+	gchar** _tmp6_;
+	gchar** _tmp7_ = NULL;
+	const gchar* _tmp8_;
+	gchar** _tmp9_;
+	gchar** _tmp10_ = NULL;
+	IBusXKBConfigRegistry* _tmp11_;
+	IBusXKBConfigRegistry* _tmp12_;
+	IBusXKBConfigRegistry* registry;
+	gchar** _tmp13_ = NULL;
+	gchar** var_xkb_engine_names;
+	gint var_xkb_engine_names_length1;
+	gint _var_xkb_engine_names_size_;
+	IBusConfig* _tmp65_;
+	GVariant* _tmp66_ = NULL;
+	GVariant* var_engines;
+	gchar** _tmp67_ = NULL;
+	gchar** engine_names;
+	gint engine_names_length1;
+	gint _engine_names_size_;
+	gboolean updated_engine_names;
+	GVariant* _tmp68_;
+	gchar** _tmp72_;
+	gint _tmp72__length1;
+	gboolean _tmp79_;
+	IBusConfig* _tmp84_;
+	GVariant* _tmp85_ = NULL;
+	GVariant* var_order;
+	gchar** _tmp86_ = NULL;
+	gchar** order_names;
+	gint order_names_length1;
+	gint _order_names_size_;
+	gboolean updated_order_names;
+	GVariant* _tmp87_;
+	gchar** _tmp91_;
+	gint _tmp91__length1;
+	gboolean _tmp98_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_xkblayout;
+	_tmp1_ = xkb_layout_get_layout (_tmp0_);
+	var_layout = _tmp1_;
+	_tmp2_ = self->priv->m_xkblayout;
+	_tmp3_ = xkb_layout_get_variant (_tmp2_);
+	var_variant = _tmp3_;
+	_tmp4_ = var_layout;
+	if (g_strcmp0 (_tmp4_, "") == 0) {
+		_g_free0 (var_variant);
+		_g_free0 (var_layout);
+		return;
+	}
+	_tmp5_ = var_layout;
+	_tmp7_ = _tmp6_ = g_strsplit (_tmp5_, ",", 0);
+	self->priv->m_layouts = (_vala_array_free (self->priv->m_layouts, self->priv->m_layouts_length1, (GDestroyNotify) g_free), NULL);
+	self->priv->m_layouts = _tmp7_;
+	self->priv->m_layouts_length1 = _vala_array_length (_tmp6_);
+	self->priv->_m_layouts_size_ = self->priv->m_layouts_length1;
+	_tmp8_ = var_variant;
+	_tmp10_ = _tmp9_ = g_strsplit (_tmp8_, ",", 0);
+	self->priv->m_variants = (_vala_array_free (self->priv->m_variants, self->priv->m_variants_length1, (GDestroyNotify) g_free), NULL);
+	self->priv->m_variants = _tmp10_;
+	self->priv->m_variants_length1 = _vala_array_length (_tmp9_);
+	self->priv->_m_variants_size_ = self->priv->m_variants_length1;
+	_tmp11_ = ibus_xkb_config_registry_new ();
+	_tmp12_ = g_object_ref_sink (_tmp11_);
+	registry = _tmp12_;
+	_tmp13_ = g_new0 (gchar*, 0 + 1);
+	var_xkb_engine_names = _tmp13_;
+	var_xkb_engine_names_length1 = 0;
+	_var_xkb_engine_names_size_ = var_xkb_engine_names_length1;
+	{
+		gint i;
+		i = 0;
+		{
+			gboolean _tmp14_;
+			_tmp14_ = TRUE;
+			while (TRUE) {
+				gboolean _tmp15_;
+				gint _tmp17_;
+				gchar** _tmp18_;
+				gint _tmp18__length1;
+				gchar** _tmp19_;
+				gint _tmp19__length1;
+				gint _tmp20_;
+				const gchar* _tmp21_;
+				gchar* _tmp22_;
+				gchar* name;
+				gchar* lang;
+				gboolean _tmp23_ = FALSE;
+				gint _tmp24_;
+				gchar** _tmp25_;
+				gint _tmp25__length1;
+				gboolean _tmp29_;
+				const gchar* _tmp50_;
+				gchar** _tmp61_;
+				gint _tmp61__length1;
+				const gchar* _tmp62_;
+				const gchar* _tmp63_;
+				gchar* _tmp64_ = NULL;
+				_tmp15_ = _tmp14_;
+				if (!_tmp15_) {
+					gint _tmp16_;
+					_tmp16_ = i;
+					i = _tmp16_ + 1;
+				}
+				_tmp14_ = FALSE;
+				_tmp17_ = i;
+				_tmp18_ = self->priv->m_layouts;
+				_tmp18__length1 = self->priv->m_layouts_length1;
+				if (!(_tmp17_ < _tmp18__length1)) {
+					break;
+				}
+				_tmp19_ = self->priv->m_layouts;
+				_tmp19__length1 = self->priv->m_layouts_length1;
+				_tmp20_ = i;
+				_tmp21_ = _tmp19_[_tmp20_];
+				_tmp22_ = g_strdup (_tmp21_);
+				name = _tmp22_;
+				lang = NULL;
+				_tmp24_ = i;
+				_tmp25_ = self->priv->m_variants;
+				_tmp25__length1 = self->priv->m_variants_length1;
+				if (_tmp24_ < _tmp25__length1) {
+					gchar** _tmp26_;
+					gint _tmp26__length1;
+					gint _tmp27_;
+					const gchar* _tmp28_;
+					_tmp26_ = self->priv->m_variants;
+					_tmp26__length1 = self->priv->m_variants_length1;
+					_tmp27_ = i;
+					_tmp28_ = _tmp26_[_tmp27_];
+					_tmp23_ = g_strcmp0 (_tmp28_, "") != 0;
+				} else {
+					_tmp23_ = FALSE;
+				}
+				_tmp29_ = _tmp23_;
+				if (_tmp29_) {
+					const gchar* _tmp30_;
+					gchar** _tmp31_;
+					gint _tmp31__length1;
+					gint _tmp32_;
+					const gchar* _tmp33_;
+					gchar* _tmp34_ = NULL;
+					const gchar* _tmp35_;
+					gchar** _tmp36_;
+					gint _tmp36__length1;
+					gint _tmp37_;
+					const gchar* _tmp38_;
+					gchar* _tmp39_ = NULL;
+					gchar* layout;
+					IBusXKBConfigRegistry* _tmp40_;
+					const gchar* _tmp41_;
+					GList* _tmp42_ = NULL;
+					GList* langs;
+					GList* _tmp43_;
+					guint _tmp44_ = 0U;
+					_tmp30_ = name;
+					_tmp31_ = self->priv->m_variants;
+					_tmp31__length1 = self->priv->m_variants_length1;
+					_tmp32_ = i;
+					_tmp33_ = _tmp31_[_tmp32_];
+					_tmp34_ = g_strdup_printf ("%s:%s", _tmp30_, _tmp33_);
+					_g_free0 (name);
+					name = _tmp34_;
+					_tmp35_ = name;
+					_tmp36_ = self->priv->m_variants;
+					_tmp36__length1 = self->priv->m_variants_length1;
+					_tmp37_ = i;
+					_tmp38_ = _tmp36_[_tmp37_];
+					_tmp39_ = g_strdup_printf ("%s(%s)", _tmp35_, _tmp38_);
+					layout = _tmp39_;
+					_tmp40_ = registry;
+					_tmp41_ = layout;
+					_tmp42_ = ibus_xkb_config_registry_layout_lang_get_langs (_tmp40_, _tmp41_);
+					langs = _tmp42_;
+					_tmp43_ = langs;
+					_tmp44_ = g_list_length (_tmp43_);
+					if (_tmp44_ != ((guint) 0)) {
+						GList* _tmp45_;
+						gconstpointer _tmp46_;
+						gchar* _tmp47_;
+						_tmp45_ = langs;
+						_tmp46_ = _tmp45_->data;
+						_tmp47_ = g_strdup ((const gchar*) _tmp46_);
+						_g_free0 (lang);
+						lang = _tmp47_;
+					}
+					__g_list_free__g_free0_0 (langs);
+					_g_free0 (layout);
+				} else {
+					const gchar* _tmp48_;
+					gchar* _tmp49_ = NULL;
+					_tmp48_ = name;
+					_tmp49_ = g_strdup_printf ("%s:", _tmp48_);
+					_g_free0 (name);
+					name = _tmp49_;
+				}
+				_tmp50_ = lang;
+				if (_tmp50_ == NULL) {
+					IBusXKBConfigRegistry* _tmp51_;
+					gchar** _tmp52_;
+					gint _tmp52__length1;
+					gint _tmp53_;
+					const gchar* _tmp54_;
+					GList* _tmp55_ = NULL;
+					GList* langs;
+					GList* _tmp56_;
+					guint _tmp57_ = 0U;
+					_tmp51_ = registry;
+					_tmp52_ = self->priv->m_layouts;
+					_tmp52__length1 = self->priv->m_layouts_length1;
+					_tmp53_ = i;
+					_tmp54_ = _tmp52_[_tmp53_];
+					_tmp55_ = ibus_xkb_config_registry_layout_lang_get_langs (_tmp51_, _tmp54_);
+					langs = _tmp55_;
+					_tmp56_ = langs;
+					_tmp57_ = g_list_length (_tmp56_);
+					if (_tmp57_ != ((guint) 0)) {
+						GList* _tmp58_;
+						gconstpointer _tmp59_;
+						gchar* _tmp60_;
+						_tmp58_ = langs;
+						_tmp59_ = _tmp58_->data;
+						_tmp60_ = g_strdup ((const gchar*) _tmp59_);
+						_g_free0 (lang);
+						lang = _tmp60_;
+					}
+					__g_list_free__g_free0_0 (langs);
+				}
+				_tmp61_ = var_xkb_engine_names;
+				_tmp61__length1 = var_xkb_engine_names_length1;
+				_tmp62_ = name;
+				_tmp63_ = lang;
+				_tmp64_ = g_strdup_printf ("%s:%s:%s", "xkb", _tmp62_, _tmp63_);
+				_vala_array_add13 (&var_xkb_engine_names, &var_xkb_engine_names_length1, &_var_xkb_engine_names_size_, _tmp64_);
+				_g_free0 (lang);
+				_g_free0 (name);
+			}
+		}
+	}
+	_tmp65_ = self->priv->m_config;
+	_tmp66_ = ibus_config_get_value (_tmp65_, "general", "preload_engines");
+	var_engines = _tmp66_;
+	_tmp67_ = g_new0 (gchar*, 0 + 1);
+	engine_names = _tmp67_;
+	engine_names_length1 = 0;
+	_engine_names_size_ = engine_names_length1;
+	updated_engine_names = FALSE;
+	_tmp68_ = var_engines;
+	if (_tmp68_ != NULL) {
+		GVariant* _tmp69_;
+		size_t _tmp70_;
+		gchar** _tmp71_ = NULL;
+		_tmp69_ = var_engines;
+		_tmp71_ = g_variant_dup_strv (_tmp69_, &_tmp70_);
+		engine_names = (_vala_array_free (engine_names, engine_names_length1, (GDestroyNotify) g_free), NULL);
+		engine_names = _tmp71_;
+		engine_names_length1 = _tmp70_;
+		_engine_names_size_ = engine_names_length1;
+	}
+	_tmp72_ = var_xkb_engine_names;
+	_tmp72__length1 = var_xkb_engine_names_length1;
+	{
+		gchar** name_collection = NULL;
+		gint name_collection_length1 = 0;
+		gint _name_collection_size_ = 0;
+		gint name_it = 0;
+		name_collection = _tmp72_;
+		name_collection_length1 = _tmp72__length1;
+		for (name_it = 0; name_it < _tmp72__length1; name_it = name_it + 1) {
+			gchar* _tmp73_;
+			gchar* name = NULL;
+			_tmp73_ = g_strdup (name_collection[name_it]);
+			name = _tmp73_;
+			{
+				const gchar* _tmp74_;
+				gchar** _tmp75_;
+				gint _tmp75__length1;
+				gchar** _tmp76_;
+				gint _tmp76__length1;
+				const gchar* _tmp77_;
+				gchar* _tmp78_;
+				_tmp74_ = name;
+				_tmp75_ = engine_names;
+				_tmp75__length1 = engine_names_length1;
+				if (_vala_string_array_contains (_tmp75_, _tmp75__length1, _tmp74_)) {
+					_g_free0 (name);
+					continue;
+				}
+				updated_engine_names = TRUE;
+				_tmp76_ = engine_names;
+				_tmp76__length1 = engine_names_length1;
+				_tmp77_ = name;
+				_tmp78_ = g_strdup (_tmp77_);
+				_vala_array_add14 (&engine_names, &engine_names_length1, &_engine_names_size_, _tmp78_);
+				_g_free0 (name);
+			}
+		}
+	}
+	_tmp79_ = updated_engine_names;
+	if (_tmp79_) {
+		IBusConfig* _tmp80_;
+		gchar** _tmp81_;
+		gint _tmp81__length1;
+		GVariant* _tmp82_;
+		GVariant* _tmp83_;
+		_tmp80_ = self->priv->m_config;
+		_tmp81_ = engine_names;
+		_tmp81__length1 = engine_names_length1;
+		_tmp82_ = g_variant_new_strv (_tmp81_, _tmp81__length1);
+		_tmp83_ = g_variant_ref_sink (_tmp82_);
+		ibus_config_set_value (_tmp80_, "general", "preload_engines", _tmp83_);
+		_g_variant_unref0 (_tmp83_);
+	}
+	_tmp84_ = self->priv->m_config;
+	_tmp85_ = ibus_config_get_value (_tmp84_, "general", "engines_order");
+	var_order = _tmp85_;
+	_tmp86_ = g_new0 (gchar*, 0 + 1);
+	order_names = _tmp86_;
+	order_names_length1 = 0;
+	_order_names_size_ = order_names_length1;
+	updated_order_names = FALSE;
+	_tmp87_ = var_order;
+	if (_tmp87_ != NULL) {
+		GVariant* _tmp88_;
+		size_t _tmp89_;
+		gchar** _tmp90_ = NULL;
+		_tmp88_ = var_order;
+		_tmp90_ = g_variant_dup_strv (_tmp88_, &_tmp89_);
+		order_names = (_vala_array_free (order_names, order_names_length1, (GDestroyNotify) g_free), NULL);
+		order_names = _tmp90_;
+		order_names_length1 = _tmp89_;
+		_order_names_size_ = order_names_length1;
+	}
+	_tmp91_ = var_xkb_engine_names;
+	_tmp91__length1 = var_xkb_engine_names_length1;
+	{
+		gchar** name_collection = NULL;
+		gint name_collection_length1 = 0;
+		gint _name_collection_size_ = 0;
+		gint name_it = 0;
+		name_collection = _tmp91_;
+		name_collection_length1 = _tmp91__length1;
+		for (name_it = 0; name_it < _tmp91__length1; name_it = name_it + 1) {
+			gchar* _tmp92_;
+			gchar* name = NULL;
+			_tmp92_ = g_strdup (name_collection[name_it]);
+			name = _tmp92_;
+			{
+				const gchar* _tmp93_;
+				gchar** _tmp94_;
+				gint _tmp94__length1;
+				gchar** _tmp95_;
+				gint _tmp95__length1;
+				const gchar* _tmp96_;
+				gchar* _tmp97_;
+				_tmp93_ = name;
+				_tmp94_ = order_names;
+				_tmp94__length1 = order_names_length1;
+				if (_vala_string_array_contains (_tmp94_, _tmp94__length1, _tmp93_)) {
+					_g_free0 (name);
+					continue;
+				}
+				_tmp95_ = order_names;
+				_tmp95__length1 = order_names_length1;
+				_tmp96_ = name;
+				_tmp97_ = g_strdup (_tmp96_);
+				_vala_array_add15 (&order_names, &order_names_length1, &_order_names_size_, _tmp97_);
+				updated_order_names = TRUE;
+				_g_free0 (name);
+			}
+		}
+	}
+	_tmp98_ = updated_order_names;
+	if (_tmp98_) {
+		IBusConfig* _tmp99_;
+		gchar** _tmp100_;
+		gint _tmp100__length1;
+		GVariant* _tmp101_;
+		GVariant* _tmp102_;
+		_tmp99_ = self->priv->m_config;
+		_tmp100_ = order_names;
+		_tmp100__length1 = order_names_length1;
+		_tmp101_ = g_variant_new_strv (_tmp100_, _tmp100__length1);
+		_tmp102_ = g_variant_ref_sink (_tmp101_);
+		ibus_config_set_value (_tmp99_, "general", "engines_order", _tmp102_);
+		_g_variant_unref0 (_tmp102_);
+	}
+	order_names = (_vala_array_free (order_names, order_names_length1, (GDestroyNotify) g_free), NULL);
+	_g_variant_unref0 (var_order);
+	engine_names = (_vala_array_free (engine_names, engine_names_length1, (GDestroyNotify) g_free), NULL);
+	_g_variant_unref0 (var_engines);
+	var_xkb_engine_names = (_vala_array_free (var_xkb_engine_names, var_xkb_engine_names_length1, (GDestroyNotify) g_free), NULL);
+	_g_object_unref0 (registry);
+	_g_free0 (var_variant);
+	_g_free0 (var_layout);
+}
+
+
+static void panel_set_xkb_group_layout (Panel* self, const gchar* layout) {
+	XKBLayout* _tmp0_;
+	const gchar* _tmp1_;
+	gint _tmp2_ = 0;
+	gint* _tmp3_ = NULL;
+	gint* retval;
+	gint retval_length1;
+	gint _retval_size_;
+	gint* _tmp4_;
+	gint _tmp4__length1;
+	gint _tmp5_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (layout != NULL);
+	_tmp0_ = self->priv->m_xkblayout;
+	_tmp1_ = layout;
+	_tmp3_ = xkb_layout_set_layout (_tmp0_, _tmp1_, "default", "default", &_tmp2_);
+	retval = _tmp3_;
+	retval_length1 = _tmp2_;
+	_retval_size_ = retval_length1;
+	_tmp4_ = retval;
+	_tmp4__length1 = retval_length1;
+	_tmp5_ = _tmp4_[0];
+	if (_tmp5_ >= 0) {
+		gint* _tmp6_;
+		gint _tmp6__length1;
+		gint _tmp7_;
+		gboolean _tmp8_ = FALSE;
+		gint* _tmp9_;
+		gint _tmp9__length1;
+		gint _tmp10_;
+		gboolean _tmp11_;
+		_tmp6_ = retval;
+		_tmp6__length1 = retval_length1;
+		_tmp7_ = _tmp6_[0];
+		self->priv->m_fallback_lock_id = _tmp7_;
+		_tmp9_ = retval;
+		_tmp9__length1 = retval_length1;
+		_tmp10_ = _tmp9_[1];
+		if (_tmp10_ != 0) {
+			_tmp8_ = TRUE;
+		} else {
+			_tmp8_ = FALSE;
+		}
+		_tmp11_ = _tmp8_;
+		self->priv->m_changed_xkb_option = _tmp11_;
+	}
+	retval = (g_free (retval), NULL);
+}
+
+
+static gboolean panel_set_gkbd_layout (Panel* self, const gchar* layout) {
+	gboolean result = FALSE;
+	gboolean _tmp0_;
+	GkbdLayout* _tmp1_;
+	gint _tmp2_ = 0;
+	gchar** _tmp3_ = NULL;
+	gchar** _tmp4_;
+	gint _tmp4__length1;
+	gint _tmp5_;
+	gint gkbd_len;
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (layout != NULL, FALSE);
+	_tmp0_ = self->priv->m_changed_xkb_option;
+	if (_tmp0_ == TRUE) {
+		self->priv->m_changed_xkb_option = FALSE;
+		result = FALSE;
+		return result;
+	}
+	_tmp1_ = self->priv->m_gkbdlayout;
+	_tmp3_ = gkbd_layout_get_group_names (_tmp1_, &_tmp2_);
+	_tmp4_ = _tmp3_;
+	_tmp4__length1 = _tmp2_;
+	_tmp5_ = _tmp2_;
+	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
+	gkbd_len = _tmp5_;
+	{
+		gint i;
+		i = 0;
+		{
+			gboolean _tmp6_;
+			_tmp6_ = TRUE;
+			while (TRUE) {
+				gboolean _tmp7_;
+				gboolean _tmp9_ = FALSE;
+				gint _tmp10_;
+				gchar** _tmp11_;
+				gint _tmp11__length1;
+				gboolean _tmp14_;
+				gchar** _tmp15_;
+				gint _tmp15__length1;
+				gint _tmp16_;
+				const gchar* _tmp17_;
+				gchar* _tmp18_;
+				gchar* sys_layout;
+				gboolean _tmp19_ = FALSE;
+				gint _tmp20_;
+				gchar** _tmp21_;
+				gint _tmp21__length1;
+				gboolean _tmp25_;
+				const gchar* _tmp31_;
+				const gchar* _tmp32_;
+				_tmp7_ = _tmp6_;
+				if (!_tmp7_) {
+					gint _tmp8_;
+					_tmp8_ = i;
+					i = _tmp8_ + 1;
+				}
+				_tmp6_ = FALSE;
+				_tmp10_ = i;
+				_tmp11_ = self->priv->m_layouts;
+				_tmp11__length1 = self->priv->m_layouts_length1;
+				if (_tmp10_ < _tmp11__length1) {
+					gint _tmp12_;
+					gint _tmp13_;
+					_tmp12_ = i;
+					_tmp13_ = gkbd_len;
+					_tmp9_ = _tmp12_ < _tmp13_;
+				} else {
+					_tmp9_ = FALSE;
+				}
+				_tmp14_ = _tmp9_;
+				if (!_tmp14_) {
+					break;
+				}
+				_tmp15_ = self->priv->m_layouts;
+				_tmp15__length1 = self->priv->m_layouts_length1;
+				_tmp16_ = i;
+				_tmp17_ = _tmp15_[_tmp16_];
+				_tmp18_ = g_strdup (_tmp17_);
+				sys_layout = _tmp18_;
+				_tmp20_ = i;
+				_tmp21_ = self->priv->m_variants;
+				_tmp21__length1 = self->priv->m_variants_length1;
+				if (_tmp20_ < _tmp21__length1) {
+					gchar** _tmp22_;
+					gint _tmp22__length1;
+					gint _tmp23_;
+					const gchar* _tmp24_;
+					_tmp22_ = self->priv->m_variants;
+					_tmp22__length1 = self->priv->m_variants_length1;
+					_tmp23_ = i;
+					_tmp24_ = _tmp22_[_tmp23_];
+					_tmp19_ = g_strcmp0 (_tmp24_, "") != 0;
+				} else {
+					_tmp19_ = FALSE;
+				}
+				_tmp25_ = _tmp19_;
+				if (_tmp25_) {
+					const gchar* _tmp26_;
+					gchar** _tmp27_;
+					gint _tmp27__length1;
+					gint _tmp28_;
+					const gchar* _tmp29_;
+					gchar* _tmp30_ = NULL;
+					_tmp26_ = sys_layout;
+					_tmp27_ = self->priv->m_variants;
+					_tmp27__length1 = self->priv->m_variants_length1;
+					_tmp28_ = i;
+					_tmp29_ = _tmp27_[_tmp28_];
+					_tmp30_ = g_strdup_printf ("%s(%s)", _tmp26_, _tmp29_);
+					_g_free0 (sys_layout);
+					sys_layout = _tmp30_;
+				}
+				_tmp31_ = sys_layout;
+				_tmp32_ = layout;
+				if (g_strcmp0 (_tmp31_, _tmp32_) == 0) {
+					GkbdLayout* _tmp33_;
+					gint _tmp34_;
+					_tmp33_ = self->priv->m_gkbdlayout;
+					_tmp34_ = i;
+					gkbd_layout_lock_group (_tmp33_, _tmp34_);
+					result = TRUE;
+					_g_free0 (sys_layout);
+					return result;
+				}
+				_g_free0 (sys_layout);
+			}
+		}
+	}
+	result = FALSE;
+	return result;
+}
+
+
+static void panel_set_layout (Panel* self, const gchar* layout) {
+	gboolean _tmp0_ = FALSE;
+	const gchar* _tmp1_;
+	gboolean _tmp3_;
+	XKBLayout* _tmp4_;
+	XKBLayout* _tmp8_;
+	const gchar* _tmp9_;
+	gint _tmp10_ = 0;
+	gint* _tmp11_ = NULL;
+	gint* _tmp12_;
+	gint _tmp12__length1;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (layout != NULL);
+	_tmp1_ = layout;
+	if (g_strcmp0 (_tmp1_, "default") == 0) {
+		_tmp0_ = TRUE;
+	} else {
+		const gchar* _tmp2_;
+		_tmp2_ = layout;
+		_tmp0_ = _tmp2_ == NULL;
+	}
+	_tmp3_ = _tmp0_;
+	if (_tmp3_) {
+		return;
+	}
+	_tmp4_ = self->priv->m_xkblayout;
+	if (_tmp4_ == NULL) {
+		panel_init_engines_order (self);
+	}
+	if (HAVE_IBUS_GKBD) {
+		const gchar* _tmp5_;
+		gboolean _tmp6_ = FALSE;
+		const gchar* _tmp7_;
+		_tmp5_ = layout;
+		_tmp6_ = panel_set_gkbd_layout (self, _tmp5_);
+		if (_tmp6_) {
+			return;
+		}
+		_tmp7_ = layout;
+		panel_set_xkb_group_layout (self, _tmp7_);
+		return;
+	}
+	_tmp8_ = self->priv->m_xkblayout;
+	_tmp9_ = layout;
+	_tmp11_ = xkb_layout_set_layout (_tmp8_, _tmp9_, "default", "default", &_tmp10_);
+	_tmp12_ = _tmp11_;
+	_tmp12__length1 = _tmp10_;
+	_tmp12_ = (g_free (_tmp12_), NULL);
+}
+
+
+static void _vala_array_add16 (gchar*** array, int* length, int* size, gchar* value) {
 	if ((*length) == (*size)) {
 		*size = (*size) ? (2 * (*size)) : 4;
 		*array = g_renew (gchar*, *array, (*size) + 1);
@@ -484,16 +1637,13 @@ static void panel_switch_engine (Panel*
 	gboolean _tmp32_ = FALSE;
 	IBusEngineDesc* _tmp35_;
 	const gchar* _tmp36_ = NULL;
-	gchar* _tmp37_ = NULL;
-	gchar* cmdline;
-	gchar** _tmp43_ = NULL;
+	gchar** _tmp37_ = NULL;
 	gchar** names;
 	gint names_length1;
 	gint _names_size_;
-	IBusEngineDesc** _tmp44_;
-	gint _tmp44__length1;
-	IBusConfig* _tmp50_;
-	GError * _inner_error_ = NULL;
+	IBusEngineDesc** _tmp38_;
+	gint _tmp38__length1;
+	IBusConfig* _tmp44_;
 	g_return_if_fail (self != NULL);
 	_tmp1_ = i;
 	if (_tmp1_ >= 0) {
@@ -588,107 +1738,63 @@ static void panel_switch_engine (Panel*
 		const gchar* _tmp34_ = NULL;
 		_tmp33_ = engine;
 		_tmp34_ = ibus_engine_desc_get_name (_tmp33_);
-		g_warning ("panel.vala:120: Switch engine to %s failed.", _tmp34_);
+		g_warning ("panel.vala:367: Switch engine to %s failed.", _tmp34_);
 		_g_object_unref0 (engine);
 		return;
 	}
 	_tmp35_ = engine;
 	_tmp36_ = ibus_engine_desc_get_layout (_tmp35_);
-	_tmp37_ = g_strdup_printf ("setxkbmap %s", _tmp36_);
-	cmdline = _tmp37_;
-	{
-		const gchar* _tmp38_;
-		gboolean _tmp39_ = FALSE;
-		gboolean _tmp40_;
-		_tmp38_ = cmdline;
-		_tmp39_ = g_spawn_command_line_sync (_tmp38_, NULL, NULL, NULL, &_inner_error_);
-		_tmp40_ = _tmp39_;
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_SPAWN_ERROR) {
-				goto __catch2_g_spawn_error;
-			}
-			_g_free0 (cmdline);
-			_g_object_unref0 (engine);
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-		if (!_tmp40_) {
-			IBusEngineDesc* _tmp41_;
-			const gchar* _tmp42_ = NULL;
-			_tmp41_ = engine;
-			_tmp42_ = ibus_engine_desc_get_layout (_tmp41_);
-			g_warning ("panel.vala:127: Switch xkb layout to %s failed.", _tmp42_);
-		}
-	}
-	goto __finally2;
-	__catch2_g_spawn_error:
-	{
-		GError* e = NULL;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		g_warning ("panel.vala:131: execute setxkblayout failed");
-		_g_error_free0 (e);
-	}
-	__finally2:
-	if (_inner_error_ != NULL) {
-		_g_free0 (cmdline);
-		_g_object_unref0 (engine);
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_tmp43_ = g_new0 (gchar*, 0 + 1);
-	names = _tmp43_;
+	panel_set_layout (self, _tmp36_);
+	_tmp37_ = g_new0 (gchar*, 0 + 1);
+	names = _tmp37_;
 	names_length1 = 0;
 	_names_size_ = names_length1;
-	_tmp44_ = self->priv->m_engines;
-	_tmp44__length1 = self->priv->m_engines_length1;
+	_tmp38_ = self->priv->m_engines;
+	_tmp38__length1 = self->priv->m_engines_length1;
 	{
 		IBusEngineDesc** desc_collection = NULL;
 		gint desc_collection_length1 = 0;
 		gint _desc_collection_size_ = 0;
 		gint desc_it = 0;
-		desc_collection = _tmp44_;
-		desc_collection_length1 = _tmp44__length1;
-		for (desc_it = 0; desc_it < _tmp44__length1; desc_it = desc_it + 1) {
-			IBusEngineDesc* _tmp45_;
+		desc_collection = _tmp38_;
+		desc_collection_length1 = _tmp38__length1;
+		for (desc_it = 0; desc_it < _tmp38__length1; desc_it = desc_it + 1) {
+			IBusEngineDesc* _tmp39_;
 			IBusEngineDesc* desc = NULL;
-			_tmp45_ = _g_object_ref0 (desc_collection[desc_it]);
-			desc = _tmp45_;
+			_tmp39_ = _g_object_ref0 (desc_collection[desc_it]);
+			desc = _tmp39_;
 			{
-				gchar** _tmp46_;
-				gint _tmp46__length1;
-				IBusEngineDesc* _tmp47_;
-				const gchar* _tmp48_ = NULL;
-				gchar* _tmp49_;
-				_tmp46_ = names;
-				_tmp46__length1 = names_length1;
-				_tmp47_ = desc;
-				_tmp48_ = ibus_engine_desc_get_name (_tmp47_);
-				_tmp49_ = g_strdup (_tmp48_);
-				_vala_array_add9 (&names, &names_length1, &_names_size_, _tmp49_);
+				gchar** _tmp40_;
+				gint _tmp40__length1;
+				IBusEngineDesc* _tmp41_;
+				const gchar* _tmp42_ = NULL;
+				gchar* _tmp43_;
+				_tmp40_ = names;
+				_tmp40__length1 = names_length1;
+				_tmp41_ = desc;
+				_tmp42_ = ibus_engine_desc_get_name (_tmp41_);
+				_tmp43_ = g_strdup (_tmp42_);
+				_vala_array_add16 (&names, &names_length1, &_names_size_, _tmp43_);
 				_g_object_unref0 (desc);
 			}
 		}
 	}
-	_tmp50_ = self->priv->m_config;
-	if (_tmp50_ != NULL) {
-		IBusConfig* _tmp51_;
-		gchar** _tmp52_;
-		gint _tmp52__length1;
-		GVariant* _tmp53_;
-		GVariant* _tmp54_;
-		_tmp51_ = self->priv->m_config;
-		_tmp52_ = names;
-		_tmp52__length1 = names_length1;
-		_tmp53_ = g_variant_new_strv (_tmp52_, _tmp52__length1);
-		_tmp54_ = g_variant_ref_sink (_tmp53_);
-		ibus_config_set_value (_tmp51_, "general", "engines_order", _tmp54_);
-		_g_variant_unref0 (_tmp54_);
+	_tmp44_ = self->priv->m_config;
+	if (_tmp44_ != NULL) {
+		IBusConfig* _tmp45_;
+		gchar** _tmp46_;
+		gint _tmp46__length1;
+		GVariant* _tmp47_;
+		GVariant* _tmp48_;
+		_tmp45_ = self->priv->m_config;
+		_tmp46_ = names;
+		_tmp46__length1 = names_length1;
+		_tmp47_ = g_variant_new_strv (_tmp46_, _tmp46__length1);
+		_tmp48_ = g_variant_ref_sink (_tmp47_);
+		ibus_config_set_value (_tmp45_, "general", "engines_order", _tmp48_);
+		_g_variant_unref0 (_tmp48_);
 	}
 	names = (_vala_array_free (names, names_length1, (GDestroyNotify) g_free), NULL);
-	_g_free0 (cmdline);
 	_g_object_unref0 (engine);
 }
 
@@ -782,7 +1888,7 @@ static void panel_handle_engine_switch (
 		i = _tmp17_;
 		_tmp18_ = i;
 		if (_tmp18_ < 0) {
-			g_debug ("panel.vala:167: switch cancelled");
+			g_debug ("panel.vala:406: switch cancelled");
 		} else {
 			gint _tmp19_;
 			IBusEngineDesc** _tmp20_;
@@ -819,7 +1925,7 @@ static void panel_handle_engine_switch (
 }
 
 
-static gchar** _vala_array_dup2 (gchar** self, int length) {
+static gchar** _vala_array_dup4 (gchar** self, int length) {
 	gchar** result;
 	int i;
 	result = g_new0 (gchar*, length + 1);
@@ -832,18 +1938,7 @@ static gchar** _vala_array_dup2 (gchar**
 }
 
 
-static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
-	int i;
-	for (i = 0; i < stack_length; i++) {
-		if (g_strcmp0 (stack[i], needle) == 0) {
-			return TRUE;
-		}
-	}
-	return FALSE;
-}
-
-
-static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value) {
+static void _vala_array_add17 (gchar*** array, int* length, int* size, gchar* value) {
 	if ((*length) == (*size)) {
 		*size = (*size) ? (2 * (*size)) : 4;
 		*array = g_renew (gchar*, *array, (*size) + 1);
@@ -853,7 +1948,7 @@ static void _vala_array_add10 (gchar***
 }
 
 
-static void _vala_array_add11 (gchar*** array, int* length, int* size, gchar* value) {
+static void _vala_array_add18 (gchar*** array, int* length, int* size, gchar* value) {
 	if ((*length) == (*size)) {
 		*size = (*size) ? (2 * (*size)) : 4;
 		*array = g_renew (gchar*, *array, (*size) + 1);
@@ -863,7 +1958,7 @@ static void _vala_array_add11 (gchar***
 }
 
 
-static IBusEngineDesc** _vala_array_dup3 (IBusEngineDesc** self, int length) {
+static IBusEngineDesc** _vala_array_dup5 (IBusEngineDesc** self, int length) {
 	IBusEngineDesc** result;
 	int i;
 	result = g_new0 (IBusEngineDesc*, length + 1);
@@ -876,7 +1971,7 @@ static IBusEngineDesc** _vala_array_dup3
 }
 
 
-static IBusEngineDesc** _vala_array_dup4 (IBusEngineDesc** self, int length) {
+static IBusEngineDesc** _vala_array_dup6 (IBusEngineDesc** self, int length) {
 	IBusEngineDesc** result;
 	int i;
 	result = g_new0 (IBusEngineDesc*, length + 1);
@@ -985,7 +2080,7 @@ static void panel_update_engines (Panel*
 	}
 	_tmp15_ = _tmp10_;
 	_tmp15__length1 = _tmp10__length1;
-	_tmp16_ = (_tmp15_ != NULL) ? _vala_array_dup2 (_tmp15_, _tmp15__length1) : ((gpointer) _tmp15_);
+	_tmp16_ = (_tmp15_ != NULL) ? _vala_array_dup4 (_tmp15_, _tmp15__length1) : ((gpointer) _tmp15_);
 	_tmp16__length1 = _tmp15__length1;
 	order_names = _tmp16_;
 	order_names_length1 = _tmp16__length1;
@@ -1024,7 +2119,7 @@ static void panel_update_engines (Panel*
 					_tmp22__length1 = names_length1;
 					_tmp23_ = name;
 					_tmp24_ = g_strdup (_tmp23_);
-					_vala_array_add10 (&names, &names_length1, &_names_size_, _tmp24_);
+					_vala_array_add17 (&names, &names_length1, &_names_size_, _tmp24_);
 				}
 				_g_free0 (name);
 			}
@@ -1063,7 +2158,7 @@ static void panel_update_engines (Panel*
 				_tmp29__length1 = names_length1;
 				_tmp30_ = name;
 				_tmp31_ = g_strdup (_tmp30_);
-				_vala_array_add11 (&names, &names_length1, &_names_size_, _tmp31_);
+				_vala_array_add18 (&names, &names_length1, &_names_size_, _tmp31_);
 				_g_free0 (name);
 			}
 		}
@@ -1084,7 +2179,7 @@ static void panel_update_engines (Panel*
 		gint _tmp38__length1;
 		_tmp37_ = engines;
 		_tmp37__length1 = engines_length1;
-		_tmp38_ = (_tmp37_ != NULL) ? _vala_array_dup3 (_tmp37_, _tmp37__length1) : ((gpointer) _tmp37_);
+		_tmp38_ = (_tmp37_ != NULL) ? _vala_array_dup5 (_tmp37_, _tmp37__length1) : ((gpointer) _tmp37_);
 		_tmp38__length1 = _tmp37__length1;
 		self->priv->m_engines = (_vala_array_free (self->priv->m_engines, self->priv->m_engines_length1, (GDestroyNotify) g_object_unref), NULL);
 		self->priv->m_engines = _tmp38_;
@@ -1109,7 +2204,7 @@ static void panel_update_engines (Panel*
 		current_engine = _tmp41_;
 		_tmp42_ = engines;
 		_tmp42__length1 = engines_length1;
-		_tmp43_ = (_tmp42_ != NULL) ? _vala_array_dup4 (_tmp42_, _tmp42__length1) : ((gpointer) _tmp42_);
+		_tmp43_ = (_tmp42_ != NULL) ? _vala_array_dup6 (_tmp42_, _tmp42__length1) : ((gpointer) _tmp42_);
 		_tmp43__length1 = _tmp42__length1;
 		self->priv->m_engines = (_vala_array_free (self->priv->m_engines, self->priv->m_engines_length1, (GDestroyNotify) g_object_unref), NULL);
 		self->priv->m_engines = _tmp43_;
@@ -1237,7 +2332,7 @@ static void panel_show_setup_dialog (Pan
 		_tmp8_ = (_vala_array_free (_tmp8_, _tmp8__length1, (GDestroyNotify) g_free), NULL);
 		if (_inner_error_ != NULL) {
 			if (_inner_error_->domain == G_SPAWN_ERROR) {
-				goto __catch3_g_spawn_error;
+				goto __catch2_g_spawn_error;
 			}
 			_g_free0 (binary);
 			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
@@ -1245,8 +2340,8 @@ static void panel_show_setup_dialog (Pan
 			return;
 		}
 	}
-	goto __finally3;
-	__catch3_g_spawn_error:
+	goto __finally2;
+	__catch2_g_spawn_error:
 	{
 		GError* e = NULL;
 		const gchar* _tmp10_;
@@ -1257,11 +2352,11 @@ static void panel_show_setup_dialog (Pan
 		_tmp10_ = binary;
 		_tmp11_ = e;
 		_tmp12_ = _tmp11_->message;
-		g_warning ("panel.vala:239: Execute %s failed! %s", _tmp10_, _tmp12_);
+		g_warning ("panel.vala:478: Execute %s failed! %s", _tmp10_, _tmp12_);
 		self->priv->m_setup_pid = (GPid) 0;
 		_g_error_free0 (e);
 	}
-	__finally3:
+	__finally2:
 	if (_inner_error_ != NULL) {
 		_g_free0 (binary);
 		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
@@ -1950,12 +3045,31 @@ static void panel_class_init (PanelClass
 
 static void panel_instance_init (Panel * self) {
 	IBusEngineDesc** _tmp0_ = NULL;
+	gchar** _tmp1_ = NULL;
+	gchar** _tmp2_ = NULL;
+	gchar** _tmp3_ = NULL;
 	self->priv = PANEL_GET_PRIVATE (self);
 	_tmp0_ = g_new0 (IBusEngineDesc*, 0 + 1);
 	self->priv->m_engines = _tmp0_;
 	self->priv->m_engines_length1 = 0;
 	self->priv->_m_engines_size_ = self->priv->m_engines_length1;
 	self->priv->m_setup_pid = (GPid) 0;
+	self->priv->m_gkbdlayout = NULL;
+	self->priv->m_xkblayout = NULL;
+	_tmp1_ = g_new0 (gchar*, 0 + 1);
+	self->priv->m_layouts = _tmp1_;
+	self->priv->m_layouts_length1 = 0;
+	self->priv->_m_layouts_size_ = self->priv->m_layouts_length1;
+	_tmp2_ = g_new0 (gchar*, 0 + 1);
+	self->priv->m_variants = _tmp2_;
+	self->priv->m_variants_length1 = 0;
+	self->priv->_m_variants_size_ = self->priv->m_variants_length1;
+	self->priv->m_fallback_lock_id = -1;
+	self->priv->m_changed_xkb_option = FALSE;
+	_tmp3_ = g_new0 (gchar*, 0 + 1);
+	self->priv->ACCELERATOR_IME_HOTKEYS = _tmp3_;
+	self->priv->ACCELERATOR_IME_HOTKEYS_length1 = 0;
+	self->priv->_ACCELERATOR_IME_HOTKEYS_size_ = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
 }
 
 
@@ -1963,15 +3077,66 @@ static void panel_finalize (GObject* obj
 	Panel * self;
 	KeybindingManager* _tmp0_ = NULL;
 	KeybindingManager* keybinding_manager;
-	KeybindingManager* _tmp1_;
-	KeybindingManager* _tmp2_;
+	gchar** _tmp1_;
+	gint _tmp1__length1;
+	gboolean _tmp7_ = FALSE;
+	gboolean _tmp9_;
 	self = PANEL (obj);
 	_tmp0_ = keybinding_manager_get_instance ();
 	keybinding_manager = _tmp0_;
-	_tmp1_ = keybinding_manager;
-	keybinding_manager_unbind (_tmp1_, PANEL_ACCELERATOR_SWITCH_IME_FOREWARD);
-	_tmp2_ = keybinding_manager;
-	keybinding_manager_unbind (_tmp2_, PANEL_ACCELERATOR_SWITCH_IME_BACKWARD);
+	_tmp1_ = self->priv->ACCELERATOR_IME_HOTKEYS;
+	_tmp1__length1 = self->priv->ACCELERATOR_IME_HOTKEYS_length1;
+	{
+		gchar** keybinding_collection = NULL;
+		gint keybinding_collection_length1 = 0;
+		gint _keybinding_collection_size_ = 0;
+		gint keybinding_it = 0;
+		keybinding_collection = _tmp1_;
+		keybinding_collection_length1 = _tmp1__length1;
+		for (keybinding_it = 0; keybinding_it < _tmp1__length1; keybinding_it = keybinding_it + 1) {
+			gchar* _tmp2_;
+			gchar* keybinding = NULL;
+			_tmp2_ = g_strdup (keybinding_collection[keybinding_it]);
+			keybinding = _tmp2_;
+			{
+				KeybindingManager* _tmp3_;
+				const gchar* _tmp4_;
+				const gchar* _tmp5_;
+				_tmp3_ = keybinding_manager;
+				_tmp4_ = keybinding;
+				keybinding_manager_unbind (_tmp3_, _tmp4_);
+				_tmp5_ = keybinding;
+				if (g_strcmp0 (_tmp5_, PANEL_ACCELERATOR_SWITCH_IME_FOREWARD) == 0) {
+					KeybindingManager* _tmp6_;
+					_tmp6_ = keybinding_manager;
+					keybinding_manager_unbind (_tmp6_, PANEL_ACCELERATOR_SWITCH_IME_BACKWARD);
+				}
+				_g_free0 (keybinding);
+			}
+		}
+	}
+	if (HAVE_IBUS_GKBD) {
+		GkbdLayout* _tmp8_;
+		_tmp8_ = self->priv->m_gkbdlayout;
+		_tmp7_ = _tmp8_ != NULL;
+	} else {
+		_tmp7_ = FALSE;
+	}
+	_tmp9_ = _tmp7_;
+	if (_tmp9_) {
+		GkbdLayout* _tmp10_;
+		guint _tmp11_ = 0U;
+		GkbdLayout* _tmp12_;
+		_tmp10_ = self->priv->m_gkbdlayout;
+		g_signal_parse_name ("changed", TYPE_GKBD_LAYOUT, &_tmp11_, NULL, FALSE);
+		g_signal_handlers_disconnect_matched (_tmp10_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp11_, 0, NULL, (GCallback) _panel_gkbdlayout_changed_cb_gkbd_layout_changed, self);
+		_tmp12_ = self->priv->m_gkbdlayout;
+		gkbd_layout_stop_listen (_tmp12_);
+		_gkbd_layout_unref0 (self->priv->m_gkbdlayout);
+		self->priv->m_gkbdlayout = NULL;
+	}
+	_xkb_layout_unref0 (self->priv->m_xkblayout);
+	self->priv->m_xkblayout = NULL;
 	_g_object_unref0 (keybinding_manager);
 	_g_object_unref0 (self->priv->m_bus);
 	_g_object_unref0 (self->priv->m_config);
@@ -1983,6 +3148,12 @@ static void panel_finalize (GObject* obj
 	_g_object_unref0 (self->priv->m_switcher);
 	_property_manager_unref0 (self->priv->m_property_manager);
 	_g_object_unref0 (self->priv->m_about_dialog);
+	_gkbd_layout_unref0 (self->priv->m_gkbdlayout);
+	_xkb_layout_unref0 (self->priv->m_xkblayout);
+	self->priv->m_layouts = (_vala_array_free (self->priv->m_layouts, self->priv->m_layouts_length1, (GDestroyNotify) g_free), NULL);
+	self->priv->m_variants = (_vala_array_free (self->priv->m_variants, self->priv->m_variants_length1, (GDestroyNotify) g_free), NULL);
+	_g_timer_destroy0 (self->priv->m_changed_layout_timer);
+	self->priv->ACCELERATOR_IME_HOTKEYS = (_vala_array_free (self->priv->ACCELERATOR_IME_HOTKEYS, self->priv->ACCELERATOR_IME_HOTKEYS_length1, (GDestroyNotify) g_free), NULL);
 	G_OBJECT_CLASS (panel_parent_class)->finalize (obj);
 }
 
--- ibus/ui/gtk3/switcher.c.orig	2012-03-04 19:05:35.000000000 +0900
+++ ibus/ui/gtk3/switcher.c	2012-03-10 11:26:30.424984137 +0900
@@ -103,7 +103,7 @@ guint keybinding_manager_get_primary_mod
 static void switcher_update_engines (Switcher* self, IBusEngineDesc** engines, int engines_length1);
 static gboolean ___lambda15_ (Switcher* self);
 static gboolean ____lambda15__gsource_func (gpointer self);
-static IBusEngineDesc** _vala_array_dup5 (IBusEngineDesc** self, int length);
+static IBusEngineDesc** _vala_array_dup7 (IBusEngineDesc** self, int length);
 static Block5Data* block5_data_ref (Block5Data* _data5_);
 static void block5_data_unref (Block5Data* _data5_);
 IconWidget* icon_widget_new (const gchar* icon, gint size);
@@ -113,7 +113,7 @@ static gboolean _____lambda13_ (Block5Da
 static gboolean ______lambda13__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
 static gboolean _____lambda14_ (Block5Data* _data5_, GdkEventButton* e);
 static gboolean ______lambda14__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
-static void _vala_array_add12 (GtkButton*** array, int* length, int* size, GtkButton* value);
+static void _vala_array_add19 (GtkButton*** array, int* length, int* size, GtkButton* value);
 static void switcher_next_engine (Switcher* self);
 static void switcher_previous_engine (Switcher* self);
 static void switcher_real_show (GtkWidget* base);
@@ -207,7 +207,9 @@ gint switcher_run (Switcher* self, GdkEv
 	GdkGrabStatus _tmp48_;
 	GMainLoop* _tmp50_;
 	GMainLoop* _tmp51_;
-	gint _tmp53_;
+	GdkDevice* _tmp52_;
+	GdkDevice* _tmp53_;
+	gint _tmp55_;
 	g_return_val_if_fail (self != NULL, 0);
 	g_return_val_if_fail (event != NULL, 0);
 	_tmp0_ = self->priv->m_loop;
@@ -335,17 +337,21 @@ gint switcher_run (Switcher* self, GdkEv
 	g_main_loop_run (_tmp51_);
 	_g_main_loop_unref0 (self->priv->m_loop);
 	self->priv->m_loop = NULL;
+	_tmp52_ = keyboard;
+	gdk_device_ungrab (_tmp52_, (guint32) GDK_CURRENT_TIME);
+	_tmp53_ = pointer;
+	gdk_device_ungrab (_tmp53_, (guint32) GDK_CURRENT_TIME);
 	gtk_widget_hide ((GtkWidget*) self);
 	while (TRUE) {
-		gboolean _tmp52_ = FALSE;
-		_tmp52_ = gtk_events_pending ();
-		if (!_tmp52_) {
+		gboolean _tmp54_ = FALSE;
+		_tmp54_ = gtk_events_pending ();
+		if (!_tmp54_) {
 			break;
 		}
 		gtk_main_iteration ();
 	}
-	_tmp53_ = self->priv->m_result;
-	result = _tmp53_;
+	_tmp55_ = self->priv->m_result;
+	result = _tmp55_;
 	_g_object_unref0 (pointer);
 	_g_object_unref0 (keyboard);
 	_g_object_unref0 (device);
@@ -353,7 +359,7 @@ gint switcher_run (Switcher* self, GdkEv
 }
 
 
-static IBusEngineDesc** _vala_array_dup5 (IBusEngineDesc** self, int length) {
+static IBusEngineDesc** _vala_array_dup7 (IBusEngineDesc** self, int length) {
 	IBusEngineDesc** result;
 	int i;
 	result = g_new0 (IBusEngineDesc*, length + 1);
@@ -432,7 +438,7 @@ static gboolean ______lambda14__gtk_widg
 }
 
 
-static void _vala_array_add12 (GtkButton*** array, int* length, int* size, GtkButton* value) {
+static void _vala_array_add19 (GtkButton*** array, int* length, int* size, GtkButton* value) {
 	if ((*length) == (*size)) {
 		*size = (*size) ? (2 * (*size)) : 4;
 		*array = g_renew (GtkButton*, *array, (*size) + 1);
@@ -500,7 +506,7 @@ static void switcher_update_engines (Swi
 	height = _tmp7_;
 	_tmp8_ = engines;
 	_tmp8__length1 = engines_length1;
-	_tmp9_ = (_tmp8_ != NULL) ? _vala_array_dup5 (_tmp8_, _tmp8__length1) : ((gpointer) _tmp8_);
+	_tmp9_ = (_tmp8_ != NULL) ? _vala_array_dup7 (_tmp8_, _tmp8__length1) : ((gpointer) _tmp8_);
 	_tmp9__length1 = _tmp8__length1;
 	self->priv->m_engines = (_vala_array_free (self->priv->m_engines, self->priv->m_engines_length1, (GDestroyNotify) g_object_unref), NULL);
 	self->priv->m_engines = _tmp9_;
@@ -599,7 +605,7 @@ static void switcher_update_engines (Swi
 				_tmp36__length1 = self->priv->m_buttons_length1;
 				_tmp37_ = _data5_->button;
 				_tmp38_ = _g_object_ref0 (_tmp37_);
-				_vala_array_add12 (&self->priv->m_buttons, &self->priv->m_buttons_length1, &self->priv->_m_buttons_size_, _tmp38_);
+				_vala_array_add19 (&self->priv->m_buttons, &self->priv->m_buttons_length1, &self->priv->_m_buttons_size_, _tmp38_);
 				_g_object_unref0 (engine);
 				block5_data_unref (_data5_);
 				_data5_ = NULL;
@@ -725,7 +731,7 @@ static gboolean switcher_real_key_press_
 			guint _tmp5_;
 			_tmp4_ = pe;
 			_tmp5_ = (*_tmp4_).keyval;
-			g_debug ("switcher.vala:225: 0x%04x", _tmp5_);
+			g_debug ("switcher.vala:228: 0x%04x", _tmp5_);
 			break;
 		}
 	}
@@ -742,7 +748,8 @@ static gboolean switcher_real_key_releas
 	guint _tmp1_;
 	gboolean _tmp2_ = FALSE;
 	GMainLoop* _tmp3_;
-	guint _tmp4_;
+	GMainLoop* _tmp4_;
+	guint _tmp5_;
 	self = (Switcher*) base;
 	g_return_val_if_fail (e != NULL, FALSE);
 	pe = e;
@@ -754,9 +761,14 @@ static gboolean switcher_real_key_releas
 		return result;
 	}
 	_tmp3_ = self->priv->m_loop;
-	g_main_loop_quit (_tmp3_);
-	_tmp4_ = self->priv->m_selected_engine;
-	self->priv->m_result = (gint) _tmp4_;
+	if (_tmp3_ == NULL) {
+		result = FALSE;
+		return result;
+	}
+	_tmp4_ = self->priv->m_loop;
+	g_main_loop_quit (_tmp4_);
+	_tmp5_ = self->priv->m_selected_engine;
+	self->priv->m_result = (gint) _tmp5_;
 	result = TRUE;
 	return result;
 }
--- ibus/ui/gtk3/xkblayout.c.orig	2012-03-09 18:58:41.452804090 +0900
+++ ibus/ui/gtk3/xkblayout.c	2012-03-09 18:54:51.718558456 +0900
@@ -0,0 +1,2441 @@
+/* xkblayout.c generated by valac 0.15.1, the Vala compiler
+ * generated from xkblayout.vala, do not modify */
+
+/* vim:set et sts=4 sw=4:
+ *
+ * ibus - The Input Bus
+ *
+ * Copyright 2012 Red Hat, Inc.
+ * Copyright(c) 2012 Peng Huang <shawn.p.huang@gmail.com>
+ * Copyright(c) 2012 Takao Fujiwara <tfujiwar@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or(at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA  02111-1307  USA
+ */
+
+#include <glib.h>
+#include <glib-object.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ibus.h>
+#include <stdio.h>
+#include <glib/gstdio.h>
+#include <gobject/gvaluecollector.h>
+
+
+#define TYPE_XKB_LAYOUT (xkb_layout_get_type ())
+#define XKB_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XKB_LAYOUT, XKBLayout))
+#define XKB_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XKB_LAYOUT, XKBLayoutClass))
+#define IS_XKB_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XKB_LAYOUT))
+#define IS_XKB_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XKB_LAYOUT))
+#define XKB_LAYOUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XKB_LAYOUT, XKBLayoutClass))
+
+typedef struct _XKBLayout XKBLayout;
+typedef struct _XKBLayoutClass XKBLayoutClass;
+typedef struct _XKBLayoutPrivate XKBLayoutPrivate;
+#define _g_free0(var) (var = (g_free (var), NULL))
+#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
+#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
+#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
+typedef struct _ParamSpecXKBLayout ParamSpecXKBLayout;
+
+struct _XKBLayout {
+	GTypeInstance parent_instance;
+	volatile int ref_count;
+	XKBLayoutPrivate * priv;
+};
+
+struct _XKBLayoutClass {
+	GTypeClass parent_class;
+	void (*finalize) (XKBLayout *self);
+};
+
+struct _XKBLayoutPrivate {
+	gchar* m_xkb_command;
+	IBusConfig* m_config;
+	gchar** m_xkb_latin_layouts;
+	gint m_xkb_latin_layouts_length1;
+	gint _m_xkb_latin_layouts_size_;
+	GPid m_xkb_pid;
+	GPid m_xmodmap_pid;
+	gchar* m_xmodmap_command;
+	gboolean m_use_xmodmap;
+	gchar** m_xmodmap_known_files;
+	gint m_xmodmap_known_files_length1;
+	gint _m_xmodmap_known_files_size_;
+	gchar* m_default_layout;
+	gchar* m_default_variant;
+	gchar* m_default_option;
+};
+
+struct _ParamSpecXKBLayout {
+	GParamSpec parent_instance;
+};
+
+
+static gpointer xkb_layout_parent_class = NULL;
+
+gpointer xkb_layout_ref (gpointer instance);
+void xkb_layout_unref (gpointer instance);
+GParamSpec* param_spec_xkb_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
+void value_set_xkb_layout (GValue* value, gpointer v_object);
+void value_take_xkb_layout (GValue* value, gpointer v_object);
+gpointer value_get_xkb_layout (const GValue* value);
+GType xkb_layout_get_type (void) G_GNUC_CONST;
+#define XKB_LAYOUT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_XKB_LAYOUT, XKBLayoutPrivate))
+enum  {
+	XKB_LAYOUT_DUMMY_PROPERTY
+};
+XKBLayout* xkb_layout_new (IBusConfig* config);
+XKBLayout* xkb_layout_construct (GType object_type, IBusConfig* config);
+static void _vala_array_add20 (gchar*** array, int* length, int* size, gchar* value);
+static gchar* xkb_layout_get_output_from_cmdline (XKBLayout* self, const gchar* arg, const gchar* element);
+static void _vala_array_add21 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add22 (gchar*** array, int* length, int* size, gchar* value);
+static void xkb_layout_set_layout_cb (XKBLayout* self, GPid pid, gint status);
+void xkb_layout_set_xmodmap (XKBLayout* self);
+static void xkb_layout_set_xmodmap_cb (XKBLayout* self, GPid pid, gint status);
+static gchar* xkb_layout_get_fullpath (XKBLayout* self, const gchar* command);
+static gchar** xkb_layout_get_xkb_group_layout (XKBLayout* self, const gchar* layout, const gchar* variant, gint layouts_max_length, int* result_length1);
+gchar** xkb_layout_get_variant_from_layout (XKBLayout* self, const gchar* layout, int* result_length1);
+gchar** xkb_layout_get_option_from_layout (XKBLayout* self, const gchar* layout, int* result_length1);
+gchar* xkb_layout_get_layout (XKBLayout* self);
+gchar* xkb_layout_get_variant (XKBLayout* self);
+gchar* xkb_layout_get_option (XKBLayout* self);
+gint* xkb_layout_set_layout (XKBLayout* self, const gchar* _layout, const gchar* _variant, const gchar* _option, int* result_length1);
+static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
+static void _vala_array_add23 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add24 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add25 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add26 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add27 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add28 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add29 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add30 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add31 (gchar*** array, int* length, int* size, gchar* value);
+static void _vala_array_add32 (gchar*** array, int* length, int* size, gchar* value);
+static void _xkb_layout_set_layout_cb_gchild_watch_func (GPid pid, gint status, gpointer self);
+static void _xkb_layout_set_xmodmap_cb_gchild_watch_func (GPid pid, gint status, gpointer self);
+void xkb_layout_reset_layout (XKBLayout* self);
+static void xkb_layout_finalize (XKBLayout* obj);
+static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
+static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
+static gint _vala_array_length (gpointer array);
+
+
+static gpointer _g_object_ref0 (gpointer self) {
+	return self ? g_object_ref (self) : NULL;
+}
+
+
+static void _vala_array_add20 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+XKBLayout* xkb_layout_construct (GType object_type, IBusConfig* config) {
+	XKBLayout* self = NULL;
+	IBusConfig* _tmp1_;
+	IBusConfig* _tmp2_;
+	IBusConfig* _tmp3_;
+	self = (XKBLayout*) g_type_create_instance (object_type);
+	if (!HAVE_IBUS_XKB) {
+		gchar* _tmp0_;
+		_tmp0_ = g_strdup ("setxkbmap");
+		_g_free0 (self->priv->m_xkb_command);
+		self->priv->m_xkb_command = _tmp0_;
+	}
+	_tmp1_ = config;
+	_tmp2_ = _g_object_ref0 (_tmp1_);
+	_g_object_unref0 (self->priv->m_config);
+	self->priv->m_config = _tmp2_;
+	_tmp3_ = config;
+	if (_tmp3_ != NULL) {
+		IBusConfig* _tmp4_;
+		GVariant* _tmp5_ = NULL;
+		GVariant* value;
+		gboolean _tmp21_;
+		_tmp4_ = config;
+		_tmp5_ = ibus_config_get_value (_tmp4_, "general", "xkb_latin_layouts");
+		value = _tmp5_;
+		{
+			gint i;
+			i = 0;
+			{
+				gboolean _tmp6_;
+				_tmp6_ = TRUE;
+				while (TRUE) {
+					gboolean _tmp7_;
+					gboolean _tmp9_ = FALSE;
+					GVariant* _tmp10_;
+					gboolean _tmp14_;
+					gchar** _tmp15_;
+					gint _tmp15__length1;
+					GVariant* _tmp16_;
+					gint _tmp17_;
+					GVariant* _tmp18_ = NULL;
+					GVariant* _tmp19_;
+					gchar* _tmp20_ = NULL;
+					_tmp7_ = _tmp6_;
+					if (!_tmp7_) {
+						gint _tmp8_;
+						_tmp8_ = i;
+						i = _tmp8_ + 1;
+					}
+					_tmp6_ = FALSE;
+					_tmp10_ = value;
+					if (_tmp10_ != NULL) {
+						gint _tmp11_;
+						GVariant* _tmp12_;
+						gsize _tmp13_ = 0UL;
+						_tmp11_ = i;
+						_tmp12_ = value;
+						_tmp13_ = g_variant_n_children (_tmp12_);
+						_tmp9_ = ((gsize) _tmp11_) < _tmp13_;
+					} else {
+						_tmp9_ = FALSE;
+					}
+					_tmp14_ = _tmp9_;
+					if (!_tmp14_) {
+						break;
+					}
+					_tmp15_ = self->priv->m_xkb_latin_layouts;
+					_tmp15__length1 = self->priv->m_xkb_latin_layouts_length1;
+					_tmp16_ = value;
+					_tmp17_ = i;
+					_tmp18_ = g_variant_get_child_value (_tmp16_, (gsize) _tmp17_);
+					_tmp19_ = _tmp18_;
+					_tmp20_ = g_variant_dup_string (_tmp19_, NULL);
+					_vala_array_add20 (&self->priv->m_xkb_latin_layouts, &self->priv->m_xkb_latin_layouts_length1, &self->priv->_m_xkb_latin_layouts_size_, _tmp20_);
+					_g_variant_unref0 (_tmp19_);
+				}
+			}
+		}
+		_tmp21_ = self->priv->m_use_xmodmap;
+		if (_tmp21_) {
+			IBusConfig* _tmp22_;
+			GVariant* _tmp23_ = NULL;
+			GVariant* _tmp24_;
+			gboolean _tmp25_ = FALSE;
+			_tmp22_ = config;
+			_tmp23_ = ibus_config_get_value (_tmp22_, "general", "use_xmodmap");
+			_tmp24_ = _tmp23_;
+			_tmp25_ = g_variant_get_boolean (_tmp24_);
+			self->priv->m_use_xmodmap = _tmp25_;
+			_g_variant_unref0 (_tmp24_);
+		}
+		_g_variant_unref0 (value);
+	}
+	return self;
+}
+
+
+XKBLayout* xkb_layout_new (IBusConfig* config) {
+	return xkb_layout_construct (TYPE_XKB_LAYOUT, config);
+}
+
+
+static void _vala_array_add21 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add22 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static gchar* string_slice (const gchar* self, glong start, glong end) {
+	gchar* result = NULL;
+	gint _tmp0_;
+	gint _tmp1_;
+	glong string_length;
+	glong _tmp2_;
+	glong _tmp5_;
+	gboolean _tmp8_ = FALSE;
+	glong _tmp9_;
+	gboolean _tmp12_;
+	gboolean _tmp13_ = FALSE;
+	glong _tmp14_;
+	gboolean _tmp17_;
+	glong _tmp18_;
+	glong _tmp19_;
+	glong _tmp20_;
+	glong _tmp21_;
+	glong _tmp22_;
+	gchar* _tmp23_ = NULL;
+	g_return_val_if_fail (self != NULL, NULL);
+	_tmp0_ = strlen (self);
+	_tmp1_ = _tmp0_;
+	string_length = (glong) _tmp1_;
+	_tmp2_ = start;
+	if (_tmp2_ < ((glong) 0)) {
+		glong _tmp3_;
+		glong _tmp4_;
+		_tmp3_ = string_length;
+		_tmp4_ = start;
+		start = _tmp3_ + _tmp4_;
+	}
+	_tmp5_ = end;
+	if (_tmp5_ < ((glong) 0)) {
+		glong _tmp6_;
+		glong _tmp7_;
+		_tmp6_ = string_length;
+		_tmp7_ = end;
+		end = _tmp6_ + _tmp7_;
+	}
+	_tmp9_ = start;
+	if (_tmp9_ >= ((glong) 0)) {
+		glong _tmp10_;
+		glong _tmp11_;
+		_tmp10_ = start;
+		_tmp11_ = string_length;
+		_tmp8_ = _tmp10_ <= _tmp11_;
+	} else {
+		_tmp8_ = FALSE;
+	}
+	_tmp12_ = _tmp8_;
+	g_return_val_if_fail (_tmp12_, NULL);
+	_tmp14_ = end;
+	if (_tmp14_ >= ((glong) 0)) {
+		glong _tmp15_;
+		glong _tmp16_;
+		_tmp15_ = end;
+		_tmp16_ = string_length;
+		_tmp13_ = _tmp15_ <= _tmp16_;
+	} else {
+		_tmp13_ = FALSE;
+	}
+	_tmp17_ = _tmp13_;
+	g_return_val_if_fail (_tmp17_, NULL);
+	_tmp18_ = start;
+	_tmp19_ = end;
+	g_return_val_if_fail (_tmp18_ <= _tmp19_, NULL);
+	_tmp20_ = start;
+	_tmp21_ = end;
+	_tmp22_ = start;
+	_tmp23_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) (_tmp21_ - _tmp22_));
+	result = _tmp23_;
+	return result;
+}
+
+
+static gchar* xkb_layout_get_output_from_cmdline (XKBLayout* self, const gchar* arg, const gchar* element) {
+	gchar* result = NULL;
+	gchar** _tmp0_ = NULL;
+	gchar** exec_command;
+	gint exec_command_length1;
+	gint _exec_command_size_;
+	gchar** _tmp1_;
+	gint _tmp1__length1;
+	const gchar* _tmp2_;
+	gchar* _tmp3_;
+	gchar** _tmp4_;
+	gint _tmp4__length1;
+	const gchar* _tmp5_;
+	gchar* _tmp6_;
+	gchar* standard_output;
+	gchar* standard_error;
+	gint exit_status;
+	gchar* _tmp7_;
+	gchar* retval;
+	gint _tmp15_;
+	const gchar* _tmp23_;
+	const gchar* _tmp25_;
+	gchar** _tmp26_;
+	gchar** _tmp27_ = NULL;
+	GError * _inner_error_ = NULL;
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (arg != NULL, NULL);
+	g_return_val_if_fail (element != NULL, NULL);
+	_tmp0_ = g_new0 (gchar*, 0 + 1);
+	exec_command = _tmp0_;
+	exec_command_length1 = 0;
+	_exec_command_size_ = exec_command_length1;
+	_tmp1_ = exec_command;
+	_tmp1__length1 = exec_command_length1;
+	_tmp2_ = self->priv->m_xkb_command;
+	_tmp3_ = g_strdup (_tmp2_);
+	_vala_array_add21 (&exec_command, &exec_command_length1, &_exec_command_size_, _tmp3_);
+	_tmp4_ = exec_command;
+	_tmp4__length1 = exec_command_length1;
+	_tmp5_ = arg;
+	_tmp6_ = g_strdup (_tmp5_);
+	_vala_array_add22 (&exec_command, &exec_command_length1, &_exec_command_size_, _tmp6_);
+	standard_output = NULL;
+	standard_error = NULL;
+	exit_status = 0;
+	_tmp7_ = g_strdup ("");
+	retval = _tmp7_;
+	{
+		gchar** _tmp8_;
+		gint _tmp8__length1;
+		gchar* _tmp9_ = NULL;
+		gchar* _tmp10_ = NULL;
+		gint _tmp11_ = 0;
+		_tmp8_ = exec_command;
+		_tmp8__length1 = exec_command_length1;
+		g_spawn_sync (NULL, _tmp8_, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp9_, &_tmp10_, &_tmp11_, &_inner_error_);
+		_g_free0 (standard_output);
+		standard_output = _tmp9_;
+		_g_free0 (standard_error);
+		standard_error = _tmp10_;
+		exit_status = _tmp11_;
+		if (_inner_error_ != NULL) {
+			if (_inner_error_->domain == G_SPAWN_ERROR) {
+				goto __catch3_g_spawn_error;
+			}
+			_g_free0 (retval);
+			_g_free0 (standard_error);
+			_g_free0 (standard_output);
+			exec_command = (_vala_array_free (exec_command, exec_command_length1, (GDestroyNotify) g_free), NULL);
+			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+			g_clear_error (&_inner_error_);
+			return NULL;
+		}
+	}
+	goto __finally3;
+	__catch3_g_spawn_error:
+	{
+		GError* err = NULL;
+		FILE* _tmp12_;
+		GError* _tmp13_;
+		const gchar* _tmp14_;
+		err = _inner_error_;
+		_inner_error_ = NULL;
+		_tmp12_ = stderr;
+		_tmp13_ = err;
+		_tmp14_ = _tmp13_->message;
+		fprintf (_tmp12_, "IBUS_ERROR: %s\n", _tmp14_);
+		_g_error_free0 (err);
+	}
+	__finally3:
+	if (_inner_error_ != NULL) {
+		_g_free0 (retval);
+		_g_free0 (standard_error);
+		_g_free0 (standard_output);
+		exec_command = (_vala_array_free (exec_command, exec_command_length1, (GDestroyNotify) g_free), NULL);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+		g_clear_error (&_inner_error_);
+		return NULL;
+	}
+	_tmp15_ = exit_status;
+	if (_tmp15_ != 0) {
+		const gchar* _tmp16_;
+		gchar* _tmp17_;
+		gchar* _tmp18_;
+		const gchar* _tmp19_;
+		FILE* _tmp21_;
+		const gchar* _tmp22_;
+		_tmp16_ = standard_error;
+		_tmp17_ = g_strdup (_tmp16_);
+		_tmp18_ = _tmp17_;
+		_tmp19_ = _tmp18_;
+		if (_tmp19_ == NULL) {
+			gchar* _tmp20_;
+			_tmp20_ = g_strdup ("");
+			_g_free0 (_tmp18_);
+			_tmp18_ = _tmp20_;
+		}
+		_tmp21_ = stderr;
+		_tmp22_ = _tmp18_;
+		fprintf (_tmp21_, "IBUS_ERROR: %s\n", _tmp22_);
+		_g_free0 (_tmp18_);
+	}
+	_tmp23_ = standard_output;
+	if (_tmp23_ == NULL) {
+		gchar* _tmp24_;
+		_tmp24_ = g_strdup ("");
+		result = _tmp24_;
+		_g_free0 (retval);
+		_g_free0 (standard_error);
+		_g_free0 (standard_output);
+		exec_command = (_vala_array_free (exec_command, exec_command_length1, (GDestroyNotify) g_free), NULL);
+		return result;
+	}
+	_tmp25_ = standard_output;
+	_tmp27_ = _tmp26_ = g_strsplit (_tmp25_, "\n", 0);
+	{
+		gchar** line_collection = NULL;
+		gint line_collection_length1 = 0;
+		gint _line_collection_size_ = 0;
+		gint line_it = 0;
+		line_collection = _tmp27_;
+		line_collection_length1 = _vala_array_length (_tmp26_);
+		for (line_it = 0; line_it < _vala_array_length (_tmp26_); line_it = line_it + 1) {
+			gchar* _tmp28_;
+			gchar* line = NULL;
+			_tmp28_ = g_strdup (line_collection[line_it]);
+			line = _tmp28_;
+			{
+				gboolean _tmp29_ = FALSE;
+				const gchar* _tmp30_;
+				gint _tmp31_;
+				gint _tmp32_;
+				const gchar* _tmp33_;
+				gint _tmp34_;
+				gint _tmp35_;
+				gboolean _tmp43_;
+				_tmp30_ = element;
+				_tmp31_ = strlen (_tmp30_);
+				_tmp32_ = _tmp31_;
+				_tmp33_ = line;
+				_tmp34_ = strlen (_tmp33_);
+				_tmp35_ = _tmp34_;
+				if (_tmp32_ <= _tmp35_) {
+					const gchar* _tmp36_;
+					const gchar* _tmp37_;
+					gint _tmp38_;
+					gint _tmp39_;
+					gchar* _tmp40_ = NULL;
+					gchar* _tmp41_;
+					const gchar* _tmp42_;
+					_tmp36_ = line;
+					_tmp37_ = element;
+					_tmp38_ = strlen (_tmp37_);
+					_tmp39_ = _tmp38_;
+					_tmp40_ = string_slice (_tmp36_, (glong) 0, (glong) _tmp39_);
+					_tmp41_ = _tmp40_;
+					_tmp42_ = element;
+					_tmp29_ = g_strcmp0 (_tmp41_, _tmp42_) == 0;
+					_g_free0 (_tmp41_);
+				} else {
+					_tmp29_ = FALSE;
+				}
+				_tmp43_ = _tmp29_;
+				if (_tmp43_) {
+					const gchar* _tmp44_;
+					const gchar* _tmp45_;
+					gint _tmp46_;
+					gint _tmp47_;
+					const gchar* _tmp48_;
+					gint _tmp49_;
+					gint _tmp50_;
+					gchar* _tmp51_ = NULL;
+					_tmp44_ = line;
+					_tmp45_ = element;
+					_tmp46_ = strlen (_tmp45_);
+					_tmp47_ = _tmp46_;
+					_tmp48_ = line;
+					_tmp49_ = strlen (_tmp48_);
+					_tmp50_ = _tmp49_;
+					_tmp51_ = string_slice (_tmp44_, (glong) _tmp47_, (glong) _tmp50_);
+					_g_free0 (retval);
+					retval = _tmp51_;
+				}
+				_g_free0 (line);
+			}
+		}
+		line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
+	}
+	result = retval;
+	_g_free0 (standard_error);
+	_g_free0 (standard_output);
+	exec_command = (_vala_array_free (exec_command, exec_command_length1, (GDestroyNotify) g_free), NULL);
+	return result;
+}
+
+
+static void xkb_layout_set_layout_cb (XKBLayout* self, GPid pid, gint status) {
+	GPid _tmp0_;
+	GPid _tmp1_;
+	GPid _tmp3_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_xkb_pid;
+	_tmp1_ = pid;
+	if (_tmp0_ != _tmp1_) {
+		FILE* _tmp2_;
+		_tmp2_ = stderr;
+		fprintf (_tmp2_, "IBUS_ERROR: set_layout_cb has another pid\n");
+		return;
+	}
+	_tmp3_ = self->priv->m_xkb_pid;
+	g_spawn_close_pid (_tmp3_);
+	self->priv->m_xkb_pid = (GPid) (-1);
+	xkb_layout_set_xmodmap (self);
+}
+
+
+static void xkb_layout_set_xmodmap_cb (XKBLayout* self, GPid pid, gint status) {
+	GPid _tmp0_;
+	GPid _tmp1_;
+	GPid _tmp3_;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_xmodmap_pid;
+	_tmp1_ = pid;
+	if (_tmp0_ != _tmp1_) {
+		FILE* _tmp2_;
+		_tmp2_ = stderr;
+		fprintf (_tmp2_, "IBUS_ERROR: set_xmodmap_cb has another pid\n");
+		return;
+	}
+	_tmp3_ = self->priv->m_xmodmap_pid;
+	g_spawn_close_pid (_tmp3_);
+	self->priv->m_xmodmap_pid = (GPid) (-1);
+}
+
+
+static gchar* xkb_layout_get_fullpath (XKBLayout* self, const gchar* command) {
+	gchar* result = NULL;
+	const gchar* _tmp0_ = NULL;
+	gchar* _tmp1_;
+	gchar* envpath;
+	const gchar* _tmp2_;
+	gchar** _tmp3_;
+	gchar** _tmp4_ = NULL;
+	gchar* _tmp11_;
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (command != NULL, NULL);
+	_tmp0_ = g_getenv ("PATH");
+	_tmp1_ = g_strdup (_tmp0_);
+	envpath = _tmp1_;
+	_tmp2_ = envpath;
+	_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, ":", 0);
+	{
+		gchar** dir_collection = NULL;
+		gint dir_collection_length1 = 0;
+		gint _dir_collection_size_ = 0;
+		gint dir_it = 0;
+		dir_collection = _tmp4_;
+		dir_collection_length1 = _vala_array_length (_tmp3_);
+		for (dir_it = 0; dir_it < _vala_array_length (_tmp3_); dir_it = dir_it + 1) {
+			gchar* _tmp5_;
+			gchar* dir = NULL;
+			_tmp5_ = g_strdup (dir_collection[dir_it]);
+			dir = _tmp5_;
+			{
+				const gchar* _tmp6_;
+				const gchar* _tmp7_;
+				gchar* _tmp8_ = NULL;
+				gchar* filepath;
+				const gchar* _tmp9_;
+				gboolean _tmp10_ = FALSE;
+				_tmp6_ = dir;
+				_tmp7_ = command;
+				_tmp8_ = g_build_filename (_tmp6_, _tmp7_, NULL);
+				filepath = _tmp8_;
+				_tmp9_ = filepath;
+				_tmp10_ = g_file_test (_tmp9_, G_FILE_TEST_EXISTS);
+				if (_tmp10_) {
+					result = filepath;
+					_g_free0 (dir);
+					dir_collection = (_vala_array_free (dir_collection, dir_collection_length1, (GDestroyNotify) g_free), NULL);
+					_g_free0 (envpath);
+					return result;
+				}
+				_g_free0 (filepath);
+				_g_free0 (dir);
+			}
+		}
+		dir_collection = (_vala_array_free (dir_collection, dir_collection_length1, (GDestroyNotify) g_free), NULL);
+	}
+	_tmp11_ = g_strdup ("");
+	result = _tmp11_;
+	_g_free0 (envpath);
+	return result;
+}
+
+
+static gchar** xkb_layout_get_xkb_group_layout (XKBLayout* self, const gchar* layout, const gchar* variant, gint layouts_max_length, int* result_length1) {
+	gchar** result = NULL;
+	gint group_id;
+	gint i;
+	const gchar* _tmp0_;
+	gchar** _tmp1_;
+	gchar** _tmp2_ = NULL;
+	gchar** layouts;
+	gint layouts_length1;
+	gint _layouts_size_;
+	const gchar* _tmp3_;
+	gchar** _tmp4_;
+	gchar** _tmp5_ = NULL;
+	gchar** variants;
+	gint variants_length1;
+	gint _variants_size_;
+	gchar* _tmp6_;
+	gchar* group_layouts;
+	gchar* _tmp7_;
+	gchar* group_variants;
+	gboolean has_variant;
+	gboolean include_keymap;
+	const gchar* _tmp63_;
+	gboolean _tmp64_;
+	gboolean _tmp72_;
+	const gchar* _tmp73_;
+	gchar* _tmp74_;
+	const gchar* _tmp75_;
+	gchar* _tmp76_;
+	gint _tmp77_;
+	gchar* _tmp78_ = NULL;
+	gchar** _tmp79_ = NULL;
+	gchar** _tmp80_;
+	gint _tmp80__length1;
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (layout != NULL, NULL);
+	g_return_val_if_fail (variant != NULL, NULL);
+	group_id = 0;
+	i = 0;
+	_tmp0_ = self->priv->m_default_layout;
+	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, ",", 0);
+	layouts = _tmp2_;
+	layouts_length1 = _vala_array_length (_tmp1_);
+	_layouts_size_ = layouts_length1;
+	_tmp3_ = self->priv->m_default_variant;
+	_tmp5_ = _tmp4_ = g_strsplit (_tmp3_, ",", 0);
+	variants = _tmp5_;
+	variants_length1 = _vala_array_length (_tmp4_);
+	_variants_size_ = variants_length1;
+	_tmp6_ = g_strdup ("");
+	group_layouts = _tmp6_;
+	_tmp7_ = g_strdup ("");
+	group_variants = _tmp7_;
+	has_variant = FALSE;
+	include_keymap = FALSE;
+	{
+		gboolean _tmp8_;
+		i = 0;
+		_tmp8_ = TRUE;
+		while (TRUE) {
+			gboolean _tmp9_;
+			gint _tmp11_;
+			gchar** _tmp12_;
+			gint _tmp12__length1;
+			gint _tmp13_;
+			gint _tmp14_;
+			gint _tmp15_;
+			gint _tmp25_;
+			gchar** _tmp26_;
+			gint _tmp26__length1;
+			gboolean _tmp39_ = FALSE;
+			const gchar* _tmp40_;
+			gchar** _tmp41_;
+			gint _tmp41__length1;
+			gint _tmp42_;
+			const gchar* _tmp43_;
+			gboolean _tmp48_;
+			gchar** _tmp50_;
+			gint _tmp50__length1;
+			gint _tmp51_;
+			const gchar* _tmp52_;
+			gint _tmp53_;
+			_tmp9_ = _tmp8_;
+			if (!_tmp9_) {
+				gint _tmp10_;
+				_tmp10_ = i;
+				i = _tmp10_ + 1;
+			}
+			_tmp8_ = FALSE;
+			_tmp11_ = i;
+			_tmp12_ = layouts;
+			_tmp12__length1 = layouts_length1;
+			if (!(_tmp11_ < _tmp12__length1)) {
+				break;
+			}
+			_tmp13_ = i;
+			_tmp14_ = layouts_max_length;
+			if (_tmp13_ >= (_tmp14_ - 1)) {
+				break;
+			}
+			_tmp15_ = i;
+			if (_tmp15_ == 0) {
+				gchar** _tmp16_;
+				gint _tmp16__length1;
+				gint _tmp17_;
+				const gchar* _tmp18_;
+				gchar* _tmp19_;
+				_tmp16_ = layouts;
+				_tmp16__length1 = layouts_length1;
+				_tmp17_ = i;
+				_tmp18_ = _tmp16_[_tmp17_];
+				_tmp19_ = g_strdup (_tmp18_);
+				_g_free0 (group_layouts);
+				group_layouts = _tmp19_;
+			} else {
+				const gchar* _tmp20_;
+				gchar** _tmp21_;
+				gint _tmp21__length1;
+				gint _tmp22_;
+				const gchar* _tmp23_;
+				gchar* _tmp24_ = NULL;
+				_tmp20_ = group_layouts;
+				_tmp21_ = layouts;
+				_tmp21__length1 = layouts_length1;
+				_tmp22_ = i;
+				_tmp23_ = _tmp21_[_tmp22_];
+				_tmp24_ = g_strdup_printf ("%s,%s", _tmp20_, _tmp23_);
+				_g_free0 (group_layouts);
+				group_layouts = _tmp24_;
+			}
+			_tmp25_ = i;
+			_tmp26_ = variants;
+			_tmp26__length1 = variants_length1;
+			if (_tmp25_ >= _tmp26__length1) {
+				gint _tmp27_;
+				gboolean _tmp31_ = FALSE;
+				const gchar* _tmp32_;
+				gchar** _tmp33_;
+				gint _tmp33__length1;
+				gint _tmp34_;
+				const gchar* _tmp35_;
+				gboolean _tmp37_;
+				_tmp27_ = i;
+				if (_tmp27_ == 0) {
+					gchar* _tmp28_;
+					_tmp28_ = g_strdup ("");
+					_g_free0 (group_variants);
+					group_variants = _tmp28_;
+				} else {
+					const gchar* _tmp29_;
+					gchar* _tmp30_;
+					_tmp29_ = group_variants;
+					_tmp30_ = g_strconcat (_tmp29_, ",", NULL);
+					_g_free0 (group_variants);
+					group_variants = _tmp30_;
+				}
+				_tmp32_ = layout;
+				_tmp33_ = layouts;
+				_tmp33__length1 = layouts_length1;
+				_tmp34_ = i;
+				_tmp35_ = _tmp33_[_tmp34_];
+				if (g_strcmp0 (_tmp32_, _tmp35_) == 0) {
+					const gchar* _tmp36_;
+					_tmp36_ = variant;
+					_tmp31_ = g_strcmp0 (_tmp36_, "") == 0;
+				} else {
+					_tmp31_ = FALSE;
+				}
+				_tmp37_ = _tmp31_;
+				if (_tmp37_) {
+					gint _tmp38_;
+					include_keymap = TRUE;
+					_tmp38_ = i;
+					group_id = _tmp38_;
+				}
+				continue;
+			}
+			_tmp40_ = layout;
+			_tmp41_ = layouts;
+			_tmp41__length1 = layouts_length1;
+			_tmp42_ = i;
+			_tmp43_ = _tmp41_[_tmp42_];
+			if (g_strcmp0 (_tmp40_, _tmp43_) == 0) {
+				const gchar* _tmp44_;
+				gchar** _tmp45_;
+				gint _tmp45__length1;
+				gint _tmp46_;
+				const gchar* _tmp47_;
+				_tmp44_ = variant;
+				_tmp45_ = variants;
+				_tmp45__length1 = variants_length1;
+				_tmp46_ = i;
+				_tmp47_ = _tmp45_[_tmp46_];
+				_tmp39_ = g_strcmp0 (_tmp44_, _tmp47_) == 0;
+			} else {
+				_tmp39_ = FALSE;
+			}
+			_tmp48_ = _tmp39_;
+			if (_tmp48_) {
+				gint _tmp49_;
+				include_keymap = TRUE;
+				_tmp49_ = i;
+				group_id = _tmp49_;
+			}
+			_tmp50_ = variants;
+			_tmp50__length1 = variants_length1;
+			_tmp51_ = i;
+			_tmp52_ = _tmp50_[_tmp51_];
+			if (g_strcmp0 (_tmp52_, "") != 0) {
+				has_variant = TRUE;
+			}
+			_tmp53_ = i;
+			if (_tmp53_ == 0) {
+				gchar** _tmp54_;
+				gint _tmp54__length1;
+				gint _tmp55_;
+				const gchar* _tmp56_;
+				gchar* _tmp57_;
+				_tmp54_ = variants;
+				_tmp54__length1 = variants_length1;
+				_tmp55_ = i;
+				_tmp56_ = _tmp54_[_tmp55_];
+				_tmp57_ = g_strdup (_tmp56_);
+				_g_free0 (group_variants);
+				group_variants = _tmp57_;
+			} else {
+				const gchar* _tmp58_;
+				gchar** _tmp59_;
+				gint _tmp59__length1;
+				gint _tmp60_;
+				const gchar* _tmp61_;
+				gchar* _tmp62_ = NULL;
+				_tmp58_ = group_variants;
+				_tmp59_ = variants;
+				_tmp59__length1 = variants_length1;
+				_tmp60_ = i;
+				_tmp61_ = _tmp59_[_tmp60_];
+				_tmp62_ = g_strdup_printf ("%s,%s", _tmp58_, _tmp61_);
+				_g_free0 (group_variants);
+				group_variants = _tmp62_;
+			}
+		}
+	}
+	_tmp63_ = variant;
+	if (g_strcmp0 (_tmp63_, "") != 0) {
+		has_variant = TRUE;
+	}
+	_tmp64_ = include_keymap;
+	if (!_tmp64_) {
+		const gchar* _tmp65_;
+		const gchar* _tmp66_;
+		gchar* _tmp67_ = NULL;
+		const gchar* _tmp68_;
+		const gchar* _tmp69_;
+		gchar* _tmp70_ = NULL;
+		gint _tmp71_;
+		_tmp65_ = group_layouts;
+		_tmp66_ = layout;
+		_tmp67_ = g_strdup_printf ("%s,%s", _tmp65_, _tmp66_);
+		_g_free0 (group_layouts);
+		group_layouts = _tmp67_;
+		_tmp68_ = group_variants;
+		_tmp69_ = variant;
+		_tmp70_ = g_strdup_printf ("%s,%s", _tmp68_, _tmp69_);
+		_g_free0 (group_variants);
+		group_variants = _tmp70_;
+		_tmp71_ = i;
+		group_id = _tmp71_;
+	}
+	_tmp72_ = has_variant;
+	if (!_tmp72_) {
+		_g_free0 (group_variants);
+		group_variants = NULL;
+	}
+	_tmp73_ = group_layouts;
+	_tmp74_ = g_strdup (_tmp73_);
+	_tmp75_ = group_variants;
+	_tmp76_ = g_strdup (_tmp75_);
+	_tmp77_ = group_id;
+	_tmp78_ = g_strdup_printf ("%i", _tmp77_);
+	_tmp79_ = g_new0 (gchar*, 3 + 1);
+	_tmp79_[0] = _tmp74_;
+	_tmp79_[1] = _tmp76_;
+	_tmp79_[2] = _tmp78_;
+	_tmp80_ = _tmp79_;
+	_tmp80__length1 = 3;
+	if (result_length1) {
+		*result_length1 = _tmp80__length1;
+	}
+	result = _tmp80_;
+	_g_free0 (group_variants);
+	_g_free0 (group_layouts);
+	variants = (_vala_array_free (variants, variants_length1, (GDestroyNotify) g_free), NULL);
+	layouts = (_vala_array_free (layouts, layouts_length1, (GDestroyNotify) g_free), NULL);
+	return result;
+}
+
+
+static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
+	gint result = 0;
+	gint _tmp0_;
+	const gchar* _tmp1_;
+	gchar* _tmp2_ = NULL;
+	gchar* _result_;
+	gchar* _tmp3_;
+	g_return_val_if_fail (self != NULL, 0);
+	g_return_val_if_fail (needle != NULL, 0);
+	_tmp0_ = start_index;
+	_tmp1_ = needle;
+	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
+	_result_ = _tmp2_;
+	_tmp3_ = _result_;
+	if (_tmp3_ != NULL) {
+		gchar* _tmp4_;
+		_tmp4_ = _result_;
+		result = (gint) (_tmp4_ - ((gchar*) self));
+		return result;
+	} else {
+		result = -1;
+		return result;
+	}
+}
+
+
+gchar** xkb_layout_get_variant_from_layout (XKBLayout* self, const gchar* layout, int* result_length1) {
+	gchar** result = NULL;
+	const gchar* _tmp0_;
+	gint _tmp1_ = 0;
+	gint left_bracket;
+	const gchar* _tmp2_;
+	gint _tmp3_ = 0;
+	gint right_bracket;
+	gboolean _tmp4_ = FALSE;
+	gint _tmp5_;
+	gboolean _tmp8_;
+	const gchar* _tmp28_;
+	gchar* _tmp29_;
+	gchar* _tmp30_;
+	gchar** _tmp31_ = NULL;
+	gchar** _tmp32_;
+	gint _tmp32__length1;
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (layout != NULL, NULL);
+	_tmp0_ = layout;
+	_tmp1_ = string_index_of (_tmp0_, "(", 0);
+	left_bracket = _tmp1_;
+	_tmp2_ = layout;
+	_tmp3_ = string_index_of (_tmp2_, ")", 0);
+	right_bracket = _tmp3_;
+	_tmp5_ = left_bracket;
+	if (_tmp5_ >= 0) {
+		gint _tmp6_;
+		gint _tmp7_;
+		_tmp6_ = right_bracket;
+		_tmp7_ = left_bracket;
+		_tmp4_ = _tmp6_ > _tmp7_;
+	} else {
+		_tmp4_ = FALSE;
+	}
+	_tmp8_ = _tmp4_;
+	if (_tmp8_) {
+		const gchar* _tmp9_;
+		gint _tmp10_;
+		gchar* _tmp11_ = NULL;
+		gchar* _tmp12_;
+		const gchar* _tmp13_;
+		gint _tmp14_;
+		const gchar* _tmp15_;
+		gint _tmp16_;
+		gint _tmp17_;
+		gchar* _tmp18_ = NULL;
+		gchar* _tmp19_;
+		gchar* _tmp20_;
+		const gchar* _tmp21_;
+		gint _tmp22_;
+		gint _tmp23_;
+		gchar* _tmp24_ = NULL;
+		gchar** _tmp25_ = NULL;
+		gchar** _tmp26_;
+		gint _tmp26__length1;
+		gchar** _tmp27_;
+		gint _tmp27__length1;
+		_tmp9_ = layout;
+		_tmp10_ = left_bracket;
+		_tmp11_ = string_slice (_tmp9_, (glong) 0, (glong) _tmp10_);
+		_tmp12_ = _tmp11_;
+		_tmp13_ = layout;
+		_tmp14_ = right_bracket;
+		_tmp15_ = layout;
+		_tmp16_ = strlen (_tmp15_);
+		_tmp17_ = _tmp16_;
+		_tmp18_ = string_slice (_tmp13_, (glong) (_tmp14_ + 1), (glong) _tmp17_);
+		_tmp19_ = _tmp18_;
+		_tmp20_ = g_strconcat (_tmp12_, _tmp19_, NULL);
+		_tmp21_ = layout;
+		_tmp22_ = left_bracket;
+		_tmp23_ = right_bracket;
+		_tmp24_ = string_slice (_tmp21_, (glong) (_tmp22_ + 1), (glong) _tmp23_);
+		_tmp25_ = g_new0 (gchar*, 2 + 1);
+		_tmp25_[0] = _tmp20_;
+		_tmp25_[1] = _tmp24_;
+		_tmp26_ = _tmp25_;
+		_tmp26__length1 = 2;
+		_g_free0 (_tmp19_);
+		_g_free0 (_tmp12_);
+		_tmp27_ = _tmp26_;
+		_tmp27__length1 = _tmp26__length1;
+		if (result_length1) {
+			*result_length1 = _tmp27__length1;
+		}
+		result = _tmp27_;
+		return result;
+	}
+	_tmp28_ = layout;
+	_tmp29_ = g_strdup (_tmp28_);
+	_tmp30_ = g_strdup ("default");
+	_tmp31_ = g_new0 (gchar*, 2 + 1);
+	_tmp31_[0] = _tmp29_;
+	_tmp31_[1] = _tmp30_;
+	_tmp32_ = _tmp31_;
+	_tmp32__length1 = 2;
+	if (result_length1) {
+		*result_length1 = _tmp32__length1;
+	}
+	result = _tmp32_;
+	return result;
+}
+
+
+gchar** xkb_layout_get_option_from_layout (XKBLayout* self, const gchar* layout, int* result_length1) {
+	gchar** result = NULL;
+	const gchar* _tmp0_;
+	gint _tmp1_ = 0;
+	gint left_bracket;
+	const gchar* _tmp2_;
+	gint _tmp3_ = 0;
+	gint right_bracket;
+	gboolean _tmp4_ = FALSE;
+	gint _tmp5_;
+	gboolean _tmp8_;
+	const gchar* _tmp28_;
+	gchar* _tmp29_;
+	gchar* _tmp30_;
+	gchar** _tmp31_ = NULL;
+	gchar** _tmp32_;
+	gint _tmp32__length1;
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (layout != NULL, NULL);
+	_tmp0_ = layout;
+	_tmp1_ = string_index_of (_tmp0_, "[", 0);
+	left_bracket = _tmp1_;
+	_tmp2_ = layout;
+	_tmp3_ = string_index_of (_tmp2_, "]", 0);
+	right_bracket = _tmp3_;
+	_tmp5_ = left_bracket;
+	if (_tmp5_ >= 0) {
+		gint _tmp6_;
+		gint _tmp7_;
+		_tmp6_ = right_bracket;
+		_tmp7_ = left_bracket;
+		_tmp4_ = _tmp6_ > _tmp7_;
+	} else {
+		_tmp4_ = FALSE;
+	}
+	_tmp8_ = _tmp4_;
+	if (_tmp8_) {
+		const gchar* _tmp9_;
+		gint _tmp10_;
+		gchar* _tmp11_ = NULL;
+		gchar* _tmp12_;
+		const gchar* _tmp13_;
+		gint _tmp14_;
+		const gchar* _tmp15_;
+		gint _tmp16_;
+		gint _tmp17_;
+		gchar* _tmp18_ = NULL;
+		gchar* _tmp19_;
+		gchar* _tmp20_;
+		const gchar* _tmp21_;
+		gint _tmp22_;
+		gint _tmp23_;
+		gchar* _tmp24_ = NULL;
+		gchar** _tmp25_ = NULL;
+		gchar** _tmp26_;
+		gint _tmp26__length1;
+		gchar** _tmp27_;
+		gint _tmp27__length1;
+		_tmp9_ = layout;
+		_tmp10_ = left_bracket;
+		_tmp11_ = string_slice (_tmp9_, (glong) 0, (glong) _tmp10_);
+		_tmp12_ = _tmp11_;
+		_tmp13_ = layout;
+		_tmp14_ = right_bracket;
+		_tmp15_ = layout;
+		_tmp16_ = strlen (_tmp15_);
+		_tmp17_ = _tmp16_;
+		_tmp18_ = string_slice (_tmp13_, (glong) (_tmp14_ + 1), (glong) _tmp17_);
+		_tmp19_ = _tmp18_;
+		_tmp20_ = g_strconcat (_tmp12_, _tmp19_, NULL);
+		_tmp21_ = layout;
+		_tmp22_ = left_bracket;
+		_tmp23_ = right_bracket;
+		_tmp24_ = string_slice (_tmp21_, (glong) (_tmp22_ + 1), (glong) _tmp23_);
+		_tmp25_ = g_new0 (gchar*, 2 + 1);
+		_tmp25_[0] = _tmp20_;
+		_tmp25_[1] = _tmp24_;
+		_tmp26_ = _tmp25_;
+		_tmp26__length1 = 2;
+		_g_free0 (_tmp19_);
+		_g_free0 (_tmp12_);
+		_tmp27_ = _tmp26_;
+		_tmp27__length1 = _tmp26__length1;
+		if (result_length1) {
+			*result_length1 = _tmp27__length1;
+		}
+		result = _tmp27_;
+		return result;
+	}
+	_tmp28_ = layout;
+	_tmp29_ = g_strdup (_tmp28_);
+	_tmp30_ = g_strdup ("default");
+	_tmp31_ = g_new0 (gchar*, 2 + 1);
+	_tmp31_[0] = _tmp29_;
+	_tmp31_[1] = _tmp30_;
+	_tmp32_ = _tmp31_;
+	_tmp32__length1 = 2;
+	if (result_length1) {
+		*result_length1 = _tmp32__length1;
+	}
+	result = _tmp32_;
+	return result;
+}
+
+
+gchar* xkb_layout_get_layout (XKBLayout* self) {
+	gchar* result = NULL;
+	g_return_val_if_fail (self != NULL, NULL);
+	if (HAVE_IBUS_XKB) {
+		gchar* _tmp0_ = NULL;
+		_tmp0_ = xkb_layout_get_output_from_cmdline (self, "--get", "layout: ");
+		result = _tmp0_;
+		return result;
+	} else {
+		gchar* _tmp1_ = NULL;
+		_tmp1_ = xkb_layout_get_output_from_cmdline (self, "-query", "layout: ");
+		result = _tmp1_;
+		return result;
+	}
+}
+
+
+gchar* xkb_layout_get_variant (XKBLayout* self) {
+	gchar* result = NULL;
+	g_return_val_if_fail (self != NULL, NULL);
+	if (HAVE_IBUS_XKB) {
+		gchar* _tmp0_ = NULL;
+		_tmp0_ = xkb_layout_get_output_from_cmdline (self, "--get", "variant: ");
+		result = _tmp0_;
+		return result;
+	} else {
+		gchar* _tmp1_ = NULL;
+		_tmp1_ = xkb_layout_get_output_from_cmdline (self, "-query", "variant: ");
+		result = _tmp1_;
+		return result;
+	}
+}
+
+
+gchar* xkb_layout_get_option (XKBLayout* self) {
+	gchar* result = NULL;
+	g_return_val_if_fail (self != NULL, NULL);
+	if (HAVE_IBUS_XKB) {
+		gchar* _tmp0_ = NULL;
+		_tmp0_ = xkb_layout_get_output_from_cmdline (self, "--get", "option: ");
+		result = _tmp0_;
+		return result;
+	} else {
+		gchar* _tmp1_ = NULL;
+		_tmp1_ = xkb_layout_get_output_from_cmdline (self, "-query", "options: ");
+		result = _tmp1_;
+		return result;
+	}
+}
+
+
+static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
+	int i;
+	for (i = 0; i < stack_length; i++) {
+		if (g_strcmp0 (stack[i], needle) == 0) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+
+static void _vala_array_add23 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add24 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add25 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add26 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add27 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add28 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add29 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add30 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add31 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _vala_array_add32 (gchar*** array, int* length, int* size, gchar* value) {
+	if ((*length) == (*size)) {
+		*size = (*size) ? (2 * (*size)) : 4;
+		*array = g_renew (gchar*, *array, (*size) + 1);
+	}
+	(*array)[(*length)++] = value;
+	(*array)[*length] = NULL;
+}
+
+
+static void _xkb_layout_set_layout_cb_gchild_watch_func (GPid pid, gint status, gpointer self) {
+	xkb_layout_set_layout_cb (self, pid, status);
+}
+
+
+gint* xkb_layout_set_layout (XKBLayout* self, const gchar* _layout, const gchar* _variant, const gchar* _option, int* result_length1) {
+	gint* result = NULL;
+	const gchar* _tmp0_;
+	gint xkb_group_id;
+	gint changed_option;
+	GPid _tmp1_;
+	gboolean _tmp4_ = FALSE;
+	gboolean _tmp5_ = FALSE;
+	const gchar* _tmp6_;
+	gboolean _tmp8_;
+	gboolean _tmp10_;
+	const gchar* _tmp13_;
+	gchar* _tmp14_;
+	gchar* layout;
+	const gchar* _tmp15_;
+	gchar* _tmp16_;
+	gchar* variant;
+	const gchar* _tmp17_;
+	gchar* _tmp18_;
+	gchar* option;
+	const gchar* _tmp19_;
+	const gchar* _tmp29_;
+	gboolean need_us_layout;
+	gchar** _tmp39_;
+	gint _tmp39__length1;
+	gint layouts_max_length;
+	gboolean _tmp54_;
+	const gchar* _tmp56_;
+	const gchar* _tmp58_;
+	const gchar* _tmp60_;
+	const gchar* _tmp62_;
+	const gchar* _tmp83_;
+	gboolean _tmp86_ = FALSE;
+	const gchar* _tmp87_;
+	gboolean _tmp89_;
+	gboolean _tmp90_ = FALSE;
+	const gchar* _tmp91_;
+	gboolean _tmp93_;
+	const gchar* _tmp107_;
+	gboolean _tmp108_;
+	gchar** _tmp114_ = NULL;
+	gchar** args;
+	gint args_length1;
+	gint _args_size_;
+	gchar** _tmp115_;
+	gint _tmp115__length1;
+	const gchar* _tmp116_;
+	gchar* _tmp117_;
+	GPid child_pid = 0;
+	GPid _tmp153_;
+	GPid _tmp154_;
+	gint _tmp155_;
+	gint _tmp156_;
+	gint* _tmp157_ = NULL;
+	gint* _tmp158_;
+	gint _tmp158__length1;
+	GError * _inner_error_ = NULL;
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (_layout != NULL, NULL);
+	g_return_val_if_fail (_variant != NULL, NULL);
+	g_return_val_if_fail (_option != NULL, NULL);
+	_tmp0_ = _layout;
+	g_assert (_tmp0_ != NULL);
+	xkb_group_id = 0;
+	changed_option = 0;
+	_tmp1_ = self->priv->m_xkb_pid;
+	if (_tmp1_ != ((GPid) (-1))) {
+		gint* _tmp2_ = NULL;
+		gint* _tmp3_;
+		gint _tmp3__length1;
+		_tmp2_ = g_new0 (gint, 2);
+		_tmp2_[0] = -1;
+		_tmp2_[1] = 0;
+		_tmp3_ = _tmp2_;
+		_tmp3__length1 = 2;
+		if (result_length1) {
+			*result_length1 = _tmp3__length1;
+		}
+		result = _tmp3_;
+		return result;
+	}
+	_tmp6_ = _layout;
+	if (g_strcmp0 (_tmp6_, "default") == 0) {
+		const gchar* _tmp7_;
+		_tmp7_ = _variant;
+		_tmp5_ = g_strcmp0 (_tmp7_, "default") == 0;
+	} else {
+		_tmp5_ = FALSE;
+	}
+	_tmp8_ = _tmp5_;
+	if (_tmp8_) {
+		const gchar* _tmp9_;
+		_tmp9_ = _option;
+		_tmp4_ = g_strcmp0 (_tmp9_, "default") == 0;
+	} else {
+		_tmp4_ = FALSE;
+	}
+	_tmp10_ = _tmp4_;
+	if (_tmp10_) {
+		gint* _tmp11_ = NULL;
+		gint* _tmp12_;
+		gint _tmp12__length1;
+		_tmp11_ = g_new0 (gint, 2);
+		_tmp11_[0] = -1;
+		_tmp11_[1] = 0;
+		_tmp12_ = _tmp11_;
+		_tmp12__length1 = 2;
+		if (result_length1) {
+			*result_length1 = _tmp12__length1;
+		}
+		result = _tmp12_;
+		return result;
+	}
+	_tmp13_ = _layout;
+	_tmp14_ = g_strdup (_tmp13_);
+	layout = _tmp14_;
+	_tmp15_ = _variant;
+	_tmp16_ = g_strdup (_tmp15_);
+	variant = _tmp16_;
+	_tmp17_ = _option;
+	_tmp18_ = g_strdup (_tmp17_);
+	option = _tmp18_;
+	_tmp19_ = variant;
+	if (g_strcmp0 (_tmp19_, "default") == 0) {
+		const gchar* _tmp20_;
+		gint _tmp21_ = 0;
+		gchar** _tmp22_ = NULL;
+		gchar** array;
+		gint array_length1;
+		gint _array_size_;
+		gchar** _tmp23_;
+		gint _tmp23__length1;
+		const gchar* _tmp24_;
+		gchar* _tmp25_;
+		gchar** _tmp26_;
+		gint _tmp26__length1;
+		const gchar* _tmp27_;
+		gchar* _tmp28_;
+		_tmp20_ = layout;
+		_tmp22_ = xkb_layout_get_variant_from_layout (self, _tmp20_, &_tmp21_);
+		array = _tmp22_;
+		array_length1 = _tmp21_;
+		_array_size_ = array_length1;
+		_tmp23_ = array;
+		_tmp23__length1 = array_length1;
+		_tmp24_ = _tmp23_[0];
+		_tmp25_ = g_strdup (_tmp24_);
+		_g_free0 (layout);
+		layout = _tmp25_;
+		_tmp26_ = array;
+		_tmp26__length1 = array_length1;
+		_tmp27_ = _tmp26_[1];
+		_tmp28_ = g_strdup (_tmp27_);
+		_g_free0 (variant);
+		variant = _tmp28_;
+		array = (_vala_array_free (array, array_length1, (GDestroyNotify) g_free), NULL);
+	}
+	_tmp29_ = option;
+	if (g_strcmp0 (_tmp29_, "default") == 0) {
+		const gchar* _tmp30_;
+		gint _tmp31_ = 0;
+		gchar** _tmp32_ = NULL;
+		gchar** array;
+		gint array_length1;
+		gint _array_size_;
+		gchar** _tmp33_;
+		gint _tmp33__length1;
+		const gchar* _tmp34_;
+		gchar* _tmp35_;
+		gchar** _tmp36_;
+		gint _tmp36__length1;
+		const gchar* _tmp37_;
+		gchar* _tmp38_;
+		_tmp30_ = layout;
+		_tmp32_ = xkb_layout_get_option_from_layout (self, _tmp30_, &_tmp31_);
+		array = _tmp32_;
+		array_length1 = _tmp31_;
+		_array_size_ = array_length1;
+		_tmp33_ = array;
+		_tmp33__length1 = array_length1;
+		_tmp34_ = _tmp33_[0];
+		_tmp35_ = g_strdup (_tmp34_);
+		_g_free0 (layout);
+		layout = _tmp35_;
+		_tmp36_ = array;
+		_tmp36__length1 = array_length1;
+		_tmp37_ = _tmp36_[1];
+		_tmp38_ = g_strdup (_tmp37_);
+		_g_free0 (option);
+		option = _tmp38_;
+		array = (_vala_array_free (array, array_length1, (GDestroyNotify) g_free), NULL);
+	}
+	need_us_layout = FALSE;
+	_tmp39_ = self->priv->m_xkb_latin_layouts;
+	_tmp39__length1 = self->priv->m_xkb_latin_layouts_length1;
+	{
+		gchar** latin_layout_collection = NULL;
+		gint latin_layout_collection_length1 = 0;
+		gint _latin_layout_collection_size_ = 0;
+		gint latin_layout_it = 0;
+		latin_layout_collection = _tmp39_;
+		latin_layout_collection_length1 = _tmp39__length1;
+		for (latin_layout_it = 0; latin_layout_it < _tmp39__length1; latin_layout_it = latin_layout_it + 1) {
+			gchar* _tmp40_;
+			gchar* latin_layout = NULL;
+			_tmp40_ = g_strdup (latin_layout_collection[latin_layout_it]);
+			latin_layout = _tmp40_;
+			{
+				gboolean _tmp41_ = FALSE;
+				const gchar* _tmp42_;
+				const gchar* _tmp43_;
+				gboolean _tmp45_;
+				gboolean _tmp46_ = FALSE;
+				const gchar* _tmp47_;
+				gboolean _tmp53_;
+				_tmp42_ = layout;
+				_tmp43_ = latin_layout;
+				if (g_strcmp0 (_tmp42_, _tmp43_) == 0) {
+					const gchar* _tmp44_;
+					_tmp44_ = variant;
+					_tmp41_ = g_strcmp0 (_tmp44_, "eng") != 0;
+				} else {
+					_tmp41_ = FALSE;
+				}
+				_tmp45_ = _tmp41_;
+				if (_tmp45_) {
+					need_us_layout = TRUE;
+					_g_free0 (latin_layout);
+					break;
+				}
+				_tmp47_ = variant;
+				if (_tmp47_ != NULL) {
+					const gchar* _tmp48_;
+					const gchar* _tmp49_;
+					gchar* _tmp50_ = NULL;
+					gchar* _tmp51_;
+					const gchar* _tmp52_;
+					_tmp48_ = layout;
+					_tmp49_ = variant;
+					_tmp50_ = g_strdup_printf ("%s(%s)", _tmp48_, _tmp49_);
+					_tmp51_ = _tmp50_;
+					_tmp52_ = latin_layout;
+					_tmp46_ = g_strcmp0 (_tmp51_, _tmp52_) == 0;
+					_g_free0 (_tmp51_);
+				} else {
+					_tmp46_ = FALSE;
+				}
+				_tmp53_ = _tmp46_;
+				if (_tmp53_) {
+					need_us_layout = TRUE;
+					_g_free0 (latin_layout);
+					break;
+				}
+				_g_free0 (latin_layout);
+			}
+		}
+	}
+	layouts_max_length = XKB_LAYOUTS_MAX_LENGTH;
+	_tmp54_ = need_us_layout;
+	if (_tmp54_) {
+		gint _tmp55_;
+		_tmp55_ = layouts_max_length;
+		layouts_max_length = _tmp55_ - 1;
+	}
+	_tmp56_ = self->priv->m_default_layout;
+	if (g_strcmp0 (_tmp56_, "") == 0) {
+		gchar* _tmp57_ = NULL;
+		_tmp57_ = xkb_layout_get_layout (self);
+		_g_free0 (self->priv->m_default_layout);
+		self->priv->m_default_layout = _tmp57_;
+	}
+	_tmp58_ = self->priv->m_default_variant;
+	if (g_strcmp0 (_tmp58_, "") == 0) {
+		gchar* _tmp59_ = NULL;
+		_tmp59_ = xkb_layout_get_variant (self);
+		_g_free0 (self->priv->m_default_variant);
+		self->priv->m_default_variant = _tmp59_;
+	}
+	_tmp60_ = self->priv->m_default_option;
+	if (g_strcmp0 (_tmp60_, "") == 0) {
+		gchar* _tmp61_ = NULL;
+		_tmp61_ = xkb_layout_get_option (self);
+		_g_free0 (self->priv->m_default_option);
+		self->priv->m_default_option = _tmp61_;
+	}
+	_tmp62_ = layout;
+	if (g_strcmp0 (_tmp62_, "default") == 0) {
+		const gchar* _tmp63_;
+		gchar* _tmp64_;
+		const gchar* _tmp65_;
+		gchar* _tmp66_;
+		_tmp63_ = self->priv->m_default_layout;
+		_tmp64_ = g_strdup (_tmp63_);
+		_g_free0 (layout);
+		layout = _tmp64_;
+		_tmp65_ = self->priv->m_default_variant;
+		_tmp66_ = g_strdup (_tmp65_);
+		_g_free0 (variant);
+		variant = _tmp66_;
+	} else {
+		if (HAVE_IBUS_GKBD) {
+			const gchar* _tmp67_;
+			const gchar* _tmp69_;
+			const gchar* _tmp70_;
+			gint _tmp71_;
+			gint _tmp72_ = 0;
+			gchar** _tmp73_ = NULL;
+			gchar** retval;
+			gint retval_length1;
+			gint _retval_size_;
+			gchar** _tmp74_;
+			gint _tmp74__length1;
+			const gchar* _tmp75_;
+			gchar* _tmp76_;
+			gchar** _tmp77_;
+			gint _tmp77__length1;
+			const gchar* _tmp78_;
+			gchar* _tmp79_;
+			gchar** _tmp80_;
+			gint _tmp80__length1;
+			const gchar* _tmp81_;
+			gint _tmp82_ = 0;
+			_tmp67_ = variant;
+			if (g_strcmp0 (_tmp67_, "default") == 0) {
+				gchar* _tmp68_;
+				_tmp68_ = g_strdup ("");
+				_g_free0 (variant);
+				variant = _tmp68_;
+			}
+			_tmp69_ = layout;
+			_tmp70_ = variant;
+			_tmp71_ = layouts_max_length;
+			_tmp73_ = xkb_layout_get_xkb_group_layout (self, _tmp69_, _tmp70_, _tmp71_, &_tmp72_);
+			retval = _tmp73_;
+			retval_length1 = _tmp72_;
+			_retval_size_ = retval_length1;
+			_tmp74_ = retval;
+			_tmp74__length1 = retval_length1;
+			_tmp75_ = _tmp74_[0];
+			_tmp76_ = g_strdup (_tmp75_);
+			_g_free0 (layout);
+			layout = _tmp76_;
+			_tmp77_ = retval;
+			_tmp77__length1 = retval_length1;
+			_tmp78_ = _tmp77_[1];
+			_tmp79_ = g_strdup (_tmp78_);
+			_g_free0 (variant);
+			variant = _tmp79_;
+			_tmp80_ = retval;
+			_tmp80__length1 = retval_length1;
+			_tmp81_ = _tmp80_[2];
+			_tmp82_ = atoi (_tmp81_);
+			xkb_group_id = _tmp82_;
+			retval = (_vala_array_free (retval, retval_length1, (GDestroyNotify) g_free), NULL);
+		}
+	}
+	_tmp83_ = layout;
+	if (g_strcmp0 (_tmp83_, "") == 0) {
+		gint* _tmp84_ = NULL;
+		gint* _tmp85_;
+		gint _tmp85__length1;
+		g_warning ("xkblayout.vala:329: Could not get the correct layout");
+		_tmp84_ = g_new0 (gint, 2);
+		_tmp84_[0] = -1;
+		_tmp84_[1] = 0;
+		_tmp85_ = _tmp84_;
+		_tmp85__length1 = 2;
+		if (result_length1) {
+			*result_length1 = _tmp85__length1;
+		}
+		result = _tmp85_;
+		_g_free0 (option);
+		_g_free0 (variant);
+		_g_free0 (layout);
+		return result;
+	}
+	_tmp87_ = variant;
+	if (g_strcmp0 (_tmp87_, "default") == 0) {
+		_tmp86_ = TRUE;
+	} else {
+		const gchar* _tmp88_;
+		_tmp88_ = variant;
+		_tmp86_ = g_strcmp0 (_tmp88_, "") == 0;
+	}
+	_tmp89_ = _tmp86_;
+	if (_tmp89_) {
+		_g_free0 (variant);
+		variant = NULL;
+	}
+	_tmp91_ = option;
+	if (g_strcmp0 (_tmp91_, "default") == 0) {
+		_tmp90_ = TRUE;
+	} else {
+		const gchar* _tmp92_;
+		_tmp92_ = option;
+		_tmp90_ = g_strcmp0 (_tmp92_, "") == 0;
+	}
+	_tmp93_ = _tmp90_;
+	if (_tmp93_) {
+		const gchar* _tmp94_;
+		gchar* _tmp95_;
+		_tmp94_ = self->priv->m_default_option;
+		_tmp95_ = g_strdup (_tmp94_);
+		_g_free0 (option);
+		option = _tmp95_;
+	} else {
+		const gchar* _tmp96_;
+		const gchar* _tmp97_;
+		gchar** _tmp98_;
+		gchar** _tmp99_ = NULL;
+		gchar** _tmp100_;
+		gint _tmp100__length1;
+		gboolean _tmp101_;
+		_tmp96_ = option;
+		_tmp97_ = self->priv->m_default_option;
+		_tmp99_ = _tmp98_ = g_strsplit (_tmp97_, ",", 0);
+		_tmp100_ = _tmp99_;
+		_tmp100__length1 = _vala_array_length (_tmp98_);
+		_tmp101_ = !_vala_string_array_contains (_tmp100_, _vala_array_length (_tmp98_), _tmp96_);
+		_tmp100_ = (_vala_array_free (_tmp100_, _tmp100__length1, (GDestroyNotify) g_free), NULL);
+		if (_tmp101_) {
+			const gchar* _tmp102_;
+			const gchar* _tmp103_;
+			gchar* _tmp104_ = NULL;
+			_tmp102_ = self->priv->m_default_option;
+			_tmp103_ = option;
+			_tmp104_ = g_strdup_printf ("%s,%s", _tmp102_, _tmp103_);
+			_g_free0 (option);
+			option = _tmp104_;
+			changed_option = 1;
+		} else {
+			const gchar* _tmp105_;
+			gchar* _tmp106_;
+			_tmp105_ = self->priv->m_default_option;
+			_tmp106_ = g_strdup (_tmp105_);
+			_g_free0 (option);
+			option = _tmp106_;
+		}
+	}
+	_tmp107_ = option;
+	if (g_strcmp0 (_tmp107_, "") == 0) {
+		_g_free0 (option);
+		option = NULL;
+	}
+	_tmp108_ = need_us_layout;
+	if (_tmp108_) {
+		const gchar* _tmp109_;
+		gchar* _tmp110_;
+		const gchar* _tmp111_;
+		_tmp109_ = layout;
+		_tmp110_ = g_strconcat (_tmp109_, ",us", NULL);
+		_g_free0 (layout);
+		layout = _tmp110_;
+		_tmp111_ = variant;
+		if (_tmp111_ != NULL) {
+			const gchar* _tmp112_;
+			gchar* _tmp113_;
+			_tmp112_ = variant;
+			_tmp113_ = g_strconcat (_tmp112_, ",", NULL);
+			_g_free0 (variant);
+			variant = _tmp113_;
+		}
+	}
+	_tmp114_ = g_new0 (gchar*, 0 + 1);
+	args = _tmp114_;
+	args_length1 = 0;
+	_args_size_ = args_length1;
+	_tmp115_ = args;
+	_tmp115__length1 = args_length1;
+	_tmp116_ = self->priv->m_xkb_command;
+	_tmp117_ = g_strdup (_tmp116_);
+	_vala_array_add23 (&args, &args_length1, &_args_size_, _tmp117_);
+	if (HAVE_IBUS_XKB) {
+		gchar** _tmp118_;
+		gint _tmp118__length1;
+		gchar* _tmp119_;
+		gchar** _tmp120_;
+		gint _tmp120__length1;
+		const gchar* _tmp121_;
+		gchar* _tmp122_;
+		const gchar* _tmp123_;
+		const gchar* _tmp129_;
+		_tmp118_ = args;
+		_tmp118__length1 = args_length1;
+		_tmp119_ = g_strdup ("--layout");
+		_vala_array_add24 (&args, &args_length1, &_args_size_, _tmp119_);
+		_tmp120_ = args;
+		_tmp120__length1 = args_length1;
+		_tmp121_ = layout;
+		_tmp122_ = g_strdup (_tmp121_);
+		_vala_array_add25 (&args, &args_length1, &_args_size_, _tmp122_);
+		_tmp123_ = variant;
+		if (_tmp123_ != NULL) {
+			gchar** _tmp124_;
+			gint _tmp124__length1;
+			gchar* _tmp125_;
+			gchar** _tmp126_;
+			gint _tmp126__length1;
+			const gchar* _tmp127_;
+			gchar* _tmp128_;
+			_tmp124_ = args;
+			_tmp124__length1 = args_length1;
+			_tmp125_ = g_strdup ("--variant");
+			_vala_array_add26 (&args, &args_length1, &_args_size_, _tmp125_);
+			_tmp126_ = args;
+			_tmp126__length1 = args_length1;
+			_tmp127_ = variant;
+			_tmp128_ = g_strdup (_tmp127_);
+			_vala_array_add27 (&args, &args_length1, &_args_size_, _tmp128_);
+		}
+		_tmp129_ = option;
+		if (_tmp129_ != NULL) {
+			gchar** _tmp130_;
+			gint _tmp130__length1;
+			gchar* _tmp131_;
+			gchar** _tmp132_;
+			gint _tmp132__length1;
+			const gchar* _tmp133_;
+			gchar* _tmp134_;
+			_tmp130_ = args;
+			_tmp130__length1 = args_length1;
+			_tmp131_ = g_strdup ("--option");
+			_vala_array_add28 (&args, &args_length1, &_args_size_, _tmp131_);
+			_tmp132_ = args;
+			_tmp132__length1 = args_length1;
+			_tmp133_ = option;
+			_tmp134_ = g_strdup (_tmp133_);
+			_vala_array_add29 (&args, &args_length1, &_args_size_, _tmp134_);
+		}
+	} else {
+		gchar** _tmp135_;
+		gint _tmp135__length1;
+		const gchar* _tmp136_;
+		gchar* _tmp137_;
+		const gchar* _tmp138_;
+		const gchar* _tmp142_;
+		_tmp135_ = args;
+		_tmp135__length1 = args_length1;
+		_tmp136_ = layout;
+		_tmp137_ = g_strdup (_tmp136_);
+		_vala_array_add30 (&args, &args_length1, &_args_size_, _tmp137_);
+		_tmp138_ = variant;
+		if (_tmp138_ != NULL) {
+			gchar** _tmp139_;
+			gint _tmp139__length1;
+			const gchar* _tmp140_;
+			gchar* _tmp141_;
+			_tmp139_ = args;
+			_tmp139__length1 = args_length1;
+			_tmp140_ = variant;
+			_tmp141_ = g_strdup (_tmp140_);
+			_vala_array_add31 (&args, &args_length1, &_args_size_, _tmp141_);
+		}
+		_tmp142_ = option;
+		if (_tmp142_ != NULL) {
+			gchar** _tmp143_;
+			gint _tmp143__length1;
+			const gchar* _tmp144_;
+			gchar* _tmp145_;
+			_tmp143_ = args;
+			_tmp143__length1 = args_length1;
+			_tmp144_ = option;
+			_tmp145_ = g_strdup (_tmp144_);
+			_vala_array_add32 (&args, &args_length1, &_args_size_, _tmp145_);
+		}
+	}
+	{
+		gchar** _tmp146_;
+		gint _tmp146__length1;
+		GPid _tmp147_ = 0;
+		_tmp146_ = args;
+		_tmp146__length1 = args_length1;
+		g_spawn_async (NULL, _tmp146_, NULL, G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp147_, &_inner_error_);
+		child_pid = _tmp147_;
+		if (_inner_error_ != NULL) {
+			if (_inner_error_->domain == G_SPAWN_ERROR) {
+				goto __catch4_g_spawn_error;
+			}
+			args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
+			_g_free0 (option);
+			_g_free0 (variant);
+			_g_free0 (layout);
+			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+			g_clear_error (&_inner_error_);
+			return NULL;
+		}
+	}
+	goto __finally4;
+	__catch4_g_spawn_error:
+	{
+		GError* err = NULL;
+		FILE* _tmp148_;
+		GError* _tmp149_;
+		const gchar* _tmp150_;
+		gint* _tmp151_ = NULL;
+		gint* _tmp152_;
+		gint _tmp152__length1;
+		err = _inner_error_;
+		_inner_error_ = NULL;
+		_tmp148_ = stderr;
+		_tmp149_ = err;
+		_tmp150_ = _tmp149_->message;
+		fprintf (_tmp148_, "IBUS_ERROR: %s\n", _tmp150_);
+		_tmp151_ = g_new0 (gint, 2);
+		_tmp151_[0] = -1;
+		_tmp151_[1] = 0;
+		_tmp152_ = _tmp151_;
+		_tmp152__length1 = 2;
+		if (result_length1) {
+			*result_length1 = _tmp152__length1;
+		}
+		result = _tmp152_;
+		_g_error_free0 (err);
+		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
+		_g_free0 (option);
+		_g_free0 (variant);
+		_g_free0 (layout);
+		return result;
+	}
+	__finally4:
+	if (_inner_error_ != NULL) {
+		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
+		_g_free0 (option);
+		_g_free0 (variant);
+		_g_free0 (layout);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+		g_clear_error (&_inner_error_);
+		return NULL;
+	}
+	_tmp153_ = child_pid;
+	self->priv->m_xkb_pid = _tmp153_;
+	_tmp154_ = self->priv->m_xkb_pid;
+	g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp154_, _xkb_layout_set_layout_cb_gchild_watch_func, xkb_layout_ref (self), xkb_layout_unref);
+	_tmp155_ = xkb_group_id;
+	_tmp156_ = changed_option;
+	_tmp157_ = g_new0 (gint, 2);
+	_tmp157_[0] = _tmp155_;
+	_tmp157_[1] = _tmp156_;
+	_tmp158_ = _tmp157_;
+	_tmp158__length1 = 2;
+	if (result_length1) {
+		*result_length1 = _tmp158__length1;
+	}
+	result = _tmp158_;
+	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
+	_g_free0 (option);
+	_g_free0 (variant);
+	_g_free0 (layout);
+	return result;
+}
+
+
+static void _xkb_layout_set_xmodmap_cb_gchild_watch_func (GPid pid, gint status, gpointer self) {
+	xkb_layout_set_xmodmap_cb (self, pid, status);
+}
+
+
+void xkb_layout_set_xmodmap (XKBLayout* self) {
+	gboolean _tmp0_;
+	GPid _tmp1_;
+	const gchar* _tmp2_;
+	gchar* _tmp3_ = NULL;
+	gchar* xmodmap_cmdpath;
+	const gchar* _tmp4_;
+	const gchar* _tmp7_ = NULL;
+	gchar* _tmp8_;
+	gchar* homedir;
+	gchar** _tmp9_;
+	gint _tmp9__length1;
+	GError * _inner_error_ = NULL;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->priv->m_use_xmodmap;
+	if (!_tmp0_) {
+		return;
+	}
+	_tmp1_ = self->priv->m_xmodmap_pid;
+	if (_tmp1_ != ((GPid) (-1))) {
+		return;
+	}
+	_tmp2_ = self->priv->m_xmodmap_command;
+	_tmp3_ = xkb_layout_get_fullpath (self, _tmp2_);
+	xmodmap_cmdpath = _tmp3_;
+	_tmp4_ = xmodmap_cmdpath;
+	if (g_strcmp0 (_tmp4_, "") == 0) {
+		const gchar* _tmp5_;
+		gchar* _tmp6_;
+		_tmp5_ = self->priv->m_xmodmap_command;
+		_tmp6_ = g_strdup (_tmp5_);
+		_g_free0 (xmodmap_cmdpath);
+		xmodmap_cmdpath = _tmp6_;
+	}
+	_tmp7_ = g_get_home_dir ();
+	_tmp8_ = g_strdup (_tmp7_);
+	homedir = _tmp8_;
+	_tmp9_ = self->priv->m_xmodmap_known_files;
+	_tmp9__length1 = self->priv->m_xmodmap_known_files_length1;
+	{
+		gchar** xmodmap_file_collection = NULL;
+		gint xmodmap_file_collection_length1 = 0;
+		gint _xmodmap_file_collection_size_ = 0;
+		gint xmodmap_file_it = 0;
+		xmodmap_file_collection = _tmp9_;
+		xmodmap_file_collection_length1 = _tmp9__length1;
+		for (xmodmap_file_it = 0; xmodmap_file_it < _tmp9__length1; xmodmap_file_it = xmodmap_file_it + 1) {
+			gchar* _tmp10_;
+			gchar* xmodmap_file = NULL;
+			_tmp10_ = g_strdup (xmodmap_file_collection[xmodmap_file_it]);
+			xmodmap_file = _tmp10_;
+			{
+				const gchar* _tmp11_;
+				const gchar* _tmp12_;
+				gchar* _tmp13_ = NULL;
+				gchar* xmodmap_filepath;
+				const gchar* _tmp14_;
+				gboolean _tmp15_ = FALSE;
+				const gchar* _tmp16_;
+				gchar* _tmp17_;
+				const gchar* _tmp18_;
+				gchar* _tmp19_;
+				gchar** _tmp20_ = NULL;
+				gchar** args;
+				gint args_length1;
+				gint _args_size_;
+				GPid child_pid = 0;
+				GPid _tmp26_;
+				GPid _tmp27_;
+				_tmp11_ = homedir;
+				_tmp12_ = xmodmap_file;
+				_tmp13_ = g_build_filename (_tmp11_, _tmp12_, NULL);
+				xmodmap_filepath = _tmp13_;
+				_tmp14_ = xmodmap_filepath;
+				_tmp15_ = g_file_test (_tmp14_, G_FILE_TEST_EXISTS);
+				if (!_tmp15_) {
+					_g_free0 (xmodmap_filepath);
+					_g_free0 (xmodmap_file);
+					continue;
+				}
+				_tmp16_ = xmodmap_cmdpath;
+				_tmp17_ = g_strdup (_tmp16_);
+				_tmp18_ = xmodmap_filepath;
+				_tmp19_ = g_strdup (_tmp18_);
+				_tmp20_ = g_new0 (gchar*, 2 + 1);
+				_tmp20_[0] = _tmp17_;
+				_tmp20_[1] = _tmp19_;
+				args = _tmp20_;
+				args_length1 = 2;
+				_args_size_ = args_length1;
+				{
+					gchar** _tmp21_;
+					gint _tmp21__length1;
+					GPid _tmp22_ = 0;
+					_tmp21_ = args;
+					_tmp21__length1 = args_length1;
+					g_spawn_async (NULL, _tmp21_, NULL, G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp22_, &_inner_error_);
+					child_pid = _tmp22_;
+					if (_inner_error_ != NULL) {
+						if (_inner_error_->domain == G_SPAWN_ERROR) {
+							goto __catch5_g_spawn_error;
+						}
+						args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
+						_g_free0 (xmodmap_filepath);
+						_g_free0 (xmodmap_file);
+						_g_free0 (homedir);
+						_g_free0 (xmodmap_cmdpath);
+						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+						g_clear_error (&_inner_error_);
+						return;
+					}
+				}
+				goto __finally5;
+				__catch5_g_spawn_error:
+				{
+					GError* err = NULL;
+					FILE* _tmp23_;
+					GError* _tmp24_;
+					const gchar* _tmp25_;
+					err = _inner_error_;
+					_inner_error_ = NULL;
+					_tmp23_ = stderr;
+					_tmp24_ = err;
+					_tmp25_ = _tmp24_->message;
+					fprintf (_tmp23_, "IBUS_ERROR: %s\n", _tmp25_);
+					_g_error_free0 (err);
+					args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
+					_g_free0 (xmodmap_filepath);
+					_g_free0 (xmodmap_file);
+					_g_free0 (homedir);
+					_g_free0 (xmodmap_cmdpath);
+					return;
+				}
+				__finally5:
+				if (_inner_error_ != NULL) {
+					args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
+					_g_free0 (xmodmap_filepath);
+					_g_free0 (xmodmap_file);
+					_g_free0 (homedir);
+					_g_free0 (xmodmap_cmdpath);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+					g_clear_error (&_inner_error_);
+					return;
+				}
+				_tmp26_ = child_pid;
+				self->priv->m_xmodmap_pid = _tmp26_;
+				_tmp27_ = self->priv->m_xmodmap_pid;
+				g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp27_, _xkb_layout_set_xmodmap_cb_gchild_watch_func, xkb_layout_ref (self), xkb_layout_unref);
+				args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
+				_g_free0 (xmodmap_filepath);
+				_g_free0 (xmodmap_file);
+				break;
+			}
+		}
+	}
+	_g_free0 (homedir);
+	_g_free0 (xmodmap_cmdpath);
+}
+
+
+void xkb_layout_reset_layout (XKBLayout* self) {
+	gchar* _tmp0_ = NULL;
+	gchar* _tmp1_ = NULL;
+	gchar* _tmp2_ = NULL;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = xkb_layout_get_layout (self);
+	_g_free0 (self->priv->m_default_layout);
+	self->priv->m_default_layout = _tmp0_;
+	_tmp1_ = xkb_layout_get_variant (self);
+	_g_free0 (self->priv->m_default_variant);
+	self->priv->m_default_variant = _tmp1_;
+	_tmp2_ = xkb_layout_get_option (self);
+	_g_free0 (self->priv->m_default_option);
+	self->priv->m_default_option = _tmp2_;
+}
+
+
+static void value_xkb_layout_init (GValue* value) {
+	value->data[0].v_pointer = NULL;
+}
+
+
+static void value_xkb_layout_free_value (GValue* value) {
+	if (value->data[0].v_pointer) {
+		xkb_layout_unref (value->data[0].v_pointer);
+	}
+}
+
+
+static void value_xkb_layout_copy_value (const GValue* src_value, GValue* dest_value) {
+	if (src_value->data[0].v_pointer) {
+		dest_value->data[0].v_pointer = xkb_layout_ref (src_value->data[0].v_pointer);
+	} else {
+		dest_value->data[0].v_pointer = NULL;
+	}
+}
+
+
+static gpointer value_xkb_layout_peek_pointer (const GValue* value) {
+	return value->data[0].v_pointer;
+}
+
+
+static gchar* value_xkb_layout_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
+	if (collect_values[0].v_pointer) {
+		XKBLayout* object;
+		object = collect_values[0].v_pointer;
+		if (object->parent_instance.g_class == NULL) {
+			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
+		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
+			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
+		}
+		value->data[0].v_pointer = xkb_layout_ref (object);
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	return NULL;
+}
+
+
+static gchar* value_xkb_layout_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
+	XKBLayout** object_p;
+	object_p = collect_values[0].v_pointer;
+	if (!object_p) {
+		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
+	}
+	if (!value->data[0].v_pointer) {
+		*object_p = NULL;
+	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
+		*object_p = value->data[0].v_pointer;
+	} else {
+		*object_p = xkb_layout_ref (value->data[0].v_pointer);
+	}
+	return NULL;
+}
+
+
+GParamSpec* param_spec_xkb_layout (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
+	ParamSpecXKBLayout* spec;
+	g_return_val_if_fail (g_type_is_a (object_type, TYPE_XKB_LAYOUT), NULL);
+	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
+	G_PARAM_SPEC (spec)->value_type = object_type;
+	return G_PARAM_SPEC (spec);
+}
+
+
+gpointer value_get_xkb_layout (const GValue* value) {
+	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_XKB_LAYOUT), NULL);
+	return value->data[0].v_pointer;
+}
+
+
+void value_set_xkb_layout (GValue* value, gpointer v_object) {
+	XKBLayout* old;
+	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_XKB_LAYOUT));
+	old = value->data[0].v_pointer;
+	if (v_object) {
+		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_XKB_LAYOUT));
+		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
+		value->data[0].v_pointer = v_object;
+		xkb_layout_ref (value->data[0].v_pointer);
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	if (old) {
+		xkb_layout_unref (old);
+	}
+}
+
+
+void value_take_xkb_layout (GValue* value, gpointer v_object) {
+	XKBLayout* old;
+	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_XKB_LAYOUT));
+	old = value->data[0].v_pointer;
+	if (v_object) {
+		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_XKB_LAYOUT));
+		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
+		value->data[0].v_pointer = v_object;
+	} else {
+		value->data[0].v_pointer = NULL;
+	}
+	if (old) {
+		xkb_layout_unref (old);
+	}
+}
+
+
+static void xkb_layout_class_init (XKBLayoutClass * klass) {
+	xkb_layout_parent_class = g_type_class_peek_parent (klass);
+	XKB_LAYOUT_CLASS (klass)->finalize = xkb_layout_finalize;
+	g_type_class_add_private (klass, sizeof (XKBLayoutPrivate));
+}
+
+
+static void xkb_layout_instance_init (XKBLayout * self) {
+	gchar* _tmp0_;
+	gchar** _tmp1_ = NULL;
+	gchar* _tmp2_;
+	gchar* _tmp3_;
+	gchar* _tmp4_;
+	gchar* _tmp5_;
+	gchar* _tmp6_;
+	gchar** _tmp7_ = NULL;
+	gchar* _tmp8_;
+	gchar* _tmp9_;
+	gchar* _tmp10_;
+	self->priv = XKB_LAYOUT_GET_PRIVATE (self);
+	_tmp0_ = g_strdup (IBUS_XKB_COMMAND);
+	self->priv->m_xkb_command = _tmp0_;
+	self->priv->m_config = NULL;
+	_tmp1_ = g_new0 (gchar*, 0 + 1);
+	self->priv->m_xkb_latin_layouts = _tmp1_;
+	self->priv->m_xkb_latin_layouts_length1 = 0;
+	self->priv->_m_xkb_latin_layouts_size_ = self->priv->m_xkb_latin_layouts_length1;
+	self->priv->m_xkb_pid = (GPid) (-1);
+	self->priv->m_xmodmap_pid = (GPid) (-1);
+	_tmp2_ = g_strdup ("xmodmap");
+	self->priv->m_xmodmap_command = _tmp2_;
+	self->priv->m_use_xmodmap = TRUE;
+	_tmp3_ = g_strdup (".xmodmap");
+	_tmp4_ = g_strdup (".xmodmaprc");
+	_tmp5_ = g_strdup (".Xmodmap");
+	_tmp6_ = g_strdup (".Xmodmaprc");
+	_tmp7_ = g_new0 (gchar*, 4 + 1);
+	_tmp7_[0] = _tmp3_;
+	_tmp7_[1] = _tmp4_;
+	_tmp7_[2] = _tmp5_;
+	_tmp7_[3] = _tmp6_;
+	self->priv->m_xmodmap_known_files = _tmp7_;
+	self->priv->m_xmodmap_known_files_length1 = 4;
+	self->priv->_m_xmodmap_known_files_size_ = self->priv->m_xmodmap_known_files_length1;
+	_tmp8_ = g_strdup ("");
+	self->priv->m_default_layout = _tmp8_;
+	_tmp9_ = g_strdup ("");
+	self->priv->m_default_variant = _tmp9_;
+	_tmp10_ = g_strdup ("");
+	self->priv->m_default_option = _tmp10_;
+	self->ref_count = 1;
+}
+
+
+static void xkb_layout_finalize (XKBLayout* obj) {
+	XKBLayout * self;
+	self = XKB_LAYOUT (obj);
+	_g_free0 (self->priv->m_xkb_command);
+	_g_object_unref0 (self->priv->m_config);
+	self->priv->m_xkb_latin_layouts = (_vala_array_free (self->priv->m_xkb_latin_layouts, self->priv->m_xkb_latin_layouts_length1, (GDestroyNotify) g_free), NULL);
+	_g_free0 (self->priv->m_xmodmap_command);
+	self->priv->m_xmodmap_known_files = (_vala_array_free (self->priv->m_xmodmap_known_files, self->priv->m_xmodmap_known_files_length1, (GDestroyNotify) g_free), NULL);
+	_g_free0 (self->priv->m_default_layout);
+	_g_free0 (self->priv->m_default_variant);
+	_g_free0 (self->priv->m_default_option);
+}
+
+
+GType xkb_layout_get_type (void) {
+	static volatile gsize xkb_layout_type_id__volatile = 0;
+	if (g_once_init_enter (&xkb_layout_type_id__volatile)) {
+		static const GTypeValueTable g_define_type_value_table = { value_xkb_layout_init, value_xkb_layout_free_value, value_xkb_layout_copy_value, value_xkb_layout_peek_pointer, "p", value_xkb_layout_collect_value, "p", value_xkb_layout_lcopy_value };
+		static const GTypeInfo g_define_type_info = { sizeof (XKBLayoutClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xkb_layout_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (XKBLayout), 0, (GInstanceInitFunc) xkb_layout_instance_init, &g_define_type_value_table };
+		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
+		GType xkb_layout_type_id;
+		xkb_layout_type_id = g_type_register_fundamental (g_type_fundamental_next (), "XKBLayout", &g_define_type_info, &g_define_type_fundamental_info, 0);
+		g_once_init_leave (&xkb_layout_type_id__volatile, xkb_layout_type_id);
+	}
+	return xkb_layout_type_id__volatile;
+}
+
+
+gpointer xkb_layout_ref (gpointer instance) {
+	XKBLayout* self;
+	self = instance;
+	g_atomic_int_inc (&self->ref_count);
+	return instance;
+}
+
+
+void xkb_layout_unref (gpointer instance) {
+	XKBLayout* self;
+	self = instance;
+	if (g_atomic_int_dec_and_test (&self->ref_count)) {
+		XKB_LAYOUT_GET_CLASS (self)->finalize (self);
+		g_type_free_instance ((GTypeInstance *) self);
+	}
+}
+
+
+static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
+	if ((array != NULL) && (destroy_func != NULL)) {
+		int i;
+		for (i = 0; i < array_length; i = i + 1) {
+			if (((gpointer*) array)[i] != NULL) {
+				destroy_func (((gpointer*) array)[i]);
+			}
+		}
+	}
+}
+
+
+static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
+	_vala_array_destroy (array, array_length, destroy_func);
+	g_free (array);
+}
+
+
+static gint _vala_array_length (gpointer array) {
+	int length;
+	length = 0;
+	if (array) {
+		while (((gpointer*) array)[length]) {
+			length++;
+		}
+	}
+	return length;
+}
+
+
+
